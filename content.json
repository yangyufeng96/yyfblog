{"meta":{"title":"峰享会","subtitle":"漫道求索","description":"集合了开发技能，生活趣事，未来科技，情感互动于一体。","author":"漫道求索","url":"https://yangyfeng.github.io"},"pages":[{"title":"404 Not Found","date":"2020-09-08T09:57:47.453Z","updated":"2020-09-08T09:57:47.453Z","comments":true,"path":"404.html","permalink":"https://yangyfeng.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-03-03T06:38:11.376Z","updated":"2021-03-03T06:38:11.376Z","comments":true,"path":"about/index.html","permalink":"https://yangyfeng.github.io/about/index.html","excerpt":"","text":"A Bout Me峰享会这是一个个人技术，身边趣事的分享博客 关于我​ 快乐小前端，北漂码农。古风音乐爱好者。从业数据可视化，各种花里胡哨中看门道（最快分析出最有价值的数据）。 ​ 每写一行代码，都是人类的一次进步！欧力给，嘻嘻嘻。也就10年青春饭，该打的鸡血还是要的（捂脸ing）。 ​ 文章不定时更新，会发的有点慢（写的太Low，或者没有看到优秀的原创，也有极少可能是最近工作太顺了，简单东西留不得台面，哈哈哈哈）。 ​ 再细微的进步在日积月累中也能变成中流砥柱，加油吧，打工人，程序猿们，还有少年如我的自己 😝😝😝。 ​ 欢迎留言～ 关于博客​ 博客基于Hexo，主题照抄hexo-theme-material-x，使用的Live2d（可爱的小姐姐要多少有多少，很开心），模型文件可直接引用。评论是Gittalk，直接关联自己的Gihub，程序猿必备技能。 ​ Github静态服务托管，自动同步到个人云服务器，方便快捷！"},{"title":"我的朋友们","date":"2021-03-04T01:59:40.578Z","updated":"2021-03-04T01:59:40.578Z","comments":true,"path":"friends/index.html","permalink":"https://yangyfeng.github.io/friends/index.html","excerpt":"","text":"海内存知己，天涯若比邻！ 相见即是缘分，欢迎各位大佬留言互换友链！ 必须要有名称、头像链接、至少一个标签或者一个简介哦～ 各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 漫道求索头像： https://s2.ax1x.com/2019/07/12/Zhm4jf.jpg网址： http://yangyfeng.com/标签： 前端开发、大数据可视化"},{"title":"所有标签","date":"2020-09-08T09:57:47.521Z","updated":"2020-09-08T09:57:47.521Z","comments":true,"path":"blogpost/tags/index.html","permalink":"https://yangyfeng.github.io/blogpost/tags/index.html","excerpt":"","text":""},{"title":"所有归档","date":"2020-09-08T09:57:47.520Z","updated":"2020-09-08T09:57:47.520Z","comments":true,"path":"blogpost/archives/index.html","permalink":"https://yangyfeng.github.io/blogpost/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-09-08T09:57:47.521Z","updated":"2020-09-08T09:57:47.521Z","comments":true,"path":"blogpost/categories/index.html","permalink":"https://yangyfeng.github.io/blogpost/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"React知识点集合","slug":"前端每日一题/React知识点集合","date":"2021-03-06T16:00:00.000Z","updated":"2021-03-07T05:15:29.295Z","comments":true,"path":"/posts/13437c1d.html","link":"","permalink":"https://yangyfeng.github.io/posts/13437c1d.html","excerpt":"","text":"React 什么时候使用状态管理器？ render函数中return如果没有使用()会有什么问题？ componentWillUpdate可以直接修改state的值吗？ 说说你对React的渲染原理的理解 什么渲染劫持？ React Intl是什么原理？ 你有使用过React Intl吗？ 怎么实现React组件的国际化呢？ 说说Context有哪些属性？ 怎么使用Context开发组件？ 为什么React并不推荐我们优先考虑使用Context？ 除了实例的属性可以获取Context外哪些地方还能直接获取Context呢？ childContextTypes是什么？它有什么用？ contextType是什么？它有什么用？ Consumer向上找不到Provider的时候怎么办？ 有使用过Consumer吗？ 在React怎么使用Context？ React15和16别支持IE几以上？ 说说你对windowing的了解 举例说明React的插槽有哪些运用场景？ 你有用过React的插槽(Portals)吗？怎么用？ React的严格模式有什么用处？ React如何进行代码拆分？拆分的原则是什么？ React组件的构造函数有什么作用？ React组件的构造函数是必须的吗？ React中在哪捕获错误？ React怎样引入svg的文件？ 说说你对Relay的理解 在React中你有经常使用常量吗？ 为什么说React中的props是只读的？ 你有使用过formik库吗？说说它的优缺点 你有用过哪些React的表单库吗？说说它们的优缺点 如果组件的属性没有传值，那么它的默认值是什么？ 可以使用TypeScript写React应用吗？怎么操作？ super()和super(props)有什么区别？ 你有使用过loadable组件吗？它帮我们解决了什么问题？ 你有使用过suspense组件吗？它帮我们解决了什么问题？ 怎样动态导入组件？ 如何给非控组件设置默认的值？ 怎么在React中引入其它的UI库，例如Bootstrap 怎样将事件传递给子组件？ 怎样使用Hooks获取服务端数据？ 使用Hooks要遵守哪些原则？ render方法的原理你有了解吗？它返回的数据类型是什么？ useEffect和useLayoutEffect有什么区别？ 在React项目中你用过哪些动画的包？ React必须使用JSX吗？ 自定义组件时render是可选的吗？为什么？ 需要把keys设置为全局唯一吗？ 怎么定时更新一个组件？ React根据不同的环境打包不同的域名？ 使用webpack打包React项目，怎么减小生成的js大小？ 在React中怎么使用async/await？ 你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？ 什么是React.forwardRef？它有什么作用？ 写个例子说明什么是JSX的内联条件渲染 在React中怎么将参数传递给事件？ React的事件和普通的HTML事件有什么不同？ 在React中怎么阻止事件的默认行为？ 你最喜欢React的哪一个特性（说一个就好）？ 在React中什么时候使用箭头函数更方便呢？ 你最不喜欢React的哪一个特性（说一个就好）？ 说说你对React的reconciliation（一致化算法）的理解 使用PropTypes和Flow有什么区别？ 怎样有条件地渲染组件？ 在JSX中如何写注释？ constructor和getInitialState有不同？ 写例子说明React如何在JSX中实现for循环 为什么建议Fragment包裹元素？它的简写是什么？ 你有用过React.Fragment吗？说说它有什么用途？ 在React中你有遇到过安全问题吗？怎么解决？ React中如何监听state的变化？ React什么是有状态组件？ React v15中怎么处理错误边界？ React Fiber它的目的是解决什么问题？ React为什么不要直接修改state？如果想修改怎么做？ create-react-app有什么好处？ 装饰器(Decorator)在React中有什么应用？ 使用高阶组件(HOC)实现一个loading组件 如何用React实现滚动动画？ 说出几点你认为的React最佳实践 你是如何划分React组件的？ 举例说明如何在React创建一个事件 如何更新组件的状态？ 怎样将多个组件嵌入到一个组件中？ React的render中可以写{if else}这样的判断吗？ React为什么要搞一个Hooks？ React Hooks帮我们解决了哪些问题？ 使用React的memo和forwardRef包装的组件为什么提示children类型不对？ 有在项目中使用过Antd吗？说说它的好处 在React中如果去除生产环境上的sourcemap？ 在React中怎么引用sass或less？ 组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？ 为什么标签里的for要写成htmlFor呢？ 状态管理器解决了什么问题？什么时候用状态管理器？ 状态管理器它精髓是什么？ 函数式组件有没有生命周期？为什么？ 在React中怎么引用第三方插件？比如说jQuery等 React的触摸事件有哪几种？ 路由切换时同一组件无法重新渲染的有什么方法可以解决？ React16新特性有哪些？ 你有用过哪些React的UI库？它们的优缺点分别是什么？ 单击和单击有什么区别？ 在React中如何引入图片？哪种方式更好？ 在React中怎么使用字体图标？ React的应用如何打包发布？它的步骤是什么？ ES6的语法’…’在React中有哪些应用？ 如何封装一个React的全局公共组件？ 在React中组件的props改变时更新组件的有哪些方法？ immutable的原理是什么？ 你对immutable有了解吗？它有什么作用？ 如何提高组件的渲染效率呢？ 在React中如何避免不必要的render？ render在什么时候会被触发？ 写出React动态改变class切换组件样式 React中怎么操作虚拟DOM的Class属性？ 为什么属性使用className而不是class呢？ 请说下react组件更新的机制是什么？ 怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？ 怎么在JSX里使用自定义属性？ 怎么防止HTML被转义？ 经常用React，你知道React的核心思想是什么吗？ 在React中我们怎么做静态类型检测？都有哪些方法可以做到？ 在React中组件的state和setState有什么区别？ React怎样跳过重新渲染？ React怎么判断什么时候重新渲染组件呢？ 什么是React的实例？函数式组件有没有实例？ 在React中如何判断点击元素属于哪一个组件？ 在React中组件和元素有什么区别？ 在React中声明组件时组件名的第一个字母必须是大写吗？为什么？ 举例说明什么是高阶组件(HOC)的反向继承？ 有用过React Devtools吗？说说它的优缺点分别是什么？ 举例说明什么是高阶组件(HOC)的属性代理？ React的isMounted有什么作用？ React组件命名推荐的方式是哪个？为什么不推荐使用displayName？ React的displayName有什么作用？ 说说你对React的组件命名规范的理解 说说你对React的项目结构的理解 React16废弃了哪些生命周期？为什么？ 怎样在React中开启生产模式？ React中getInitialState方法的作用是什么？ React中你知道creatClass的原理吗？ React中验证props的目的是什么？ React中你有使用过getDefaultProps吗？它有什么作用？ React中你有使用过propType吗？它有什么作用？ React中怎么检验props？ React.createClass和extends Component的区别有哪些？ 高阶组件(HOC)有哪些优点和缺点？ 给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？ React16跟之前的版本生命周期有哪些变化？ 怎样实现React组件的记忆？原理是什么？ 创建React动画有哪些方式？ 为什么建议不要过渡使用Refs？ 在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？ 在使用React过程中什么时候用高阶组件(HOC)？ 说说React diff的原理是什么？ React怎么提高列表渲染的性能？ 使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？ 为何说虚拟DOM会提高性能？ React的性能优化在哪个生命周期？它优化的原理是什么？ 你知道的React性能优化有哪些方法？ 举例说明在React中怎么使用样式？ React有哪几种方法来处理表单输入？ 什么是浅层渲染？ 你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？ 在React中什么是合成事件？有什么用？ 使用React写一个todo应用，说说你的思路 React16的reconciliation和commit分别是什么？ React的函数式组件有没有生命周期？ useState和this.state的区别是什么？ 请说说什么是useImperativeHandle？ 请说说什么是useReducer？ 请说说什么是useRef？ 请说说什么是useEffect？ 举例说明useState 请说说什么是useState？为什么要使用useState？ 请描述下你对React的新特性Hooks的理解？它有哪些应用场景？ 说说你对Error Boundaries的理解 说说你对Fiber架构的理解 说说你是怎么理解React的业务组件和技术组件的？ 为什么建议setState的第一个参数是callback而不是一个对象呢？ 展示组件和容器组件有什么区别？ Mern和Yeoman脚手架有什么区别？ 你有在项目中使用过Yeoman脚手架吗？ 你有在项目中使用过Mern脚手架吗？ shouldComponentUpdate方法是做什么的？ 怎样在React中使用innerHTML？ 你有写过React的中间件插件吗？ React的中间件机制是怎么样的？这种机制有什么作用？ React中你用过哪些第三方的中间件？ 不用脚手架，你会手动搭建React项目吗？ 请说说React中Portal是什么？ React中修改prop引发的生命周期有哪几个？ React多个setState调用的原理是什么？ React中调用setState会更新的生命周期有哪几个？ React中setState的第二个参数作用是什么呢？ React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？ React中的setState批量更新的过程是什么？ React中的setState执行机制是什么呢？ 在React中遍历的方法有哪些？它们有什么区别呢？ 请说说你对React的render方法的理解 props.children.map和js的map有什么区别？为什么优先选择React的？ 有用过React的严格模式吗？ React中的setState和replaceState的区别是什么？ React中的setState缺点是什么呢？ 有用过React的Fragment吗？它的运用场景是什么？ React组件间共享数据方法有哪些？ React的状态提升是什么？使用场景有哪些？ 简单描述下你有做过哪些React项目？ 在构造函数中调用super(props)的目的是什么？ 你是如何学习React的？ 从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？ 你用过React版本有哪些？ 有用过React的服务端渲染吗？怎么做的？ React的mixins有什么作用？适用于什么场景？ React怎么拿到组件对应的DOM元素？ 请描述下事件在React中的处理方式是什么？ JSX和HTML有什么区别？ React的书写规范有哪些？ create-react-app创建新运用怎么解决卡的问题？ 使用React的方式有哪几种？ 说说你对reader的context的理解 同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？ 你知道Virtual DOM的工作原理吗？ 你阅读过React的源码吗？简要说下它的执行流程 React中怎样阻止组件渲染？ React非兄弟组件如何通信？ React兄弟组件如何通信？ React非父子组件如何通信？ React父子组件如何通信？ React组件间的通信有哪些？ 类组件和函数式组件有什么区别？ React自定义组件你写过吗？说说看都写过哪些？ React组件的state和props两者有什么区别？ React有几种构建组件的方式？可以写出来吗？ React中遍历时为什么不用索引作为唯一的key值？ React中的key有什么作用？ React中除了在构造函数中绑定this,还有别的方式吗？ 在React中页面重新加载时怎样保留数据？ 请描述下React的事件机制 怎样在React中创建一个事件？ 在React中无状态组件有什么运用场景？ 描述下在React中无状态组件和有状态组件的区别是什么？ 写一个React的高阶组件(HOC)并说明你对它的理解 React中可以在render访问refs吗？为什么？ React中refs的作用是什么？有哪些应用场景？ 请描述你对纯函数的理解？ 受控组件和非受控组件有什么区别？ React中什么是非控组件？ React中什么是受控组件？ React中发起网络请求应该在哪个生命周期中进行？为什么？ 说说React的生命周期有哪些？ 说说你对“在React中，一切都是组件”的理解 写React你是用es6还是es5的语法？有什么区别？ 浏览器为什么无法直接JSX？怎么解决呢？ 在使用React过程中你都踩过哪些坑？你是怎么填坑的？ 说说你喜欢React的原因是什么？它有什么优缺点？ 如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？ createElement与cloneElement两者有什么区别？ 解释下React中Element 和Component两者的区别是什么？ 解释下React中component和pureComponent两者的区别是什么？ React的虚拟DOM和vue的虚拟DOM有什么区别？ 你觉得React上手快不快？它有哪些限制？ 说说你对声明式编程的理解？ React与angular、vue有什么区别？ React是哪个公司开发的？ React是什么？它的主要特点是什么？ 简要描述下你知道的React工作原理是什么？ 在React中怎样改变组件状态，以及状态改变的过程是什么？ 在React中你是怎么进行状态管理的？ React声明组件有哪几种方法，各有什么不同？ ReactNative 如何在React Native中设置环境变量？ 请描述下Code Push的原理是什么？ React Native怎样查看日记？ React Native怎样测试？ React Native怎样调试？ React Native和React有什么区别？ 有做过React Native项目吗？ React-Router React-Router怎么获取历史对象？ React-Router怎么获取URL的参数？ 在history模式中push和replace有什么区别？ React-Router怎么设置重定向？ React-Router 4中组件有几种类型？ React-Router 3和React-Router 4有什么变化？添加了什么好的特性？ React-Router的实现原理是什么？ React-Router 4的switch有什么用？ React-Router的路由有几种模式？ React-Router 4怎样在路由变化时重新渲染同一个组件？ React-Router的标签和标签有什么区别？ React的路由和普通路由有什么区别？ 请你说说React的路由的优缺点？ 请你说说React的路由是什么？ Redux/Mobox 你有了解Rxjs是什么吗？它是做什么的？ 在Redux中怎么发起网络请求？ Redux怎样重置状态？ Redux怎样设置初始状态？ Context api可以取代Redux吗？为什么？ 推荐在reducer中触发Action吗？为什么？ Redux怎么添加新的中间件？ redux-saga和redux-thunk有什么本质的区别？ 在React中你是怎么对异步方案进行选型的？ 你知道redux-saga的原理吗？ 你有使用过redux-saga中间件吗？它是干什么的？ Redux中异步action和同步action最大的区别是什么？ Redux和vuex有什么区别？ Redux的中间件是什么？你有用过哪些Redux的中间件？ 说说Redux的实现流程 Mobx的设计思想是什么？ Redux由哪些组件构成？ Mobx和Redux有什么区别？ 在React项目中你是如何选择Redux和Mobx的？说说你的理解 你有在React中使用过Mobx吗？它的运用场景有哪些？ Redux的thunk作用是什么？ Redux的数据存储和本地储存有什么区别？ 在Redux中，什么是reducer？它有什么作用？ 举例说明怎么在Redux中定义action？ 在Redux中，什么是action？ 在Redux中，什么是store？ 为什么Redux能做到局部渲染呢？ 说说Redux的优缺点分别是什么？ Redux和Flux的区别是什么？ Redux它的三个原则是什么？ 什么是单一数据源？ 什么是Redux？说说你对Redux的理解？有哪些运用场景？ Flux 请说说点击按钮触发到状态更改，数据的流向？ 请描述下Flux的思想 什么是Flux？说说你对Flux的理解？有哪些运用场景？ 面试题https://www.cnblogs.com/dcyd/p/12989422.html https://zhuanlan.zhihu.com/p/76909668 https://zhuanlan.zhihu.com/p/24856035 https://www.jianshu.com/p/84ce8d9f5391 https://www.cnblogs.com/zhuxinpeng-looking/p/11283015.html 更多题目https://github.com/haizlin/fe-interview","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yangyfeng.github.io/blogpost/tags/React/"},{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"Vue知识点集合","slug":"前端每日一题/Vue知识点集合","date":"2021-03-06T16:00:00.000Z","updated":"2021-03-07T05:09:36.892Z","comments":true,"path":"/posts/5b9a2dd2.html","link":"","permalink":"https://yangyfeng.github.io/posts/5b9a2dd2.html","excerpt":"","text":"vue 在vue中watch和created哪个先执行？为什么？ vue中mixins和extends有什么区别？ vue中mixins有什么使用场景？ 在vue中created与activated有什么区别？ 在vue项目如何引入异步组件？ 在vue项目中scss scoped穿透符&gt;&gt;&gt;无效的解决方案有哪些？ 为什么在v-for中的key不推荐使用随机数或者index呢？那要怎么使用才比较好呢？ vue-loader在webpack编译流程中的哪个阶段？ 预渲染和SSR(服务端渲染)有什么区别？ 你有用过预渲染技术吗？怎么做的？ 使用vue如何判断页面是否编辑及编辑页面未保存离开时，给出弹窗提示 vue的.sync修饰符可以用表达式吗？为什么？ v-if和v-show哪个优先级更高？ 如何批量引入组件？ vue的v-for如何倒序输出？ 如何在全局使用axios的实例呢？ v-show指令算是重排吗？ axios同时请求多个接口，如果当token过期时，怎么取消后面的请求？ 从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织 你知道vue的模板语法用的是哪个web模板引擎的吗？说说你对这模板引擎的理解 你知道v-model的原理吗？说说看 你有使用过vue开发多语言项目吗？说说你的做法？ 在使用计算属性的时，函数名和data数据源中的数据可以同名吗？ vue中data的属性可以和methods中的方法同名吗？为什么？ 怎么给vue定义全局的方法？ vue2.0不再支持v-html中使用过滤器了怎么办？ 怎么解决vue打包后静态资源图片失效的问题？ 怎么解决vue动态设置img的src不生效的问题？ 使用vue后怎么针对搜索引擎做SEO优化？ 跟keep-alive有关的生命周期是哪些？描述下这些生命周期 如果现在让你从vue/react/angularjs三个中选择一个，你会选哪个？说说你的理由 你知道vue2.0兼容IE哪个版本以上吗？ 使用vue开发一个todo小应用，谈下你的思路 你有看过vue推荐的风格指南吗？列举出你知道的几条 你是从vue哪个版本开始用的？你知道1.x和2.x有什么区别吗？ 你知道vue中key的原理吗？说说你对它的理解 vue中怎么重置data？ vue渲染模板时怎么保留模板中的HTML注释呢？ Vue.observable你有了解过吗？说说看 你知道style加scoped属性的用途和原理吗？ 你期待vue3.0有什么功能或者改进的地方？ vue边界情况有哪些？ 如何在子组件中访问父组件的实例？ watch的属性用箭头函数定义结果会怎么样？ 在vue项目中如果methods的方法用箭头函数定义结果会怎么样？ 在vue项目中如何配置favicon？ 你有使用过babel-polyfill模块吗？主要是用来做什么的？ 说说你对vue的错误处理的了解？ 在vue事件中传入$event，使用e.target和e.currentTarget有什么区别？ 在.vue文件中style是必须的吗？那script是必须的吗？为什么？ vue怎么实现强制刷新组件？ vue自定义事件中父组件怎么接收子组件的多个参数？ 实际工作中，你总结的vue最佳实践有哪些？ vue给组件绑定自定义事件无效怎么解决？ vue的属性名称与method的方法名称一样时会发生什么问题？ vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？ vue使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？ vue如果想扩展某个现有的组件时，怎么做呢？ 说下$attrs和$listeners的使用场景 分析下vue项目本地开发完成后部署到服务器后报404是什么原因呢？ v-once的使用场景有哪些？ 说说你对vue的表单修饰符.lazy的理解 vue为什么要求组件模板只能有一个根元素？ EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？ 怎么修改vue打包后生成文件路径？ 你有使用做过vue与原生app交互吗？说说vue与ap交互的方法 使用vue写一个tab切换 vue中什么是递归组件？举个例子说明下？ 怎么访问到子组件的实例或者子元素？ 在子组件中怎么访问到父组件的实例？ 在组件中怎么访问到根实例？ 说说你对Object.defineProperty的理解 vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？ vue组件里的定时器要怎么销毁？ vue组件会在什么时候下被销毁？ 使用vue渲染大量数据时应该怎么优化？说下你的思路！ 在vue中使用this应该注意哪些问题？ 你有使用过JSX吗？说说你对JSX的理解 说说组件的命名规范 怎么配置使vue2.0+支持TypeScript写法？ 有什么用？ vue的is这个特性你有用过吗？主要用在哪些方面？ vue的:class和:style有几种表示方式？ 你了解什么是函数式组件吗？ vue怎么改变插入模板的分隔符？ 组件中写name选项有什么作用？ 说说你对provide和inject的理解 开发过程中有使用过devtools吗？ 说说你对slot的理解有多少？slot使用场景有哪些？ 你有使用过动态组件吗？说说你对它的理解 prop验证的type类型有哪几种？ prop是怎么做验证的？可以设置默认值吗？ 怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢？ 说说你对vue组件的设计原则的理解 你了解vue的diff算法吗？ vue如何优化首页的加载速度？ vue打包成最终的文件有哪些？ ajax、fetch、axios这三都有什么区别？ vue能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？ vue中是如何使用event对象的？ vue首页白屏是什么问题引起的？如何解决呢？ 说说你对单向数据流和双向数据流的理解 移动端ui你用的是哪个ui库？有遇到过什么问题吗？ 你知道nextTick的原理吗？ 说说你对v-clock和v-pre指令的理解 写出你知道的表单修饰符和事件修饰符 说说你对proxy的理解 你有自己用vue写过UI组件库吗？ 用vue怎么实现一个换肤的功能？ 有在vue中使用过echarts吗？踩过哪些坑？如何解决的？ 如果让你教一个2-3年经验前端经验的同事使用vue，你该怎么教？ vue性能的优化的方法有哪些？ SSR解决了什么问题？有做过SSR吗？你是怎么做的？ 说说你觉得认为的vue开发规范有哪些？ vue部署上线前需要做哪些准备工作？ vue过渡动画实现的方式有哪些？ vue在created和mounted这两个生命周期中请求数据有什么区别呢？ vue父子组件双向绑定的方法有哪些？ vue怎么获取DOM节点？ vue项目有做过单元测试吗？ vue项目有使用过npm run build –report吗？ 如何解决vue打包vendor过大的问题？ webpack打包vue速度太慢怎么办？ vue在开发过程中要同时跟N个不同的后端人员联调接口（请求的url不一样）时你该怎么办？ vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？ 说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？ 在移动端使用vue，你觉得最佳实践有哪些？ 你们项目为什么会选vue而不选择其它的框架呢？ 对于即将到来的vue3.0特性你有什么了解的吗？ vue开发过程中你有使用什么辅助工具吗？ vue和微信小程序写法上有什么区别？ 怎么缓存当前的组件？缓存后怎么更新？ 你了解什么是高阶组件吗？可否举个例子说明下？ 为什么我们写组件的时候可以写在.vue里呢？可以是别的文件名后缀吗？ vue-loader是什么？它有什么作用？ 说说你对vue的extend（构造器）的理解，它主要是用来做什么的？ 如果将axios异步请求同步化处理？ 怎么捕获组件vue的错误信息？ 为什么vue使用异步更新组件？ 如何实现一个虚拟DOM？说说你的思路 写出多种定义组件模板的方法 SPA单页面的实现方式有哪些？ 说说你对SPA单页面的理解，它的优缺点分别是什么？ 说说你都用vue做过哪些类型的项目？ 在vue项目中如何引入第三方库（比如jQuery）？有哪些方法可以做到？ 使用vue手写一个过滤器 你有使用过render函数吗？有什么好处？ 写出你常用的指令有哪些？ 手写一个自定义指令及写出如何调用 组件进来请求接口时你是放在哪个生命周期？为什么？ 你有用过事件总线(EventBus)吗？说说你的理解 说说vue的优缺点分别是什么？ DOM渲染在哪个周期中就已经完成了？ 第一次加载页面时会触发哪几个钩子？ vue生命周期总共有几个阶段？ vue生命周期的作用是什么？ vue和angular有什么区别呢？ 如何引入scss？引入后如何使用？ 使用vue开发过程你是怎么做接口管理的？ 为何官方推荐使用axios而不用vue-resource？ 你了解axios的原理吗？有看过它的源码吗？ 你有封装过axios吗？主要是封装哪方面的？ 如何中断axios的请求？ axios是什么？怎样使用它？怎么解决跨域的问题？ 说说你对vue的template编译的理解？ v-on可以绑定多个方法吗？ vue常用的修饰符有哪些？列举并说明 你认为vue的核心是什么？ v-model是什么？有什么用呢？ 说说你对vue的mixin的理解，有什么应用场景？ SPA首屏加载速度慢的怎么解决？ 删除数组用delete和Vue.delete有什么区别？ 动态给vue的data添加一个新的属性时会发生什么？怎样解决？ 组件和插件有什么区别？ 说说你使用vue过程中遇到的问题（坑）有哪些，你是怎么解决的？ 说说你对选项el,template,render的理解 vue实例挂载的过程是什么？ vue在组件中引入插件的方法有哪些？ v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？ 分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？ $nextTick有什么作用？ 为什么data属性必须声明为返回一个初始数据对应的函数呢？ 怎么在watch监听开始之后立即被调用？ watch怎么深度监听对象变化？ watch和计算属性有什么区别？ vue如何监听键盘事件？ v-for循环中key有什么作用？ 怎么在vue中使用插件？ 你有写过自定义组件吗？ 说说你对keep-alive的理解是什么？ 怎么使css样式只在当前组件中生效？ 你有看过vue的源码吗？如果有那就说说看 你有写过自定义指令吗？自定义指令的生命周期（钩子函数）有哪些？ v-show和v-if有什么区别？使用场景分别是什么？ 说说你对MVC、MVP、MVVM模式的理解 说下你对指令的理解？ 请描述下vue的生命周期是什么？ vue组件之间的通信都有哪些？ 什么是虚拟DOM？ 什么是双向绑定？原理是什么？ vue和react有什么不同？使用场景是什么？ 说说vue的优缺点 有使用过vue吗？说说你对vue的理解 vue-cli vue-cli提供了的哪几种脚手架模板？ vue-cli工程中常用的npm命令有哪些？ 在使用vue-cli开发vue项目时，自动刷新页面的原理你了解吗？ vue-cli3插件有写过吗？怎么写一个代码生成插件？ vue-cli生成的项目可以使用es6、es7的语法吗？为什么？ vue-cli怎么解决跨域的问题？ vue-cli中你经常的加载器有哪些？ 你知道什么是脚手架吗？ 说下你了解的vue-cli原理？你可以自己实现个类vue-cli吗？ 怎么使用vue-cli3创建一个项目？ vue-cli3你有使用过吗？它和2.x版本有什么区别？ vue-cli默认是单页面的，那要弄成多页面该怎么办呢？ 不用vue-cli，你自己有搭建过vue的开发环境吗？流程是什么？ vue-router vue-router怎么重定向页面？ vue-router怎么配置404页面？ 切换路由时，需要保存草稿的功能，怎么实现呢？ vue-router路由有几种模式？说说它们的区别？ vue-router有哪几种导航钩子（ 导航守卫 ）？ 说说你对router-link的了解 vue-router如何响应路由参数的变化？ 你有看过vue-router的源码吗？说说看 切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？ 在什么场景下会用到嵌套路由？ 如何获取路由传过来的参数？ 说说active-class是哪个组件的属性？ 在vue组件中怎么获取到当前的路由信息？ vur-router怎么重定向？ 怎样动态加载路由？ 怎么实现路由懒加载呢？ 如果让你从零开始写一个vue路由，说说你的思路 说说vue-router完整的导航解析流程是什么？ 路由之间是怎么跳转的？有哪些方式？ 如果vue-router使用history模式，部署时要注意什么？ route和router有什么区别？ vue-router钩子函数有哪些？都有哪些参数？ vue-router是用来做什么的？它有哪些组件？ vuex 你有写过vuex中store的插件吗？ 你有使用过vuex的module吗？主要是在什么场景下使用？ vuex中actions和mutations有什么区别？ vuex使用actions时不支持多参数传递怎么办？ 你觉得vuex有什么缺点？ 你觉得要是不用vuex的话会带来哪些问题？ vuex怎么知道state是通过mutation修改还是外部直接修改的？ 请求数据是写在组件的methods中还是在vuex的action中？ 怎么监听vuex数据的变化？ vuex的action和mutation的特性是什么？有什么区别？ 页面刷新后vuex的state数据丢失怎么解决？ vuex的state、getter、mutation、action、module特性分别是什么？ vuex的store有几个属性值？分别讲讲它们的作用是什么？ 你理解的vuex是什么呢？哪些场景会用到？不用会有问题吗？有哪些特性？ 使用vuex的优势是什么？ 有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？ ElementUI 使用Element UI表格如何设置列宽的宽度自适应？ Element UI的表格，点击编辑跳转到编辑页面，编辑完成返回到列表页面，还返回到原分页列表 使用elementUI的表格组件时，在有多页的情况下，多选框如何跨页选择？ ElementUI是怎么做表单验证的？在循环里对每个input验证怎么做呢？ 你有二次封装过ElementUI组件吗？ ElementUI怎么修改组件的默认样式？ ElementUI的穿梭组件如果数据量大会变卡怎么解决不卡的问题呢？ ElementUI表格组件如何实现动态表头？ ElementUI使用表格组件时有遇到过问题吗？ 有阅读过ElementUI的源码吗？ 项目中有使用过ElementUI吗？有遇到过哪些问题？它的使用场景主要是哪些？ 有用过哪些vue的ui？说说它们的优缺点？ mint-ui mint-ui使用过程中有没有遇到什么坑？怎么解决的？ 说出几个mint-ui常用的组件 mint-ui是什么？你有使用过吗？","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"可视化定制开发","slug":"我的项目展示/可视化定制开发","date":"2021-03-04T16:00:00.000Z","updated":"2021-03-06T15:36:24.248Z","comments":true,"path":"/posts/aab0fbb9.html","link":"","permalink":"https://yangyfeng.github.io/posts/aab0fbb9.html","excerpt":"","text":"定制开发 用户业务需求为基础，设计出客户满意的方案，前端根据设计图1:1完成开发。 包括各类图表展示元素，地理位置信息展示单元（Gis、矢量、3d地球等），交互效果（酷炫动画，用户交互，展示效果等），实数数据监控，告警反馈，控制等。 交互给客户就是一套完整的可运行的程序，数据接口我们可以开发或者直接对接客户提供的数据接口。 慧盾网络监控设备网络监控，数据安全。 视频安全指挥中心 全局安全监测 东胜电厂 中国石化安徽石油可视化智慧调度平台","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://yangyfeng.github.io/blogpost/tags/数据可视化/"}]},{"title":"应急管理中心 刑侦案件地理信息可视化展示系统","slug":"我的项目展示/应急管理中心展示平台","date":"2021-03-04T16:00:00.000Z","updated":"2021-03-07T04:37:43.573Z","comments":true,"path":"/posts/f2d2e0b4.html","link":"","permalink":"https://yangyfeng.github.io/posts/f2d2e0b4.html","excerpt":"","text":"介绍刑侦案件地理信息可视化展示系。为国家互联网应急协调中心业务专家提供前端业务数据和业务流程的实时性展示，以满足数据建模和业务建模之后的业务分析，实现有效的态势感知、实时预警告警，追溯分析后展示等能力。综合了各类特点，将复杂而凌乱的数据更加直观的展示在屏幕上，做到“精准打击”，“一目了然”。 数据价值展示 以数据为中心，过滤和分析将数据的价值真实的展示出来 视觉美观度 保障页面美观程度与展示效果符合大众化审美与流行元素 业务核心价值 数据指标满足核心业务，真正的为业务设计，业务服务 展示层次化 呈现信息要有整体的层次，符合可视化视域，把最直观的内容第一时间展现给使用者 业务业务包含如下： 地理信息分布分析：对主要业务在国家、省、城市的相关态势分布情况。 设备安全隐患：设备安全隐患的分析，是路由器设备发现和漏洞挖掘验证的业务呈现。 安全性影响范围：包括地理范围，案件范围，人员范围、设备分布等多种业务的汇总呈现。 案件信息：包括案件类型分析和进展分析。 案件预警：对预警情况进行分析。 人员分析：分析嫌疑人，受害人情况。 涉案金额分析：案件类型划分涉案金额等内容。 时间维度分析：按不同的时间点分析不同的数据，如“近六个月案发量环比增长”，年度，季度，月份，选定时间段等内容。 关联分析：包括关系图谱在内的各种，多维度分析内容。 功能详解GIS地图展示案件关系 案件数据统计与分析","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"}]},{"title":"QTV2直播商城","slug":"我的项目展示/QTV2直播商城","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-07T04:37:45.430Z","comments":true,"path":"/posts/b1fde4c6.html","link":"","permalink":"https://yangyfeng.github.io/posts/b1fde4c6.html","excerpt":"项目描述QTV-2直播生活供货商入驻系统，运行在微信公众号， 集资讯短视频，电商直播，购物商城为一体的青岛广电生活服务平台 。 其功能主要有直播打赏，直播抽奖，会员制，商品分享，弹幕评论等。微信搜索“QTV蛤蜊帮”，即可进入。 系统结构说明核心模型 业务架构 业务介绍产品分类 推荐、大牌MALL（商超大牌）、扶农助农、工厂清仓、母婴亲子、美食美味、珠光宝气、潮搭攻略、乐家生活、美妆心得等","text":"项目描述QTV-2直播生活供货商入驻系统，运行在微信公众号， 集资讯短视频，电商直播，购物商城为一体的青岛广电生活服务平台 。 其功能主要有直播打赏，直播抽奖，会员制，商品分享，弹幕评论等。微信搜索“QTV蛤蜊帮”，即可进入。 系统结构说明核心模型 业务架构 业务介绍产品分类 推荐、大牌MALL（商超大牌）、扶农助农、工厂清仓、母婴亲子、美食美味、珠光宝气、潮搭攻略、乐家生活、美妆心得等 视频广场 可以在这里看直播卖货，也能看录播的商品介绍视频。 会员管理 微信获取用户信息（微信头像 通讯录 地理位置 会员名 电话 当前登录地 常活动地 收货地址 普通用户 分销用户 等级 性别 购买喜好）。 会员等级有用户购买的商品累计金额来核算。 商品管理 用户可以在后台添加自己的商品（商品封面 标题 价格 商家 ），在前台购买用户还可以看到，今日销量 昨日销量 总销量 总销售额 上架时间。 当然商户也可以在后台下架商品，设置满减和折扣优惠，限购数量，下架商品，购买方式包括自提（线下实体流量导入）送货到家等。 直播录播管理 录播：在后台商户可以手动上传商品，并关联商品中的商品，再审核或禁播。权重规则， 按照销量+上新+评价确定展示的优先顺序。 直播：商户可以预约一次直播，甚至可以在直播中开启抽奖活动。 商户管理 在后台需要审核商户。 入住审核： 供货商（工厂）/门店（实体）入住审核（基本公司信息+行业特殊证件） 渠道商入住审核（基本公司信息+会员数量截图） 特殊权限： 开启购买跳转到他们的自建购物网站。 商户营销 商户可以开启一些营销活动来吸收流量。 例如，投票（特殊要求-萌宝视频pk投票—转化用户数与活跃度） 拼团 限时购等。","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"}]},{"title":"华北电力控制系统","slug":"我的项目展示/华北电力控制系统","date":"2021-02-22T16:00:00.000Z","updated":"2021-03-07T04:37:41.661Z","comments":true,"path":"/posts/763ea06e.html","link":"","permalink":"https://yangyfeng.github.io/posts/763ea06e.html","excerpt":"项目概况数据可视化展示与开发中心，通过开发可视化设计器、可视化展示引擎、可视化控制平台、可视化后台服务及音视屏驱动软件，用于全方面、多角度展示智能发电运行控制系统整体架构与主要功能，开展发电设备三维可视化、发电过程音视频数据分析、状态识别与故障定位算法研究，最终形成“多业务，多窗口，多交互手段，少人工”的数据驾驶舱系统。 系统架构 总体应用框架分为六层框架结构，提供两类支撑，分别是“网络层”、“数据层”、“应用层”、“业务层”、“交互层”、“表现层”，支撑为“标准规范”与“硬件体系”。 系统业务业务主要包括，工业指标的数据可视化展示（数据监测），设备的精准控制（手动，阀值报警或制动，语音智能控制），对数据的多类方式分析并给出高价值结果，各类测试数据下指标对比（灵活筛选对比的指标），以及用户权限控制，报表分析与下载，3d场景下的工业数据的可视化展示等。","text":"项目概况数据可视化展示与开发中心，通过开发可视化设计器、可视化展示引擎、可视化控制平台、可视化后台服务及音视屏驱动软件，用于全方面、多角度展示智能发电运行控制系统整体架构与主要功能，开展发电设备三维可视化、发电过程音视频数据分析、状态识别与故障定位算法研究，最终形成“多业务，多窗口，多交互手段，少人工”的数据驾驶舱系统。 系统架构 总体应用框架分为六层框架结构，提供两类支撑，分别是“网络层”、“数据层”、“应用层”、“业务层”、“交互层”、“表现层”，支撑为“标准规范”与“硬件体系”。 系统业务业务主要包括，工业指标的数据可视化展示（数据监测），设备的精准控制（手动，阀值报警或制动，语音智能控制），对数据的多类方式分析并给出高价值结果，各类测试数据下指标对比（灵活筛选对比的指标），以及用户权限控制，报表分析与下载，3d场景下的工业数据的可视化展示等。 三维流程图 系统监控画面 语音控制（发出指令） 指标对比 客户端集成 BS架构集成为windows客户端，可以制定开机任务等。","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://yangyfeng.github.io/blogpost/tags/数据可视化/"}]},{"title":"国珍知识库管理系统","slug":"我的项目展示/国珍知识库管理系统","date":"2021-02-22T16:00:00.000Z","updated":"2021-03-07T04:37:38.872Z","comments":true,"path":"/posts/d02d7caa.html","link":"","permalink":"https://yangyfeng.github.io/posts/d02d7caa.html","excerpt":"","text":"项目描述客服中心知识管理系统。以知识库为核心，以检索查询为主要手段，通过对客服中心各类知识的管理，最终将它们演变成客服中心可重复利用的组织知识。以提出问题、回答问题、采编知识等流程，实现国珍企业知识库的知识储存，知识管理和知识搜索，并有效的帮助客服服务用户。 主要功能罗列了部分功能。主要含有知识库搜索、采编管理、文章发布与编辑、在线问答、智能提问、评论、收藏、点赞等。 知识搜索 关键字，模糊词，热搜词，近义词等多种词条搜索。 采编功能 用户主动添加文章，添加知识库，由专家审核，敏感词警告，以及历史文章对比等。 在线问答 业务架构 升级版本内容核心内容：对接了客服中心智能机器人系统，供智能机器人调取内容所用，可以提供用户在线智能问答。","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"}]},{"title":"风力发电SCADA","slug":"我的项目展示/风力发电SCADA","date":"2021-02-22T16:00:00.000Z","updated":"2021-03-07T04:37:35.740Z","comments":true,"path":"/posts/fa28e10b.html","link":"","permalink":"https://yangyfeng.github.io/posts/fa28e10b.html","excerpt":"什么是SCADASCADA系统，即数据采集与监视控制系统。SCADA系统是以计算机为基础的DCS与电力自动化监控系统；它应用领域很广，可以应用于电力、冶金、石油、化工、燃气、铁路等领域的数据采集与监视控制以及过程控制等诸多领域。其功能主要围绕生产数据实时采集、生产设备过程监控、生产设备异常报警、数据分析、数据报表及仪表盘展示四个方面进行，其特性主要体现以下几个方面： 1、支持5000多种通讯协议，满足市场上百分之99.99的控制器、仪器仪表的通讯要求。打通自动化硬件系统与信息化软件系统信息传递。2、将办公网络IP与工业设备IP进行硬件隔离，避免IP冲突。3、直观展示生产动态，对现场设备实现直接或间接控制，满足可视化管理的需求。4、进行数据统计分析，并通过仪表盘进行展示。 项目描述风力发电厂的安全监测平台。将SCADA和IT运维监控内容融与数据可视化相融合形成安全监测平台。分别有数据可视化、SACDA、IT运维监控和基本功能4个主要功能模块。 数据可视化：主要提供前端展示内容，包括3D、2D建模和图表元素，形成沉浸式的监控展示体系，将业务、告警等相融合。 SCADA：将SCADA的原有功能和信息发布功能相结合，对升压站、风机进行实时数据监控，形成数据采集、分析、监控和预警的统一功能。 IT运维监测：对机房网络和服务进行整体的监控。 基本功能：账号管理、权限管理、部门管理和角色管理等内容。 建设要求遵循了灵活性和可扩展性原则，能够适应业务变化和进步的要求，满足同行业电厂业务要求。平台系统所采用的相关标准必须与国际、国家、省、市级及行业标准相符合，确保系统具有良好的开放性，能实现与多种技术和软硬件平台的有机集成。 对于用户而言，解决了在业务中一些棘手问题，如下： 1. 运营管理场景：对变电站和风机进行全面的监控，提供直观高效的数据展现形式。 2. 预警告警：对预警和告警信息作出实时数据监控并发送相应的告警信息。 3. 运维支撑：对业务运维和IT运维人员提供及时的信息提醒和展示，便于运维人员及时有效的进行电厂的整体维护。 4. 培训人员：减少员工培训成本，快速理解电厂业务和相关工作岗位，增加员工的业务熟练程度和应急处理能力。","text":"什么是SCADASCADA系统，即数据采集与监视控制系统。SCADA系统是以计算机为基础的DCS与电力自动化监控系统；它应用领域很广，可以应用于电力、冶金、石油、化工、燃气、铁路等领域的数据采集与监视控制以及过程控制等诸多领域。其功能主要围绕生产数据实时采集、生产设备过程监控、生产设备异常报警、数据分析、数据报表及仪表盘展示四个方面进行，其特性主要体现以下几个方面： 1、支持5000多种通讯协议，满足市场上百分之99.99的控制器、仪器仪表的通讯要求。打通自动化硬件系统与信息化软件系统信息传递。2、将办公网络IP与工业设备IP进行硬件隔离，避免IP冲突。3、直观展示生产动态，对现场设备实现直接或间接控制，满足可视化管理的需求。4、进行数据统计分析，并通过仪表盘进行展示。 项目描述风力发电厂的安全监测平台。将SCADA和IT运维监控内容融与数据可视化相融合形成安全监测平台。分别有数据可视化、SACDA、IT运维监控和基本功能4个主要功能模块。 数据可视化：主要提供前端展示内容，包括3D、2D建模和图表元素，形成沉浸式的监控展示体系，将业务、告警等相融合。 SCADA：将SCADA的原有功能和信息发布功能相结合，对升压站、风机进行实时数据监控，形成数据采集、分析、监控和预警的统一功能。 IT运维监测：对机房网络和服务进行整体的监控。 基本功能：账号管理、权限管理、部门管理和角色管理等内容。 建设要求遵循了灵活性和可扩展性原则，能够适应业务变化和进步的要求，满足同行业电厂业务要求。平台系统所采用的相关标准必须与国际、国家、省、市级及行业标准相符合，确保系统具有良好的开放性，能实现与多种技术和软硬件平台的有机集成。 对于用户而言，解决了在业务中一些棘手问题，如下： 1. 运营管理场景：对变电站和风机进行全面的监控，提供直观高效的数据展现形式。 2. 预警告警：对预警和告警信息作出实时数据监控并发送相应的告警信息。 3. 运维支撑：对业务运维和IT运维人员提供及时的信息提醒和展示，便于运维人员及时有效的进行电厂的整体维护。 4. 培训人员：减少员工培训成本，快速理解电厂业务和相关工作岗位，增加员工的业务熟练程度和应急处理能力。 架构分析系统围绕“5个1工程”的核心建设目标，设计总体框架如下图所示，采用五层框架结构“感知层”、“网络层”、“数据层”、“平台层”，“应用层”。 感知层：主要是进行数据采集清洗转换等功能。 网络层：采用电厂原有网络结构，进行传输。 数据层：提供标准化的业务数据库。 平台层：平台功能的业务服务程序。 应用层：共有PC，手机和大屏端三个应用前端场景。 我们将安全平台进行了逻辑分层，具体的分层架构图如下图所示： 整体说明如下： 1.基础设备：数据底层设备和系统层将各系统之前完成对接，包括在SDK、硬件、软件、API、数据库等多种对接方式； 2.数据对接层：将数据采集后，进行结构化和半结构化的数据治理。直接操作数据库，针对数据的增添、删除、修改、查找等。 3.业务逻辑层针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。（关键在于由原始数据抽象出逻辑数据）能够提供interface\\API层次上所有的功能。“中间业务层”的实际目的是将“数据访问层”的最基础的存储逻辑组合起来，形成一种业务规则。 4.将非实时数据及实时数据进行数据清洗通过不同的匹配规则在页面端进行展示。 5.按照业务对接需求中的展示效果实现，使用大数据可视化平台进行展示。 功能详解业务功能太多，只展示部分！！！ 业务安全监测 设置系统预警阈值，预警信息展示，自由控制设备状态。 运维监测 多维度业务管理展示，图表展示相关运维指标数据，拓扑结构展示（网络拓扑，设备拓扑，服务拓扑，业务拓扑）。 风场电站电压路线图监控 监控输电线路，排查故障，线路检测等。 业务功能架构 开发说明工业数据采集 ➜ 存储实时数据库（RabbitMQ）➜ 高效Go程序（UA）将工业数据处理为业务数据（JSON），并建立HTTP和WebSocket模块与前端做数据通信 ➜ restful Api与前端交互，做数据渲染和可视化渲染（各类图表库，Echarts，D3等，其中3D可视化采用建模和WebGL渲染）","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://yangyfeng.github.io/blogpost/tags/数据可视化/"}]},{"title":"大数据可视化系统","slug":"我的项目展示/大数据可视化系统","date":"2021-02-02T01:22:00.000Z","updated":"2021-03-07T04:37:30.158Z","comments":true,"path":"/posts/5f998618.html","link":"","permalink":"https://yangyfeng.github.io/posts/5f998618.html","excerpt":"项目描述一套数据可视化展示平台，支持多种数据源类型（CSV静态文件，数据库连接，Http接口，JSON静态数据，WebSocket连接）。拥有多种酷炫图表和动画，同时支持本地化部署，镜像保存，分享，权限控制等。支持自定义图表上传，支持多种可视化插件，如Echarts，D3，AntV等。3D可视化功能目前只支持Unity3D引擎。 系统简介探索您拥有的所有数据，发现新的模式，创造丰富的视觉效果来共享洞察。利用该系统易于使用的分析和商业智能工具，您能够： ① 快速获得信息概览，更快的通过可视化探索所有相关数据，飞速获取洞察。发现未知模式识别关键的联系，发现隐藏的机会。 ② 看到数据，理解数据，通过炫目的可视化方式，快速理解数据所表明的一切。基于分析的交互可视化让每个人都可以理解分析结果。 ③ 停止猜测，更智慧地工作，简化数据准备。软件自动突出显示相关的重要发现，无需编程。 功能详解登录 项目只支持内网部署版本，未发版sass平台。 用户有管理员逐一分配，适合多类企业的需求。 可视化大屏列表 展示方式有两种：卡片模式、列表模式 卡片模式可以获取大屏内部的画面作为预览图或者用户自己设置封面 之外每个大屏都可以锁定（设置密码）、发布、预览、复制、编辑等功能。 左上角的创建按钮，跳转到创建大屏页面，创建时可选择模板、空白的任意比例的大屏，以及加入到多选分类中。 可视化大屏配置 在上方选择需要的图表拖入到中间画布，即可在右侧配置对应属性和数据，并能加入到收藏，供后面使用。 其中在使用数据时，选择创建的数据源，然后做好字段映射即可，非常方便。 离线部署 适配非常规拼接大屏，支持加密发布，支持本地部署，数据无需上传至第三方服务器或云端，私密数据的安全性更有保障。 多种数据源支持 支持接入关系型数据库、本地CSV上传和在线API等，支持动态请求，多服务平台信息可视化呈现。 以及可以使用用户自定义的数据做为数据源在图表上使用。 数据源跨平台兼容 兼容各种数据源类型，支持海量数据。可连接公司各种各样业务管理系统、第三方平台互联网技术统计数据、电子表格等数据文件以及公共数据综合服务平台，轻松整合所有相关业务数据，帮助企业消除数据孤岛。 用户权限控制 RBAC控制，以及数据的用户绑定，用户创建的数据源只能为单用户使用，使数据更加安全和独立。 3D可视化 我们不仅提供全周期模型资源支持，还可以通过设计师灵动设计的场景模型与现实设备进行数据互通与联动，真正实现3D万物可视，还支持3D地图等效果，支持地理数据多层叠加。 支持多种图表效果 支持各类图表，折线，点，柱，地图等都有涉及，支持多种可视化图表库，echarts，highcharts，d3，g2等。 数据下钻和上浮 支持多图表数据联动，以及下钻和上浮","text":"项目描述一套数据可视化展示平台，支持多种数据源类型（CSV静态文件，数据库连接，Http接口，JSON静态数据，WebSocket连接）。拥有多种酷炫图表和动画，同时支持本地化部署，镜像保存，分享，权限控制等。支持自定义图表上传，支持多种可视化插件，如Echarts，D3，AntV等。3D可视化功能目前只支持Unity3D引擎。 系统简介探索您拥有的所有数据，发现新的模式，创造丰富的视觉效果来共享洞察。利用该系统易于使用的分析和商业智能工具，您能够： ① 快速获得信息概览，更快的通过可视化探索所有相关数据，飞速获取洞察。发现未知模式识别关键的联系，发现隐藏的机会。 ② 看到数据，理解数据，通过炫目的可视化方式，快速理解数据所表明的一切。基于分析的交互可视化让每个人都可以理解分析结果。 ③ 停止猜测，更智慧地工作，简化数据准备。软件自动突出显示相关的重要发现，无需编程。 功能详解登录 项目只支持内网部署版本，未发版sass平台。 用户有管理员逐一分配，适合多类企业的需求。 可视化大屏列表 展示方式有两种：卡片模式、列表模式 卡片模式可以获取大屏内部的画面作为预览图或者用户自己设置封面 之外每个大屏都可以锁定（设置密码）、发布、预览、复制、编辑等功能。 左上角的创建按钮，跳转到创建大屏页面，创建时可选择模板、空白的任意比例的大屏，以及加入到多选分类中。 可视化大屏配置 在上方选择需要的图表拖入到中间画布，即可在右侧配置对应属性和数据，并能加入到收藏，供后面使用。 其中在使用数据时，选择创建的数据源，然后做好字段映射即可，非常方便。 离线部署 适配非常规拼接大屏，支持加密发布，支持本地部署，数据无需上传至第三方服务器或云端，私密数据的安全性更有保障。 多种数据源支持 支持接入关系型数据库、本地CSV上传和在线API等，支持动态请求，多服务平台信息可视化呈现。 以及可以使用用户自定义的数据做为数据源在图表上使用。 数据源跨平台兼容 兼容各种数据源类型，支持海量数据。可连接公司各种各样业务管理系统、第三方平台互联网技术统计数据、电子表格等数据文件以及公共数据综合服务平台，轻松整合所有相关业务数据，帮助企业消除数据孤岛。 用户权限控制 RBAC控制，以及数据的用户绑定，用户创建的数据源只能为单用户使用，使数据更加安全和独立。 3D可视化 我们不仅提供全周期模型资源支持，还可以通过设计师灵动设计的场景模型与现实设备进行数据互通与联动，真正实现3D万物可视，还支持3D地图等效果，支持地理数据多层叠加。 支持多种图表效果 支持各类图表，折线，点，柱，地图等都有涉及，支持多种可视化图表库，echarts，highcharts，d3，g2等。 数据下钻和上浮 支持多图表数据联动，以及下钻和上浮 发版案例能源行业在高峰用量时段，若电力供应不足可能导致断电。相反，则会造成资源浪费。先进的需求预测技术可以详细预测特定日每小时的需求与高峰时。我们还针对电力产生企业进行煤耗、智能发电进行全面的技术支持。 智慧发电控系统 携手国家能源集团 BIPV光伏发电控制 东胜电厂数据大屏 旅游行业游客来源:通过车牌、游客的手机号码、身份证多维度的分析明确广告投放。 车流:对车流量、各卡口入口的流量进行分析，方便进行整体交通疏导。 搜索分析:对数据关键词进行定制和展示，帮助宣传、文案引导来源客流。 门票、酒店:全面对门票销售数据、时间数据进行对比，以及对酒店入住进行分析。 环境检测:对于景区的整体环镜、PM2.5、负氧离子进行分析，对景区更信赖 。 全国旅游分布图 旅游车辆信息汇总 个人创作手搭新冠疫情大数据趋势 利用静态数据和炫酷的图片，个人也能很容易搭建出一个可视化大屏，在屏幕上发挥自己的聪明才智！！！ 线上测试地址地址： http://ys.kwcnet.com/ 账号：admin 密码： admin","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://yangyfeng.github.io/blogpost/categories/个人项目/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/tags/前端/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://yangyfeng.github.io/blogpost/tags/数据可视化/"}]},{"title":"2021年前端重修课","slug":"前端干货/2021年前端重修课","date":"2021-02-01T16:00:00.000Z","updated":"2021-03-07T04:43:19.242Z","comments":true,"path":"/posts/cf2c43d.html","link":"","permalink":"https://yangyfeng.github.io/posts/cf2c43d.html","excerpt":"","text":"2021年前端重修课","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangyfeng.github.io/blogpost/tags/Javascript/"}]},{"title":"Babel转码器","slug":"Es6/Babel 转码器","date":"2021-01-07T16:00:00.000Z","updated":"2021-03-07T04:26:04.124Z","comments":true,"path":"/posts/390a51fc.html","link":"","permalink":"https://yangyfeng.github.io/posts/390a51fc.html","excerpt":"","text":"Babel 是一个广泛使用的 ES6 转码器(下一代的JavaScript编译器)，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 下面的命令在项目目录中，安装 Babel。 1$ npm install --save-dev @babel/core 配置文件.babelrcBabel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; \"presets\": [], \"plugins\": []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 12345# 最新转码规则$ npm install --save-dev @babel/preset-env# react 转码规则$ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc。 1234567&#123; \"presets\": [ \"@babel/env\", \"@babel/preset-react\" ], \"plugins\": [] &#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 命令行转码 Babel 提供命令行工具@babel/cli，用于命令行转码。 它的安装命令如下。 1$ npm install --save-dev @babel/cli 基本用法如下。 1234567891011121314151617# 转码结果输出到标准输出$ npx babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ npx babel example.js --out-file compiled.js# 或者$ npx babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ npx babel src --out-dir lib# 或者$ npx babel src -d lib# -s 参数生成source map文件$ npx babel src -d lib -s polyfillBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用core-js和regenerator-runtime(后者提供generator函数的转码)，为当前环境提供一个垫片。 安装命令如下。 1$ npm install --save-dev core-js regenerator-runtime 然后，在脚本头部，加入如下两行代码。 12345import 'core-js';import 'regenerator-runtime/runtime';// 或者require('core-js');require('regenerator-runtime/runtime); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Es6","slug":"Es6","permalink":"https://yangyfeng.github.io/blogpost/tags/Es6/"}]},{"title":"globalThis对象","slug":"Es6/globalThis对象","date":"2021-01-07T16:00:00.000Z","updated":"2021-03-07T04:26:08.443Z","comments":true,"path":"/posts/180dd8a3.html","link":"","permalink":"https://yangyfeng.github.io/posts/180dd8a3.html","excerpt":"","text":"JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node.js 模块中this返回的是当前模块，ES6 模块中this返回的是undefined。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Es6","slug":"Es6","permalink":"https://yangyfeng.github.io/blogpost/tags/Es6/"}]},{"title":"js 优化for循环-Duff装置","slug":"前端干货/js 优化for循环-Duff装置","date":"2020-12-23T16:00:00.000Z","updated":"2021-03-07T04:41:47.486Z","comments":true,"path":"/posts/ef7302f6.html","link":"","permalink":"https://yangyfeng.github.io/posts/ef7302f6.html","excerpt":"","text":"循环是编程中常见的结构，在javaScript程序中同样随处可见。当我们要处理的数据集很大时，for循环的优化就显得格外重要了。 如下是一个常见的for循环： 123for(var i = 0; i &lt; values.length; i++) &#123; console.log(values[i])&#125; 这段代码中每循环一次都要计算一次values的长度，所以我们可以将循环由i递增改为i递减，在这个过程中，将终止条件values.l ength的O(n)调用简化成了O(1)调用，初次优化的代码如下： 123for(var i = values.length -1; i &gt;= 0; i--)&#123; console.log(values[i])&#125; 我们还可以将循环改为后测试循环，如下： 123456var i = values.length - 1;if (i &gt; -1) &#123; do&#123; console.log(values[i]); &#125;while(--i &gt;= 0)&#125; 以上的代码主要是将终止条件和自减操作符组合成了单个语句，不过使用后测试循环必须要保证要处理的值必须有一个。空数组会导致多余的一次循环。 以上的优化都是基于终止条件和自减操作，循环的次数依然没有变化，如果我们能减少循环的次数，代码运行速度是不是会更快呢。接下来我们介绍下一种叫Duff装置的技术。Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句。请看以下代码： 12345678910111213141516var iterations = Math.ceil(values.length / 8);var startAt = values.length % 8;var i = 0;do&#123; switch(startAt)&#123; case 0: console.log(values[i++]); case 7: console.log(values[i++]); case 6: console.log(values[i++]); case 5: console.log(values[i++]); case 4: console.log(values[i++]); case 3: console.log(values[i++]); case 2: console.log(values[i++]); case 1: console.log(values[i++]); &#125; startAt = 0;&#125;while(--iterations &gt; 0) 我们假设循环次数是10次，在普通的for循环中，会进入循环体10次，每一次打印对应的值。而在以上的代码中，我们计算出iterations是2，startAt是2，第一次进入switch语句的时候，会执行两次console语句，startAt重置为0，iterations自减为1，第二次进入switch语句时，就,会执行8次console语句， 然后退出循环。以上只执行了两次循环，打印的次数依然是10次，我们减少了循环的次数和处理终止条件的额外开销，在数据量很大的时候，可以使代码运行的更快。基于以上代码，Andrew B.King提出了一个更快的Duff装置技术，将do-while循环分成两个单独的循环。代码如下： 123456789101112131415161718var iterations = Math.floor(values.length / 8);var leftover = values.length % 8;var i = 0;if(leftover &gt; 0)&#123; do&#123; console.log(values[i++]); &#125;while(--leftover &gt; 0);&#125;do&#123; console.log(values[i++]); console.log(values[i++]); console.log(values[i++]); console.log(values[i++]); console.log(values[i++]); console.log(values[i++]); console.log(values[i++]); console.log(values[i++]);&#125;while(--iterations &gt; 0) 以上的代码没有switch语句，每次进入第二个do-while循环时，执行8次console即可，这个方法比几乎比原始的Duff装置实现快上40%。针对大数据集使用Duff装置技术可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。我们可以将duff装置技术封装成一个类似于forEach的方法，代码如下： 123456789101112131415161718192021222324Array.prototype.duffForEach = function (fn) &#123; const len = this.length; var num = Math.floor(len / 8); var leftover = len % 8; var i = 0; if (leftover &gt; 0) &#123; do &#123; fn(this[i], i++); &#125; while (--leftover &gt; 0); &#125; if (this.length &lt; 8) &#123; return &#125; do &#123; fn(this[i], i++); fn(this[i], i++); fn(this[i], i++); fn(this[i], i++); fn(this[i], i++); fn(this[i], i++); fn(this[i], i++); fn(this[i], i++); &#125; while (--num &gt; 0);&#125;; 我们可以测试一下： 1234let arr = [1, 2, 3, 4, 5];arr.duffForEach((item, index) =&gt; &#123; console.log(item, index)&#125;) 可以看到，结果不出意料是正常的 原文地址","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"代码优化","slug":"代码优化","permalink":"https://yangyfeng.github.io/blogpost/tags/代码优化/"}]},{"title":"V8引擎是如何运行JS","slug":"前端干货/V8引擎是如何运行JS","date":"2020-12-21T16:00:00.000Z","updated":"2021-03-07T04:43:19.242Z","comments":true,"path":"/posts/cf2c43d.html","link":"","permalink":"https://yangyfeng.github.io/posts/cf2c43d.html","excerpt":"","text":"什么是V8引擎一个接受JavaScript代码，编译代码然后执行的C++ 程序，编译后的代码可以在多种操作系统多种处理器上运行。 介绍 哪些程序用到V8 Chrome浏览器的JS引擎是V8 Nodejs的运行时环境是V8 electron的底层引擎是V8 跨平台桌面应用开发工具 blink是渲染引擎，V8是JS引擎 访问Dom的接口是由Blink提供的 功能 接收JavaScript代码，编译代码后执行C++程序，编译后的代码可以在多种操作系统多种处理器上运行。编译和执行JS代码、处理调用栈、内存分配、垃圾回收。 编译和执行JS代码 处理调用栈 内存分配 垃圾回收 V8的js编译和执行 解析器 parser js –&gt; 解析成功抽象语法树AST 解释器 interpreter AST –&gt; 字节码bytecode，也有直接执行字节码的能力 编译器 compiler bytecode –&gt; 更高效的机器码 V8版本5.9之前没有解释器，但是有两个编译器 5.9版本的V8 parser 解释器生成抽象语法树AST compiler 编译器Full-codegen 基准编译器 直接生成机器码 运行一段时间后，由分析器线程优化js代码 compiler 编译器CrankShaft 优化编译器 重新生成AST提升运行效率 这样设计的缺点 机器码会占用大量的内存 缺少中间层机器码，无法实现一些优化策略 无法很好的支持和优化JS的新语特性，无法拥抱未来 新版本的V8 parser 解析器 生成AST抽象语法树 interpreter 解释器 Ignition 生成byteCode字节码 并直接执行 清除AST 释放内存空间 得到25% - 50%的等效机器代码大小 compiler 运行过程中，解释器收集优化信息发送给编译器TurboFan 重新生成机器码 有些热点函数变更会由优化后的机器码还原成字节码 也就是deoptimization 回退字节码操作执行 优化点： 值声明未调用，不会被解析生成AST 函数只被调用一次，bytcode直接被解释执行，不会进入到编译优化阶段 函数被调用多次，Igniton会收集函数类型信息，可能会被标记为热点函数，可能被编译成优化后的机器代码 好处： 由于一开始不需要直接编译成机器码，生成了中间层的字节码，从而节约了时间 优化编译阶段，不需要从源码重新解析,直接通过字节码进行优化，也可以deoptimization回退操作 12345function sum(x,y)&#123;return x + y&#125;;sum(1,2);sum(3,4);sum(5,6);sum(\"7\",\"8\");//会回退字节码操作执行 原文地址","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangyfeng.github.io/blogpost/tags/Javascript/"},{"name":"JS运行原理","slug":"JS运行原理","permalink":"https://yangyfeng.github.io/blogpost/tags/JS运行原理/"},{"name":"V8引擎","slug":"V8引擎","permalink":"https://yangyfeng.github.io/blogpost/tags/V8引擎/"}]},{"title":"javascript是如何被运行的","slug":"前端干货/javascript是如何被运行的","date":"2020-12-21T16:00:00.000Z","updated":"2021-03-07T04:43:19.243Z","comments":true,"path":"/posts/81adf3b6.html","link":"","permalink":"https://yangyfeng.github.io/posts/81adf3b6.html","excerpt":"JS的语言组成 基本语法：C 数据类型 内存管理：Java 函数式编程：Scheme 函数是第一等公民 原型继承：Self 基于原型prototype的继承机制 奇葩的JS对于熟悉javascript语言的前端开发小伙伴，直接上来两张图 是不是瞬间感觉头脑发热呢。 之所以会出现这些诡异的问题，是因为javascript是在设计之初并没有考虑的完善，是借鉴了多种语言的模式，基本是融合了面向过程和面向对象的。","text":"JS的语言组成 基本语法：C 数据类型 内存管理：Java 函数式编程：Scheme 函数是第一等公民 原型继承：Self 基于原型prototype的继承机制 奇葩的JS对于熟悉javascript语言的前端开发小伙伴，直接上来两张图 是不是瞬间感觉头脑发热呢。 之所以会出现这些诡异的问题，是因为javascript是在设计之初并没有考虑的完善，是借鉴了多种语言的模式，基本是融合了面向过程和面向对象的。 语言特性动态类型语言 JS 编译环境JIT Just In Time Compilation 静态类型语言 C++ 编译环境 AOT Ahead Of Time JIT js引擎运用了一项技术叫运行时编译 JITjavascript是动态类型语言，在编译是使用的是JIT(just in time compilation) 运行时编译技术白话就是：在运行时编译成机器代码 AOT 在运行前提前生成好机器代码 javascript引擎 将javascript代码高级语言转化为低级语言（机器语言）来执行 常用的执行javascript引擎 谷歌的v8引擎，javascriptcore，spidermonkey，quickjs，hermess(react nactive) 谷歌V8 苹果 - javaScriptCore 火狐 - SpideMonkey QuickJs FaceBook - Hermes javascript引擎的编译流程 说明： javascript代码解析器（parser）解析成抽象语法树AST，通过解释器（interpreter）将AST编译为字节码bytecode(跨平台的一种中间表示，可以在不同的操作平台运行),字节码最后通过编译器，生成机器代码。V8在5.9之前 是没有字节码的环节。 parser - 将js源码通过parser解析器生成AST 抽象语法树 interpreter - 通过解释器将AST编程成功字节码bytecode (字节码与平台无关，是中间层，可以在各个平台上运行) compiler - 根据当前平台编译出相应的机器代码也就是汇编代码 常见的操作系统平台有：IA32 X64 ARM MIPS 原文地址","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangyfeng.github.io/blogpost/tags/Javascript/"},{"name":"JS运行原理","slug":"JS运行原理","permalink":"https://yangyfeng.github.io/blogpost/tags/JS运行原理/"}]},{"title":"互联网是如何运作的","slug":"前端干货/互联网是如何运作的","date":"2020-12-21T16:00:00.000Z","updated":"2021-03-07T04:42:46.533Z","comments":true,"path":"/posts/c35109d5.html","link":"","permalink":"https://yangyfeng.github.io/posts/c35109d5.html","excerpt":"互联网所有的传输都通过RCP/IP协议族来传输，TCP/IP是面向连接的可靠字节流服务协议 什么是协议协议是一组规则，用于指定计算机应该如何通过网络来交互通信 TCP/IP协议族有四层 应用层：提供特定于应用程序的协议 HTTP FTP IMAP(邮件) 网络控制层： 发送数据包到计算机上使用特定的端口号的应用程序 网络层： 使用IP地址将数据包发送到特定的计算 链路层： 将二进制数据包与网络信号相互之间转换 TCP的可靠 tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功 IP的传输 IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP TCP传输的质量和顺序 当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送 IP和IP地址的区别 Ip是一种协议 有两种标准 IPv4 2^32次方和IPv6 2^128 IP地址是一串数字192.0.0.1","text":"互联网所有的传输都通过RCP/IP协议族来传输，TCP/IP是面向连接的可靠字节流服务协议 什么是协议协议是一组规则，用于指定计算机应该如何通过网络来交互通信 TCP/IP协议族有四层 应用层：提供特定于应用程序的协议 HTTP FTP IMAP(邮件) 网络控制层： 发送数据包到计算机上使用特定的端口号的应用程序 网络层： 使用IP地址将数据包发送到特定的计算 链路层： 将二进制数据包与网络信号相互之间转换 TCP的可靠 tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功 IP的传输 IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP TCP传输的质量和顺序 当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送 IP和IP地址的区别 Ip是一种协议 有两种标准 IPv4 2^32次方和IPv6 2^128 IP地址是一串数字192.0.0.1 网络传输 个人电脑 猫 local ISP 互联网服务提供商 regional ISP 经过多个主干网络 NSP 网络服务提供商 大型网络 卖带宽给ISP NAP 每个NSP连接到至少三个网络访问点 ISP NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。 个人客户端访问哔哩哔哩服务器的过程 路由器路由器服务检查路由表上是否有目的地的IP地址， 如果有直接发送到对应的网络，否则向上发送数据，在更高的层级寻找对一个拥有该IP的路由器 直到找到对应的网络的IP地址 DNS服务存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系 原文地址","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://yangyfeng.github.io/blogpost/tags/Http/"}]},{"title":"什么是JS调用栈","slug":"前端干货/什么是JS调用栈","date":"2020-12-21T16:00:00.000Z","updated":"2020-12-22T09:32:41.337Z","comments":true,"path":"/posts/9926a09c.html","link":"","permalink":"https://yangyfeng.github.io/posts/9926a09c.html","excerpt":"","text":"概念 栈：先进后出，进栈，出栈，与堆栈不同 队列：先进先出 调用栈是JS引擎追踪函数执行流程的一种机制，当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体又调用了哪个函数 例子 调用栈，调用函数执行才回入栈 push average() push sum() shift sum() shift average() push console.log() shift console.log() 123456789function sum(a, b) &#123; return a + b;&#125;function average(a, b) &#123; const aver = sum(a, b) / 2; return aver;&#125;const num = average(3, 5);console.log(num); tips 用栈持持续被调用，会导致内存溢出 原因是因为，JS主线程被占用会造成堵塞：事件循环，异步回调(宏任务，微任务，面试必问哦)","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"JS运行原理","slug":"JS运行原理","permalink":"https://yangyfeng.github.io/blogpost/tags/JS运行原理/"}]},{"title":"浏览器是如何运作的","slug":"前端干货/浏览器是如何运作的","date":"2020-12-21T16:00:00.000Z","updated":"2020-12-22T09:32:34.662Z","comments":true,"path":"/posts/41e3ecae.html","link":"","permalink":"https://yangyfeng.github.io/posts/41e3ecae.html","excerpt":"浏览器是多进程结构的进程 操作系统进行资源分配和调度的基本单元。可以申请和拥有计算机资源，进程是程序的基本执行实体。两个进程分配的资源和内存是独立，如果需要通信就要使用进程通信管道IPC来传递信息。 线程 操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 浏览器功能进程拆解 浏览器进程 控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作 缓存进程 负责控制浏览器的存储数据的缓存和读取 网络进程 发起和接受网络请求 渲染器进程 渲染Tab 有可能会为每个标签页是一个渲染进程 GPU进程 整个浏览器界面的渲染 插件进程 控制网站使用的所有内置插件，例如：flash 浏览器结构图 说明： 用户界面：展示除了标签页窗口之外的其他用户用户界面内容 渲染引擎：渲染用户获取数据的渲染内容。一下还有很多小的功能模块，如负责网络请求的网络模块，用于解析和执行js的js解释器 浏览器引擎：用户界面和渲染引擎之间传递数据 数据持久层：帮助浏览器存储持久数据，如cokies和storage。 我们称呼的内核就是指的渲染引擎，是整个浏览器的核心和灵魂 Chromium会给用户创建的每一个访问实例分配一个进程，确保每一个页面是独立呈现的，并且对每个网站的独立访问也是彼此隔离的。访问不同站点和同一站点的不同页面都会创建新的进程。一个标签就是一个新的渲染器进程。","text":"浏览器是多进程结构的进程 操作系统进行资源分配和调度的基本单元。可以申请和拥有计算机资源，进程是程序的基本执行实体。两个进程分配的资源和内存是独立，如果需要通信就要使用进程通信管道IPC来传递信息。 线程 操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 浏览器功能进程拆解 浏览器进程 控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作 缓存进程 负责控制浏览器的存储数据的缓存和读取 网络进程 发起和接受网络请求 渲染器进程 渲染Tab 有可能会为每个标签页是一个渲染进程 GPU进程 整个浏览器界面的渲染 插件进程 控制网站使用的所有内置插件，例如：flash 浏览器结构图 说明： 用户界面：展示除了标签页窗口之外的其他用户用户界面内容 渲染引擎：渲染用户获取数据的渲染内容。一下还有很多小的功能模块，如负责网络请求的网络模块，用于解析和执行js的js解释器 浏览器引擎：用户界面和渲染引擎之间传递数据 数据持久层：帮助浏览器存储持久数据，如cokies和storage。 我们称呼的内核就是指的渲染引擎，是整个浏览器的核心和灵魂 Chromium会给用户创建的每一个访问实例分配一个进程，确保每一个页面是独立呈现的，并且对每个网站的独立访问也是彼此隔离的。访问不同站点和同一站点的不同页面都会创建新的进程。一个标签就是一个新的渲染器进程。 渲染进程的过程 网络进程获取数据后通过SafeBrowsing来检查是不是恶意站点，如果是则会展示一个警告页面并提示，浏览器会阻止你的访问。SafeBrowsing：谷歌内部的站点安全检测系统获取数据后网络线程通知UI线程，然后UI线程创建一个渲染器进程（renderer thread）来渲染页面。 浏览器通过网络请求后获取html数据，通过tcp传给渲染器进程，正式进入渲染流程。 DOM - 通过tokeniser进行词法分析器生成标记，根据识别后的标记进行dom tree构造，创建DOM对象。主线程将html解析构造DOM树 style - 样式计算，生成css tree layoutTree - dom+style 根据dom树和样式生成layoutTree paint -绘制 通过遍历 Layout Tree生成绘制顺序表。将图形块转化为像素点绘制在屏幕上，这个过程叫做栅格化（rastering）。 laryer - 布局 然后根据主进程将layoutTree 和绘制信息表传给合成器线程 合成器线程 - 将得到的信息分图层分成更小的图块 栅格线程 - 将更小的图块进行栅格化raster，返还给合成器线程draw quads图块信息 存储在GPU中 frame 合成器帧通过IPC将栅格线程返回的图块合成帧交给浏览器进程 浏览器进程 收到一帧的图像后传给GPU进行渲染 重排当改变dom的属性时，会重新进行样式计算，会重新布局和绘制重绘当改变颜色时，只会发生样式计算和绘制(layer)requestAnimationFrame()会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程Fiberreact最新的渲染引擎利用浏览器的空闲时间做优化。 requestIdlCallback，这个会在每一帧最后的空余时间判断是否运行，react fiber在每一个单元任务执行前判断空余时间以及设定的最大timeout值来决定是否执行。Transform会直接运行合成器线程，所以不会感染主线程的渲染在移动端使用3d转换可以优化性能（如果设备有3d加速引擎 GPU 可以提高性能 , 2d转换是无法调用GPU，2G是靠的CPU） 原文地址","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"浏览器运行原理","slug":"浏览器运行原理","permalink":"https://yangyfeng.github.io/blogpost/tags/浏览器运行原理/"}]},{"title":"js的事件循环是什么","slug":"前端干货/js的事件循环是什么","date":"2020-12-21T16:00:00.000Z","updated":"2021-03-07T04:40:38.875Z","comments":true,"path":"/posts/62b88241.html","link":"","permalink":"https://yangyfeng.github.io/posts/62b88241.html","excerpt":"","text":"事件循环的机制概念 宏任务：script(整个代码)、setTimeout、setInterval、setImmediate、I/O、UI rendering 微任务：promise、Object.observe、MutationObserve 任务的优先级：process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate https://mp.weixin.qq.com/s/7k4skVdCIhTsTdEFmXyYLg","categories":[{"name":"深入前端","slug":"深入前端","permalink":"https://yangyfeng.github.io/blogpost/categories/深入前端/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://yangyfeng.github.io/blogpost/tags/EventLoop/"}]},{"title":"vue面试题（2）","slug":"前端每日一题/vue面试题（2）","date":"2020-12-20T16:00:00.000Z","updated":"2021-03-07T04:37:21.277Z","comments":true,"path":"/posts/e210f74f.html","link":"","permalink":"https://yangyfeng.github.io/posts/e210f74f.html","excerpt":"v-if和v-for哪个优先级更高？ 分析：此题考查常识，文档中曾有详细说明；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者应用能力。 思路分析：总分总模式 先给出结论 为什么是这样的 它们能放一起吗 如果不能，那应该怎样 总结 回答范例： v-for优先于v-if被解析 我曾经做过实验，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件 实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。 通常有两种情况下导致我们这样做： 为了过滤列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。此时把 v-if 移动至容器元素上 (比如 ul、ol)即可。 文档中明确指出永远不要把 v-if 和 v-for 同时用在同一个元素上，显然这是一个重要的注意事项。 看过源码里面关于代码生成的部分 知其所以然： 做个测试 12345678910111213ƒ anonymous() &#123; with(this) &#123; return _c('div', &#123; attrs: &#123; \"id\": \"app\" &#125; &#125;, _l((items), function(item) &#123; return (item.isActive) ? _c('div', &#123; key: item.id &#125;, [_v(\"\\n \" + _s(item.name) + \"\\n \")]) : _e() &#125;), 0) &#125;&#125; 源码中找答案 compiler/codegen/index.js","text":"v-if和v-for哪个优先级更高？ 分析：此题考查常识，文档中曾有详细说明；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者应用能力。 思路分析：总分总模式 先给出结论 为什么是这样的 它们能放一起吗 如果不能，那应该怎样 总结 回答范例： v-for优先于v-if被解析 我曾经做过实验，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件 实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。 通常有两种情况下导致我们这样做： 为了过滤列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。此时把 v-if 移动至容器元素上 (比如 ul、ol)即可。 文档中明确指出永远不要把 v-if 和 v-for 同时用在同一个元素上，显然这是一个重要的注意事项。 看过源码里面关于代码生成的部分 知其所以然： 做个测试 12345678910111213ƒ anonymous() &#123; with(this) &#123; return _c('div', &#123; attrs: &#123; \"id\": \"app\" &#125; &#125;, _l((items), function(item) &#123; return (item.isActive) ? _c('div', &#123; key: item.id &#125;, [_v(\"\\n \" + _s(item.name) + \"\\n \")]) : _e() &#125;), 0) &#125;&#125; 源码中找答案 compiler/codegen/index.js 你知道key的作用吗？分析：这是一道特别常见的问题，主要考查大家对虚拟DOM和patch细节的掌握程度，能够反映面试者理解层次。 思路分析：总分总模式 给出结论，key的作用是用于优化patch性能 key的必要性 实际使用方式 总结：可从源码层面描述一下vue如何判断两个节点是否相同 回答范例： key的作用主要是为了更高效的更新虚拟DOM。 vue在patch过程中判断两个节点是否是相同节点是key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，vue只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个patch过程比较低效，影响性能。 实际使用中在渲染一组列表时key必须设置，而且必须是唯一标识，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。 测试代码 使用key: 123456789101112131415161718192021// 首次循环patch AA B C D EA B F C D E// 第2次循环patch BB C D EB F C D E// 第3次循环patch EC D EF C D E// 第4次循环patch DC DF C D// 第5次循环patch CC F C// oldCh全部处理结束，newCh中剩下的F，创建F并插入到C前面 不使用key 源码中找答案 src\\core\\vdom\\patch.js - sameVnode() 你了解vue中的diff算法吗？题目分析：vue基于虚拟DOM做更新，diff又是其核心部分，因此常被问道，此题考查面试者深度。 答题思路：3w1h 定义diff 它的必要性 它在哪里被使用 它如何运作 提升：说一些细节 回答范例： diff算法是虚拟DOM技术的产物，vue里面实际叫做patch，它的核心实现来自于snabbdom；通过新旧虚拟DOM作对比（即patch），将变化的地方转换为DOM操作 在vue 1中是没有patch的，因为界面中每个依赖都有专门的watcher负责更新，这样项目规模变大就会成为性能瓶颈，vue 2中为了降低watcher粒度，每个组件只有一个watcher，但是当需要更新的时候，怎样才能精确找到发生变化的地方？这就需要引入patch才行。 组件中数据发生变化时，对应的watcher会通知更新并执行其更新函数，它会执行渲染函数获取全新虚拟dom：newVnode，此时就会执行patch比对上次渲染结果oldVnode和新的渲染结果newVnode。 patch过程遵循深度优先、同层比较的策略；两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。 vue中组件之间的通信方式？ 题目分析： vue是组件化开发框架，所以对于vue应用来说组件间的数据通信非常重要。此题主要考查大家vue基本功，对于vue基础api运用熟练度。另外一些边界知识如provide/inject/$attrs/$listeners则体现了面试者的知识面。 思路分析：总分 总述知道的所有方式 按组件关系阐述使用场景 回答范例： 组件通信方式大体有以下8种： props $emit/$on $children/$parent $attrs/$listeners ref $root eventbus vuex 根据组件之间关系讨论组件通信最为清晰有效 父子组件 props $emit/$on $parent / $children ref $attrs / $listeners 兄弟组件 $parent eventbus vuex 跨层级关系 provide/inject $root eventbus vuex 简单说一说你对vuex理解？ 分析：此题考查实践能力，能说出用法只能60分。更重要的是对vuex设计理念和实现原理的解读。 回答策略：3w1h 首先给vuex下一个定义 vuex解决了哪些问题，解读理念 什么时候我们需要vuex 你的具体用法 简述原理，提升层级 首先是官网定义： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 回答范例： vuex是vue专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。 vuex主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。vuex通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。 vuex并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用vuex的必要。一个简单的store 模式就足够了。反之，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。 我在使用vuex过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入state对象中，它本身一棵状态树，组件中使用store实例的state访问这些状态；然后有配套的mutation方法修改这些状态，并且只能用mutation修改状态，在组件中调用commit方法提交mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写action，执行结束如果有状态修改仍然需要提交mutation，组件中调用这些action使用dispatch方法派发。最后是模块化，通过modules选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置namespace，那么在提交mutation和派发action时还需要额外的命名空间前缀。 vuex在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了vue的数据响应化特性实现的，它会利用Vue将state作为data对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。 vue-router中如何保护路由？ 此题是考查项目实践能力，项目中基本都有路由守卫的需求，保护指定路由考查的就是这个知识点。 答题整体思路： 阐述vue-router中路由保护策略 描述具体实现方式 简单说一下它们是怎么生效的 回答范例： vue-router中保护路由安全通常使用导航守卫来做，通过设置路由导航钩子函数的方式添加守卫函数，在里面判断用户的登录状态和权限，从而达到保护指定路由的目的。 具体实现有几个层级：全局前置守卫beforeEach、路由独享守卫beforeEnter或组件内守卫beforeRouteEnter。以全局守卫为例来说，可以使用router.beforeEach((to,from,next)=&gt;{})方式设置守卫，每次路由导航时，都会执行该守卫，从而检查当前用户是否可以继续导航，通过给next函数传递多种参数达到不同的目的，比如如果禁止用户继续导航可以传递next(false)，正常放行可以不传递参数，传递path字符串可以重定向到一个新的地址等等。 这些钩子函数之所以能够生效，也和vue-router工作方式有关，像beforeEach只是注册一个hook，当路由发生变化，router准备导航之前会批量执行这些hooks，并且把目标路由to，当前路由from，以及后续处理函数next传递给我们设置的hook。 可能的追问： 1、能不能说说全局守卫、路由独享守卫和组件内守卫区别？ 作用范围 组件实例的获取 12345beforeRouteEnter(to,from,next) &#123; next(vm =&gt; &#123; &#125;)&#125; 名称/数量/顺序 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 2、你项目中的路由守卫是怎么做的？ 3、前后端路由一样吗？ 4、前端路由是用什么方式实现的？ 5、你前面提到的next方法是怎么实现的？ 你了解哪些Vue性能优化方法？ 答题思路：根据题目描述，这里主要探讨Vue代码层面的优化 路由懒加载 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: () =&gt; import('./Foo.vue') &#125; ]&#125;) keep-alive缓存页面 1234567&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 使用v-show复用DOM 1234567891011&lt;template&gt; &lt;div class=&quot;cell&quot;&gt; &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt; &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/div&gt; &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; v-for 遍历避免同时使用 v-if 1234567891011121314151617181920&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125; &#125; &#125;&lt;/script&gt; 长列表性能优化 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化 123456789export default &#123; data: () =&gt; (&#123; users: [] &#125;), async created() &#123; const users = await axios.get(\"/api/users\"); this.users = Object.freeze(users); &#125;&#125;; 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容 123456789101112&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot;&gt; &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt; &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot; /&gt; &lt;/template&gt;&lt;/recycle-scroller&gt; 参考vue-virtual-scroller、vue-virtual-scroll-list 事件的销毁 Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 123456created() &#123; this.timer = setInterval(this.refresh, 2000)&#125;,beforeDestroy() &#123; clearInterval(this.timer)&#125; 图片懒加载 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。 1&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt; 参考项目：vue-lazyload 第三方插件按需引入 像element-ui这样的第三方组件库可以按需引入避免体积太大。 12345import Vue from 'vue';import &#123; Button, Select &#125; from 'element-ui'; Vue.use(Button) Vue.use(Select) 无状态的组件标记为函数式组件 123456789101112&lt;template functional&gt; &lt;div class=&quot;cell&quot;&gt; &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt; &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&apos;value&apos;]&#125;&lt;/script&gt; 子组件分割 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;ChildComp/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123; ChildComp: &#123; methods: &#123; heavy () &#123; /* 耗时任务 */ &#125; &#125;, render (h) &#123; return h(&apos;div&apos;, this.heavy()) &#125; &#125; &#125;&#125;&lt;/script&gt; 变量本地化 123456789101112131415161718192021222324&lt;template&gt; &lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt; &#123;&#123; result &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; heavy &#125; from &apos;@/utils&apos;export default &#123; props: [&apos;start&apos;], computed: &#123; base () &#123; return 42 &#125;, result () &#123; const base = this.base // 不要频繁引用this.base let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(base) &#125; return result &#125; &#125;&#125;&lt;/script&gt; SSR 说一说你对vue响应式理解？ 烂大街的问题，但却不是每个人都能回答到位。因为如果你只是看看别人写的网文，通常没什么底气，也经不住面试官推敲，但像我们这样即看过源码还造过轮子的，回答这个问题就会比较有底气。 答题思路： 啥是响应式？ 为什么vue需要响应式？ 它能给我们带来什么好处？ vue的响应式是怎么实现的？有哪些优缺点？ vue3中的响应式的新变化 回答范例： 所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。 mvvm框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。 以vue为例说明，通过数据响应式加上虚拟DOM和patch算法，可以使我们只需要操作数据，完全不用接触繁琐的dom操作，从而大大提升开发效率，降低开发难度。 vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。 为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的Proxy机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，我们甚至不需要引入vue都可以体验。 你如果想要扩展某个Vue组件时会怎么做？ 此题属于实践题，着重考察大家对vue常用api使用熟练度，答题时不仅要列出这些解决方案，同时最好说出他们异同。 答题思路： 按照逻辑扩展和内容扩展来列举，逻辑扩展有：mixins、extends、composition api；内容扩展有slots； 分别说出他们使用使用方法、场景差异和问题。 作为扩展，还可以说说vue3中新引入的composition api带来的变化 回答范例： 常见的组件扩展方法有：mixins，slots，extends等 混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 12345678910111213// 复用代码：它是一个配置对象，选项和组件里面一样const mymixin = &#123; methods: &#123; dosomething()&#123;&#125; &#125;&#125;// 全局混入：将混入对象传入Vue.mixin(mymixin)// 局部混入：做数组项设置到mixins选项，仅作用于当前组件const Comp = &#123; mixins: [mymixin]&#125; 插槽主要用于vue组件中的内容分发，也可以用于组件扩展。 子组件Child 123&lt;div&gt; &lt;slot&gt;这个内容会被父组件传递的内容替换&lt;/slot&gt;&lt;/div&gt; 父组件Parent 123&lt;div&gt; &lt;Child&gt;来自老爹的内容&lt;/Child&gt;&lt;/div&gt; 如果要精确分发到不同位置可以使用具名插槽，如果要使用子组件中的数据可以使用作用域插槽。 组件选项中还有一个不太常用的选项extends，也可以起到扩展组件的目的 123456789101112// 扩展对象const myextends = &#123; methods: &#123; dosomething()&#123;&#125; &#125;&#125;// 组件扩展：做数组项设置到extends选项，仅作用于当前组件// 跟混入的不同是它只能扩展单个对象// 另外如果和混入发生冲突，该选项优先级较高，优先起作用const Comp = &#123; extends: myextends&#125; 混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中有机组合使用。例如： 123456789101112// 复用逻辑1function useXX() &#123;&#125;// 复用逻辑2function useYY() &#123;&#125;// 逻辑组合const Comp = &#123; setup() &#123; const &#123;xx&#125; = useXX() const &#123;yy&#125; = useYY() return &#123;xx, yy&#125; &#125;&#125; 可能的追问 : Vue.extend方法你用过吗？它能用来做组件扩展吗？ Vue2和Vue3中的响应式原理对比，分别的具体实现思路此题非常好，既考察深度又考察广度，面试者要对两个版本的响应式原理都有深入理解才能答好。 答题思路： 可以先说vue2响应式原理 然后说出它的问题 最后说出vue3是怎么解决的 回答范例： vue2数据响应式实现根据对象类型做不同处理，如果是object，则通过Object.defineProperty(obj,key,descriptor)拦截对象属性访问 1234567891011function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; return val &#125;, set(v) &#123; val = v notify() &#125; &#125;)&#125; 如果是数组，则覆盖数组的7个变更方法实现变更通知 123456789101112const arrayProto = Array.prototypeconst arrayMethods = Object.create(arrayProto);['push','pop','shift','unshift','splice','sort','reverse'] .forEach(function (method) &#123; const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) notify() return result &#125;)&#125;) 可以看到vue2中有几个问题： 初始化时需要遍历对象所有key，如果对象层级较深，性能不好 通知更新过程需要维护大量dep实例和watcher实例，额外占用内存较多 动态新增、删除对象属性无法拦截，只能用特定set/delete api代替 不支持新的Map、Set等数据结构 vue3中为了解决以上问题，使用原生的Proxy代替： 12345678910111213141516function defineReactive(obj) &#123; return new Proxy(obj, &#123; get(target, key) &#123; track(target, key) return Reflect.get(target, key) &#125;, set(target, key, val) &#123; Reflect.set(target, key, val) trigger(target, key) &#125;, deleteProperty(target, key) &#123; Reflect.deleteProperty(target, key) trigger(target, key) &#125; &#125;)&#125; 可以同时支持object和array，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能取得很大进步。 面试题剖析","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"面试题集锦（2）","slug":"前端每日一题/面试题集锦（2）","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-22T09:31:10.544Z","comments":true,"path":"/posts/63fad71d.html","link":"","permalink":"https://yangyfeng.github.io/posts/63fad71d.html","excerpt":"","text":"web安全攻击手段有哪些？以及如何防范常见的有xss, csrf, sql注入 xss(cross site scripting) 跨站脚本攻击 定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行 XSS攻击分为3类：存储型（持久型）、反射型（非持久型）、基于DOM 如何防范: 设置HttpOnly以避免cookie劫持的危险过滤，对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御 csrf(cross site request forgery) 跨站请求伪造 定义: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式 如何防范: 验证 HTTP Referer 字段请求地址中添加 token 并验证HTTP 头中自定义属性并验证 sql注入(SQL injection) 定义: 在未授权情况下，非法访问数据库信息 如何防范: 杜绝用户提交的参数入库并且执行在代码层，不准出现sql语句在web输入参数处，对所有的参数做sql转义上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试 前端优化手段有哪些？ 静态资源合并压缩(js,css, images) 请求数量优化 Gzip压缩 带宽优化 CDN 就近节点，减少DNS查找 按需加载 lazyload 减少请求 骨架屏 优化白屏 web缓存 缓存ajax数据 减少重绘和重排 批量更新ＤＯＭ样式 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 如何理解es6中的Decorator（装饰器）？定义 Decorator是ES7中的提案，概念借鉴于python， 它作用于一个目标类为其添加属性于方法 我们用一个比喻来理解Decorator, 把孙悟空看成是一个类，那么棒子就是装饰器为其装备的武器 代码理解: 123456789101112131415161718@stickclass Monkey &#123; &#125;function stick(target) &#123;// 第一个参数就是目标类的本身 target.ATK = 100000&#125;Monkey.ATK// 为悟空装备了棒子，攻击力提高了100000// 如果一个参数不够用，可以在装饰器外层再包一层function stick(atk) &#123; return function (targt) &#123; target.ATK = atk &#125;&#125;@stick(200000)// 这样我们就为悟空增加了200000攻击力class Monkey &#123; &#125; Decorator 不仅能修饰类，也能修饰类的方法 123456class Monkey &#123; @setName name() &#123; this.name = '孙悟空' &#125;&#125; Decorator 只能修饰类及类的方法,不能修饰于函数,因为存在函数提升 Mixin 在修饰器基础上，我们可以实现mixin(混入),意思在一个对象中混入另一个对象的方法 代码示例: 12345678910111213141516171819export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;const skill = &#123; shapeshifting() &#123; console.log('72变') &#125;&#125;@mixins(skill)class Monkey &#123;&#125;Object.assign(Monkey.prototype, skill)const swk = new Monkey()swk.shapeshifting() // 72变 使用Decorator的好处 扩展功能，相对于继承增加了更多的灵活性 代码可读性更高，装饰器正确命名相当于注释","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"深入webpack","slug":"前端工程化/深入webpack","date":"2020-12-15T16:00:00.000Z","updated":"2021-03-07T04:44:19.961Z","comments":true,"path":"/posts/a441c8bd.html","link":"","permalink":"https://yangyfeng.github.io/posts/a441c8bd.html","excerpt":"","text":"实现步骤：0、读取webpack.config.js 1、解析文件依赖 2、替换require为webpack_require 3、本地使用{}存储所有的文件，然后通过使用为webpack_require获取文件内容，执行函数方式为evel的包裹代码字符串 代码实现index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#! /usr/bin/env node// 读取configconst path = require('path')const fs = require('fs')// 默认配置const defaultConfig = &#123; entry: './src/index.js', output: &#123; filename: 'build.js' &#125;&#125;// 最终的配置const config = &#123; ...defaultConfig, ...require(path.resolve('./mywebpack.config.js'))&#125;class MyWebPack &#123; constructor(config) &#123; this.config = config this.entry = config.entry // 根目录 this.root = process.cwd() // 存储所有代码 this.modules = &#123;&#125; &#125; start() &#123; console.log('解析依赖') const entryPath = path.resolve(this.root, this.entry) this.createModule(entryPath, this.entry) // 生成新文件 this.generaleFile() &#125; // 代码字符串 generaleModuleString() &#123; let fnTmp = '' for (const name in this.modules) &#123; fnTmp += `\"$&#123;name&#125;\":$&#123;this.modules[name].replace(/\\r|\\n/g, \"\")&#125;,` &#125; fnTmp = fnTmp.substring(0, fnTmp.length - 1) return `&#123;$&#123;fnTmp&#125;&#125;` &#125; // 生成新文件 generaleFile() &#123; let template = fs.readFileSync(path.resolve(__dirname, './template.js'), 'utf-8') this.template = template.replace('__entry__', this.entry).replace('__modules_content__', this.generaleModuleString()) fs.mkdirSync(\"./mydist\"); fs.writeFileSync('./mydist/' + this.config.output.filename, this.template) console.log('写入文件完毕'); &#125; // 创建依赖 createModule(modulePath, name) &#123; // 出现了循环依赖 // if (this.modules[modulePath]) return const fileContent = fs.readFileSync(modulePath, 'utf-8') // 替换后的代码和依赖数组 const &#123; code, deps &#125; = this.parse(fileContent, path.dirname(name)) this.modules[name] = `function (module, module.exports, __mywebpack_require__) &#123; eval(\\`$&#123;code&#125;\\`) &#125;` // 循环获取所有依赖数组的内容 deps.forEach(dep =&gt; &#123; this.createModule(path.join(this.root, dep), './' + dep) &#125;) console.log(this.modules) &#125; // 文件解析 parse(code, parent) &#123; let deps = [] let r = /require\\('(.*)'\\)/g // require('xxx') 将require替换__mywebpack_require__ code = code.replace(r, function (match, arg) &#123; const retPath = path.join(parent, arg.replace(/'|\"/g, '')) deps.push(retPath) return `__mywebpack_require__(\"./$&#123;retPath&#125;\")` &#125;) return &#123; code, deps &#125; &#125;&#125;const mywebpack = new MyWebPack(config)mywebpack.start() template.js 12345678910111213141516171819!function (modules) &#123; // 缓存 const installModules = &#123;&#125; // 替换后的require function __mywebpack_require__(moduleId) &#123; // 是否缓存 if (installModules[moduleId]) &#123; return installModules[moduleId].exports &#125; let modules = installModules[moduleId] = &#123; exports: &#123;&#125; &#125; modules[moduleId].call(modules.exports, module, exports, __mywebpack_require__) return module.exports &#125; // 入口 return __mywebpack_require__(\"__entry__\")&#125;(__modules_content__)","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://yangyfeng.github.io/blogpost/tags/Webpack/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"}]},{"title":"深入前端模块化","slug":"前端工程化/深入前端模块化","date":"2020-12-15T16:00:00.000Z","updated":"2020-12-22T09:32:18.050Z","comments":true,"path":"/posts/c00659d0.html","link":"","permalink":"https://yangyfeng.github.io/posts/c00659d0.html","excerpt":"什么是前端的模块化？理解的不太透彻。 平常一直用的也只有ES6模块化，对于其他几种模块化规范用的也少，理解不够深，但是经常会见到一些面试题是问这几种模块化规范的区别，所以这次做一个整理总结 一、对于模块化的理解1、什么是模块化？模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的AMD规范，CMD规范，以及ES6自带的模块化规范 2、模块化带来的好处？ 解决命名冲突 提供复用性 提高代码可维护性 灵活架构，焦点分离，方便模块间组合、分解 多人协作互不干扰 3、模块化规范的发展进程 原始写法（全局function） 模块就是实现特定**功能的一组方法，只要把不同的函数（以及记录状态的变量）简单的放在一起，就算是一个模块。 123456function m1 () &#123; // ...&#125;function m2 () &#123; // ...&#125; 这样写上面的函数 m1() 和 m2() ，组成了一个模块，在使用的时候直接调用就可以了。 但是带来的问题也很明显：&quot;污染&quot;了全局变量 ，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系 namespace写法（简单对象） 为了解决上面写法带来的缺点，可以吧模块写成一个对象，所有的模块成员都放到这个对象里面，这样减少了全局变量，减少命名冲突 123456789101112131415161718const myModule = new Object(&#123; count: 0, m1: function () &#123; console.log('m1:' + this.count); &#125;, m2: function () &#123; console.log('m2:' + this.count) &#125;&#125;)// 调用myModule.m1() // m1:0// 改变模块内部状态myModule.count = 5;myModule.m1() // m1:5 上面的函数 m1 和 m2 ，都封装在myModule对象里。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 立即执行函数写法（匿名函数自执行 ，闭包） 12345678910111213const myModule = (function () &#123; let count = 0; let m1 = function () &#123; console.log('m1:' + count) &#125;; let m2 = function () &#123; console.log('m2:' + count) &#125; return &#123; m1, m2 &#125;;&#125;)()// 这样写在外面就无法读取内部的 count 变量console.log(myModule.count); // undefined 立即执行函数增强(引入依赖) 12345const myModule = (function ($) &#123; // 这里面就可以使用JQuery&#125;)(JQuery)// 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显","text":"什么是前端的模块化？理解的不太透彻。 平常一直用的也只有ES6模块化，对于其他几种模块化规范用的也少，理解不够深，但是经常会见到一些面试题是问这几种模块化规范的区别，所以这次做一个整理总结 一、对于模块化的理解1、什么是模块化？模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的AMD规范，CMD规范，以及ES6自带的模块化规范 2、模块化带来的好处？ 解决命名冲突 提供复用性 提高代码可维护性 灵活架构，焦点分离，方便模块间组合、分解 多人协作互不干扰 3、模块化规范的发展进程 原始写法（全局function） 模块就是实现特定**功能的一组方法，只要把不同的函数（以及记录状态的变量）简单的放在一起，就算是一个模块。 123456function m1 () &#123; // ...&#125;function m2 () &#123; // ...&#125; 这样写上面的函数 m1() 和 m2() ，组成了一个模块，在使用的时候直接调用就可以了。 但是带来的问题也很明显：&quot;污染&quot;了全局变量 ，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系 namespace写法（简单对象） 为了解决上面写法带来的缺点，可以吧模块写成一个对象，所有的模块成员都放到这个对象里面，这样减少了全局变量，减少命名冲突 123456789101112131415161718const myModule = new Object(&#123; count: 0, m1: function () &#123; console.log('m1:' + this.count); &#125;, m2: function () &#123; console.log('m2:' + this.count) &#125;&#125;)// 调用myModule.m1() // m1:0// 改变模块内部状态myModule.count = 5;myModule.m1() // m1:5 上面的函数 m1 和 m2 ，都封装在myModule对象里。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 立即执行函数写法（匿名函数自执行 ，闭包） 12345678910111213const myModule = (function () &#123; let count = 0; let m1 = function () &#123; console.log('m1:' + count) &#125;; let m2 = function () &#123; console.log('m2:' + count) &#125; return &#123; m1, m2 &#125;;&#125;)()// 这样写在外面就无法读取内部的 count 变量console.log(myModule.count); // undefined 立即执行函数增强(引入依赖) 12345const myModule = (function ($) &#123; // 这里面就可以使用JQuery&#125;)(JQuery)// 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显 二、模块化规范1. CommonJS(1)简介Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。 (2)特点 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 (3)基本语法12暴露模块：module.exports = value或exports.xxx = value引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径 CommonJS暴露的模块到底是什么? CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 1234567// example.jslet count = 5;let incrementCount = function () &#123; return ++count&#125;module.exports.count = count;module.exports.incrementCount = incrementCount; 1234// require.jsconst example = require('./example.js');console.log(example.count); // 5console.log(example.incrementCount()); // 6 require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 (4)模块的加载机制CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（ES6输入的是值的引用） 1234567// example.jslet count = 5;let incrementCount = function () &#123; return ++count&#125;module.exports = &#123; count, incrementCount &#125;; 1234567// require.jsconst example = require('./example.js');console.log(example.count); // 5example.incrementCount();console.log(example.count); // 5 2. AMD(1)简介CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 此外AMD规范比CommonJS规范在浏览器端实现要来着早。 (2)基本语法1234567/*** @param id* @param dependencies* @param factory*/define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。 factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 (3)用例定义一个名为 myModule 的模块，它依赖 jQuery 模块： 1234567define('myModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用require(['myModule'], function(myModule) &#123;&#125;); 依赖多个模块的定义： 1234define(['jquery', './math.js'], function($, math) &#123; // $ 和 math 一次传入 factory $('body').text('hello world');&#125;); 模块输出： 123456789define(['jquery'], function($) &#123; var HelloWorldize = function(selector)&#123; $(selector).text('hello world'); &#125;; // HelloWorldize 是该模块输出的对外接口 return HelloWorldize;&#125;); 在模块定义内部引用依赖： 1234define(function(require) &#123; var $ = require('jquery'); $('body').text('hello world');&#125;); 3. CMD(1)简介CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。 (2)基本语法123456/*** @param &#123;String&#125; id* @param &#123;Array&#125; dependencies* @param &#123;Function | Object | String&#125; factory*/define(id?, dependencies?, factory) factory 为对象、字符串时，表示模块的接口就是该对象、字符串。 123define(&#123; \"foo\": \"bar\" &#125;);define('I am a template. My name is &#123;&#123;name&#125;&#125;.'); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module： 123456define(function(require, exports, module) &#123; // 模块代码&#125;); (3)简单用例定义没有依赖的模块： 1234define(function(require, exports, module)&#123; exports.xxx = value module.exports = value&#125;) 定义有依赖的模块： 123456789define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require('./module2') //引入依赖模块(异步) require.async('./module3', function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) 4. ES6模块化(1) 简介ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 (2) 基本语法export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 1234567891011121314/** 定义模块 **/var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;;/** 引用模块 **/import &#123; basicNum, add &#125; from './math';function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; 导出模块还可以有种默认导出的写法 module.export : 123456789// export-default.jsexport default function () &#123; console.log('foo');&#125;// 模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。// import-default.jsimport customName from './export-default'; customName(); // 'foo' (3) ES6 模块与 CommonJS 模块的差异 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块输出的是一个值的拷贝， ES6 模块输出的是一个值的引用 差异一： 是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 差异二： 123456789101112// export.jsexport let num = 5;export let incrementNum = function() &#123; ++num;&#125;;// import.jsimport &#123; num, num2, incrementNum &#125; from '../export.js';console.log(num); // 5console.log(incrementNum());console.log(num); // 6 从上面我们不难看出 ES6 模块化 与上面CommonJS不一样的地方 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。CommonJS输入的是值的拷贝（原始类型），如果是函数、对象，也是用的引用 三、总结 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 前端模块化详解(完整版)","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"},{"name":"模块化","slug":"模块化","permalink":"https://yangyfeng.github.io/blogpost/tags/模块化/"}]},{"title":"为什么前端需要学习node","slug":"Node/为什么前端需要学习node","date":"2020-12-14T16:00:00.000Z","updated":"2021-03-07T04:31:54.043Z","comments":true,"path":"/posts/fbba48cc.html","link":"","permalink":"https://yangyfeng.github.io/posts/fbba48cc.html","excerpt":"","text":"理解解决跨域、token鉴权、Rsetful风格、XSS、CSRF等问题，学习后端的思维。（与后端有效沟通） 如何只用js语言如何开发一个全栈的应用（快速开发全栈应用） 学习全栈和架构思维的有效途径（践行工程化思想）","categories":[{"name":"后端","slug":"后端","permalink":"https://yangyfeng.github.io/blogpost/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://yangyfeng.github.io/blogpost/tags/Node/"}]},{"title":"vue性能优化","slug":"Vue/vue性能优化","date":"2020-12-10T16:00:00.000Z","updated":"2021-03-07T04:37:13.717Z","comments":true,"path":"/posts/93532fe.html","link":"","permalink":"https://yangyfeng.github.io/posts/93532fe.html","excerpt":"1、使用单文件组件我们写的tmplate配置，实际上需要编译为render函数在执行的 当使用DOM内模板或者JS内的字符串模板时，模板会在运行时被编译为render函数，通常情况这个过程已经足够快乐，但是对性能敏感的应用还是有影响的。 预编译模板最简单的方式就是使用单文件组件，单文件组件将相关的构建设置自动预编译好了，所以构建的代码已经包含了编译出来的render函数了，而不是原始的模板字符串了，减少了重新编译的过程了。（单文件组件导入使用直接使用vue-loader来处理，没有vue-tmplate的出来，使用起来会足够快速的。）","text":"1、使用单文件组件我们写的tmplate配置，实际上需要编译为render函数在执行的 当使用DOM内模板或者JS内的字符串模板时，模板会在运行时被编译为render函数，通常情况这个过程已经足够快乐，但是对性能敏感的应用还是有影响的。 预编译模板最简单的方式就是使用单文件组件，单文件组件将相关的构建设置自动预编译好了，所以构建的代码已经包含了编译出来的render函数了，而不是原始的模板字符串了，减少了重新编译的过程了。（单文件组件导入使用直接使用vue-loader来处理，没有vue-tmplate的出来，使用起来会足够快速的。） 2、使用Objaec.freeze()提升性能参考vue源码，定义响应式的时候，如果freeze后的数据，不会加上setter和getter https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js 1234const property = Object.getOwnPropertyDescriptor(obj, key)if (property &amp;&amp; property.configurable === false) &#123; return&#125; 3、扁平化数据storestore数据扁平化，减少数据层级嵌套，减少遍历。 4、列表渲染优化如果的我们的应用存在无限长或者无限滚动的长列表，那么采用 窗口化的技术来优化，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。 vue-virtual-scroll-list vue-virtual-scroller 可以使用上面的两个库来处理 5、骨架屏 webpack骨架屏的实践方案: https://www.jianshu.com/p/ec4bf33ab2c8 6、 ssr服务端渲染 实现方案可以采用nuxt.js 7、 路由懒加载https://router.vuejs.org/zh/guide/advanced/lazy-loading.html 8、 gzip、缓存控制、cdn开启GZIP 体积对比图：1541KB vs 466KB 耗时对比图：333ms vs 225ms 操作步骤： 1、安装包（新版本的好像配置还要改~~） npm install --save-dev compression-webpack-plugin 2、webpack的配置 123productionGzip: true,productionGzipExtensions: ['js', 'css'] 3、nginx添加配置： 12345678server &#123; gzip on; #开启或关闭gzip on off gzip_static on; gzip_disable \"msie6\"; #不使用gzip IE6 gzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节） gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #压缩文件类型 ...&#125; CND加速 vue打包文件会默认把所有的第三方代码打包到一个vendor.js中，我们可以把部分超大的文件剥离出来，使用cnd资源。如图，我们将vue/vuex/vue-router/axios分离出来降低vendor.js的压力。 1、引入外部资源CDN 2、webpack处理（别名处理） key：要引入的资源名称；value：模块提供给外部引用的名称 3、去除引用，如果想避免全局污染，可如下定义","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"性能优化","slug":"性能优化","permalink":"https://yangyfeng.github.io/blogpost/tags/性能优化/"}]},{"title":"vue面试题（1）","slug":"前端每日一题/vue面试题（1）","date":"2020-12-10T16:00:00.000Z","updated":"2021-03-07T04:37:18.381Z","comments":true,"path":"/posts/f0a558a1.html","link":"","permalink":"https://yangyfeng.github.io/posts/f0a558a1.html","excerpt":"Vue双向绑定实现原理？vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 双花括弧），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 Observer 对所有数据的属性进行监听 Compile 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 Watcher 作为连接Observer 跟 Compile 之间的桥梁, 能够订阅接收到每个属性变动的通知,执行相应的回调函数 代码理解: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const Dep = function() &#123; this.subs = []&#125;;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(sub = &gt; &#123; sub.update() &#125;) &#125;,&#125;;const Watcher = function(vm, node, name) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null&#125;;Watcher.prototype = &#123; update: function() &#123; this.get(); this.node.nodeValue = this.value &#125;, get: function() &#123; this.value = this.vm[this.name] &#125;,&#125;;const compile = function(node, vm) &#123; if (node.nodeType === 1) &#123; let attr = node.attributes; for (let i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName === 'v-model') &#123; let name = attr[i].nodeValue; node.addEventListener('input', e = &gt; &#123; vm[name] = node.value &#125;); node.value = vm[name]; node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.nodeValue)) &#123; let name = RegExp.$1; name = name.trim(); node.nodeValue = vm[name]; new Watcher(vm, node, name) &#125; &#125;&#125;;const observe = data = &gt; &#123; if (!data || typeof data !== 'object') return 3344; Object.keys(data).forEach(key = &gt; defineReactive(data, key, data[key]))&#125;;const defineReactive = (data, key, value) = &gt; &#123; const dep = new Dep(); observe(value); Object.defineProperty(data, key, &#123; get: () = &gt; &#123; if (Dep.target) dep.addSub(Dep.target); return value &#125;, set: function(newValue) &#123; console.log(`数据已发生变化，新的值为$ &#123; newValue &#125;`); value = newValue; dep.notify() &#125;, &#125;)&#125;;function nodeToFragment(node, vm) &#123; let flag = document.createDocumentFragment(); let child; while ((child = node.firstChild)) &#123; compile(child, vm); flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; let data = this.data = options.data; observe(data, this); let id = options.el; let dom = nodeToFragment(document.getElementById(id), data); document.getElementById(id).appendChild(dom)&#125;let vm = new Vue(&#123; el: 'app', data: &#123; text: 'example text', &#125;,&#125;); 题目分析：双向绑定是vue的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。 思路分析：3w1h 给出双绑定义 双绑带来的好处 在哪使用双绑 使用方式 扩展：使用细节、原理实现描述 回答范例： vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。 使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好 通常在表单项上使用v-model 原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件 我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。 可能的追问： v-model和sync修饰符有什么区别 自定义组件使用v-model如果想要改变事件名或者属性名应该怎么做 观察输出的渲染函数： 123456789101112// &lt;input type=\"text\" v-model=\"foo\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (foo), expression: \"foo\" &#125;], attrs: &#123; \"type\": \"text\" &#125;, domProps: &#123; \"value\": (foo) &#125;, on: &#123; \"input\": function ($event) &#123; if ($event.target.composing) return; foo = $event.target.value &#125; &#125; &#125;) 123456789101112131415161718192021// &lt;input type=\"checkbox\" v-model=\"bar\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (bar), expression: \"bar\" &#125;], attrs: &#123; \"type\": \"checkbox\" &#125;, domProps: &#123; \"checked\": Array.isArray(bar) ? _i(bar, null) &gt; -1 : (bar) &#125;, on: &#123; \"change\": function ($event) &#123; var $$a = bar, $$el = $event.target, $$c = $$el.checked ? (true) : (false); if (Array.isArray($$a)) &#123; var $$v = null, $$i = _i($$a, $$v); if ($$el.checked) &#123; $$i &lt; 0 &amp;&amp; (bar = $$a.concat([$$v])) &#125; else &#123; $$i &gt; -1 &amp;&amp; (bar = $$a.slice(0, $$i).concat($$a.slice($$i + 1))) &#125; &#125; else &#123; bar = $$c &#125; &#125; &#125; &#125;) 123456789101112131415161718192021222324// &lt;select v-model=\"baz\"&gt;// &lt;option value=\"vue\"&gt;vue&lt;/option&gt;// &lt;option value=\"react\"&gt;react&lt;/option&gt;// &lt;/select&gt;_c('select', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (baz), expression: \"baz\" &#125;], on: &#123; \"change\": function ($event) &#123; var $$selectedVal = Array.prototype.filter.call( $event.target.options, function (o) &#123; return o.selected &#125; ).map( function (o) &#123; var val = \"_value\" in o ? o._value : o.value; return val &#125; ); baz = $event.target.multiple ? $$selectedVal : $$selectedVal[0] &#125; &#125; &#125;, [ _c('option', &#123; attrs: &#123; \"value\": \"vue\" &#125; &#125;, [_v(\"vue\")]), _v(\" \"), _c('option', &#123; attrs: &#123; \"value\": \"react\" &#125; &#125;, [_v(\"react\")])])","text":"Vue双向绑定实现原理？vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 双花括弧），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 Observer 对所有数据的属性进行监听 Compile 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 Watcher 作为连接Observer 跟 Compile 之间的桥梁, 能够订阅接收到每个属性变动的通知,执行相应的回调函数 代码理解: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const Dep = function() &#123; this.subs = []&#125;;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(sub = &gt; &#123; sub.update() &#125;) &#125;,&#125;;const Watcher = function(vm, node, name) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null&#125;;Watcher.prototype = &#123; update: function() &#123; this.get(); this.node.nodeValue = this.value &#125;, get: function() &#123; this.value = this.vm[this.name] &#125;,&#125;;const compile = function(node, vm) &#123; if (node.nodeType === 1) &#123; let attr = node.attributes; for (let i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName === 'v-model') &#123; let name = attr[i].nodeValue; node.addEventListener('input', e = &gt; &#123; vm[name] = node.value &#125;); node.value = vm[name]; node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.nodeValue)) &#123; let name = RegExp.$1; name = name.trim(); node.nodeValue = vm[name]; new Watcher(vm, node, name) &#125; &#125;&#125;;const observe = data = &gt; &#123; if (!data || typeof data !== 'object') return 3344; Object.keys(data).forEach(key = &gt; defineReactive(data, key, data[key]))&#125;;const defineReactive = (data, key, value) = &gt; &#123; const dep = new Dep(); observe(value); Object.defineProperty(data, key, &#123; get: () = &gt; &#123; if (Dep.target) dep.addSub(Dep.target); return value &#125;, set: function(newValue) &#123; console.log(`数据已发生变化，新的值为$ &#123; newValue &#125;`); value = newValue; dep.notify() &#125;, &#125;)&#125;;function nodeToFragment(node, vm) &#123; let flag = document.createDocumentFragment(); let child; while ((child = node.firstChild)) &#123; compile(child, vm); flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; let data = this.data = options.data; observe(data, this); let id = options.el; let dom = nodeToFragment(document.getElementById(id), data); document.getElementById(id).appendChild(dom)&#125;let vm = new Vue(&#123; el: 'app', data: &#123; text: 'example text', &#125;,&#125;); 题目分析：双向绑定是vue的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。 思路分析：3w1h 给出双绑定义 双绑带来的好处 在哪使用双绑 使用方式 扩展：使用细节、原理实现描述 回答范例： vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。 使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好 通常在表单项上使用v-model 原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件 我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。 可能的追问： v-model和sync修饰符有什么区别 自定义组件使用v-model如果想要改变事件名或者属性名应该怎么做 观察输出的渲染函数： 123456789101112// &lt;input type=\"text\" v-model=\"foo\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (foo), expression: \"foo\" &#125;], attrs: &#123; \"type\": \"text\" &#125;, domProps: &#123; \"value\": (foo) &#125;, on: &#123; \"input\": function ($event) &#123; if ($event.target.composing) return; foo = $event.target.value &#125; &#125; &#125;) 123456789101112131415161718192021// &lt;input type=\"checkbox\" v-model=\"bar\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (bar), expression: \"bar\" &#125;], attrs: &#123; \"type\": \"checkbox\" &#125;, domProps: &#123; \"checked\": Array.isArray(bar) ? _i(bar, null) &gt; -1 : (bar) &#125;, on: &#123; \"change\": function ($event) &#123; var $$a = bar, $$el = $event.target, $$c = $$el.checked ? (true) : (false); if (Array.isArray($$a)) &#123; var $$v = null, $$i = _i($$a, $$v); if ($$el.checked) &#123; $$i &lt; 0 &amp;&amp; (bar = $$a.concat([$$v])) &#125; else &#123; $$i &gt; -1 &amp;&amp; (bar = $$a.slice(0, $$i).concat($$a.slice($$i + 1))) &#125; &#125; else &#123; bar = $$c &#125; &#125; &#125; &#125;) 123456789101112131415161718192021222324// &lt;select v-model=\"baz\"&gt;// &lt;option value=\"vue\"&gt;vue&lt;/option&gt;// &lt;option value=\"react\"&gt;react&lt;/option&gt;// &lt;/select&gt;_c('select', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (baz), expression: \"baz\" &#125;], on: &#123; \"change\": function ($event) &#123; var $$selectedVal = Array.prototype.filter.call( $event.target.options, function (o) &#123; return o.selected &#125; ).map( function (o) &#123; var val = \"_value\" in o ? o._value : o.value; return val &#125; ); baz = $event.target.multiple ? $$selectedVal : $$selectedVal[0] &#125; &#125; &#125;, [ _c('option', &#123; attrs: &#123; \"value\": \"vue\" &#125; &#125;, [_v(\"vue\")]), _v(\" \"), _c('option', &#123; attrs: &#123; \"value\": \"react\" &#125; &#125;, [_v(\"react\")])]) Vue-router有几种模式？如何实现呢？ 在vue-router中有两种模式 historyhistory 为 HTML5 Api,提供了丰富的router 相关属性， 比如history.back() 就能轻松的做到页面回退 hashhash router 有一个明显的标志是url 中带有#， 我们可以通过监听url中的hash来进行路由跳转 如何实现 history 在代码实现前，我们先看看history几个api history.pushState 浏览器历史纪录添加记录 history.replaceState 修改浏览器历史纪录中当前纪录 history.popState 当history 发生变化时触发 在结合代码理解: 1234567891011121314151617181920212223242526272829class Routers &#123; contructor() &#123; this.routes = &#123;&#125;; this.listerPopState() &#125; init(path) &#123; history.replaceState(&#123; path: path &#125;, null, path); this.routes[path] &amp;&amp; this.routes[path]() &#125; route(path, callback) &#123; this.routes[path] = callback &#125; push(path) &#123; history.pushState(&#123; path: path &#125;, null, path); this.routes[path] &amp;&amp; this.routes[path]() &#125; listerPopState() &#123; window.addEventListener('popstate', e = &gt; &#123; const path = e.state &amp;&amp; e.state.path; this.routers[path] &amp;&amp; this.routers[path]() &#125;) &#125;&#125;window.VueRouter = new Routers();VueRouter.route('/', () = &gt; console.log('JS')) VueRouter.route('/detail', () = &gt; console.log('JS每日一题')) VueRouter.push('/detail') hash router 上面说过我们可以通过监听url中的hash来进行路由跳转 结合代码理解: 123456789101112131415161718class Routers &#123; constructor() &#123; this.routes = &#123;&#125;; this.currentUrl = ''; this.refresh = this.refresh.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false) &#125; route(path, callback) &#123; this.routes[path] = callback &#125; push() &#123; this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl] &amp;&amp; this.routes[this.currentUrl]() &#125;&#125;window.VueRouter = new Routers();VueRouter.route('/', () = &gt; console.log('JS')) VueRouter.route('/detail', () = &gt; console.log('JS每日一题')) VueRouter.push('/detail') 工作中不必太过纠结使用哪种模式，hash模式url中会带有#号，破坏url整体的美观性, history 需要服务端支持rewrite, 否则刷新会出现404现象 vue中keepalive怎么理解？ 说在前面: keep-alive是vue源码中实现的一个组件, 感兴趣的可以研究源码 https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js 什么是keepalive 我们平时开发中, 总有部分组件没有必要多次init, 我们需要将组件进行持久化，使组件状态维持不变，在下一次展示时， 也不会进行重新init keepalive音译过来就是保持活着, 所以在vue中我们可以使用keepalive来进行组件缓存 基本使用 12// 被keepalive包含的组件会被进行缓存&lt; keep - alive &gt; &lt; component / &gt; &lt; /keep-alive&gt; 上面提到被keepalive包含的组件不会被再次init，也就意味着不会重走生命周期函数, 但是平常工作中很多业务场景是希望我们缓存的组件在再次渲染的能做一些事情,vue为keepalive提供了两个额外的hook activated 当keepalive包含的组件再次渲染的时候触发 deactivated 当keepalive包含的组件销毁的时候触发 注: 2.1.0 版本后keepalive包含但被exclude排除的组件不会有以上两个hook 参数 keepalive可以接收3个属性做为参数进行匹配对应的组件进行缓存 include 包含的组件 exclude 排除的组件 max 缓存组件的最大值 其中include,exclude可以为字符，数组，以及正则表达式max 类型为字符或者数字 代码理解 12345678910111213141516// 只缓存组件name为a或者b的组件&lt;keep-alive include = \"a,b\" &gt; &lt;component: is = \"currentView\" /&gt; &lt;/keep-alive&gt;// 组件名为c的组件不缓存&lt;keep-alive exclude=\"c\"&gt; &lt;component:is=\"currentView\"/ &gt; &lt;/keep-alive&gt;// 如果同时使用include,exclude,那么exclude优先于include， 下面的例子也就是只缓存a组件&lt;keep-alive include=\"a,b\"exclude=\"b\"&gt; &lt;component:is=\"currentView\"/ &gt;&lt;/keep-alive&gt;// 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件&lt;keep-alive exclude=\"c\"max=\"5\"&gt; &lt;component:is=\"currentView\"/ &gt; &lt;/keep-alive&gt; 配合router使用 12345678910111213141516171819202122&lt;!-- template --&gt;// 意思就是$router.meta.keepAlive值为真是将组件进行缓存&lt;keep-alive&gt; &lt;router-view v-if=\"$router.meta.keepAlive\"&gt;&lt;/router-view&gt;&lt;router-view v-if=\"!$router.meta.keepAlive\"&gt;&lt;/router-view&gt;//router配置new Router(&#123; routes: [&#123; name: 'a', path: '/a', component: A, meta: &#123; keepAlive: true &#125; &#125;, &#123; name: 'b', path: '/b', component: B &#125;]&#125;) 总结 keepalive是一个抽象组件，缓存vnode，缓存的组件不会被mounted，为此提供activated 和 deactivated 钩子函数, 使用props max 可以控制缓存组件个数 Vue.use中都发生了什么？ 源码地址: https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js 定义 vue.use()往全局注入一个插件，供全局真接使用, 不需要单独引用 代码理解: 12345678import Router from 'vue-router'// 入口文件全局注入vue-router, 从而可以在全局使用this.$routeVue.use(Router)如果不使用vue.use那么需在组件中使用都得单独引入// a.vueimport Router from 'vue-router'// b.vueimport Router from 'vue-router' 理解了其基本使用及作用，我们来看一下vue.use中都发生了什么 源码很少，所以直接摘抄了 123456789101112131415161718192021222324Vue.use = function(plugin: Function | Object) &#123; // flow语法, 检测参数是否是函数或对象 // 拿到已安装插件列表 const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) // 如果已经安装，直接跳出方法 if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this &#125; // additional parameters // 取vue.use() 传入的参数 const args = toArray(arguments, 1) // 将vue对象填充到第一位, 最后的结构为[vue,arg1,arg2,...] args.unshift(this) // 判断插件是否有install方法，如果有执行install方法，如果没有直接把插件当install执行 if (typeof plugin.install === 'function') &#123; plugin.install.apply(plugin, args) &#125; else if (typeof plugin === 'function') &#123; plugin.apply(null, args) &#125; // 注册完成填充至已安装列表，保证每个插件只安装一次 installedPlugins.push(plugin) return this&#125; 结合代码理解 1234567891011121314151617181920212223// 代码摘抄自elementui入口文件实现上就是在install中执行了全局注册的操作// index.jsconst install = function(Vue, opts = &#123;&#125;) &#123; locale.use(opts.locale); locale.i18n(opts.i18n); components.forEach(component = &gt; &#123; Vue.component(component.name, component) &#125;);...&#125;exportdefault &#123; version: '2.5.4', locale: locale.use, i18n: locale.i18n, install, CollapseTransition, Loading, ...&#125;// main.jsimport demo from './idnex'vue.use(demo) 总结 vue.use()为注册全局插件所用，接收函数或者一个包含install属性的对象为参数，如果参数带有install就执行install, 如果没有就直接将参数当install执行, 第一个参数始终为vue对象, 注册过的插件不会重新注册 简述一下Vue.js的template编译过程？ 看一下整个流程 从上图中我们可以看到compile是从mount后开始进行中, 整体逻辑分为三个部分 解析器(parse) - 将 模板字符串 转换成 elementASTs 优化器(optimize) - 对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化 代码生成器(generate) - 使用 elementASTs 生成 render 函数代码字符串 开始前先解释一下AST AST(abstract syntax tree 抽象语法树), 是源代码的抽象语法结构的树状表现形式 从代码上简单理解一下 1234567891011121314151617181920212223&lt; div class = \"name\" &gt; JS每日一题 &lt; /div&gt;//转成AST后会得到如下格式[&#123; \"type\": \"tag\", \"name\": \"div\", \"attribs\": &#123; \"class\": \"name\" &#125;, \"children\": [&#123; \"data\": \"JS每日一题\", \"type\": \"text\", \"next\": null, \"startIndex\": 18, \"prev\": null, \"parent\": \"[Circular ~.0]\", \"endIndex\": 24 &#125;], \"next\": null, \"startIndex\": 0, \"prev\": null, \"parent\": null, \"endIndex\": 30&#125;] AST会经过generate得到render函数，render的返回值是VNode VNode的源码可以见 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/core/vdom/vnode.js 解析器(parse) 源码地址 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/parser/index.js parse 的目标是把 template 模板字符串转换成 AST 树，它是一种用 JavaScript 对象的形式来描述整个模板。那么整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的 优化器(optimize) 源码地址 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/optimizer.js 通过 optimize 把整个 AST 树中的每一个 AST 元素节点标记了 static 和 staticRoot, optimize 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变 代码生成器(generate) 源码地址 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/codegen/index.js 把优化后的 AST 树转换成可执行的代码 总结 首先通过parse将template解析成AST,其次optimize对解析出来的AST进行标记，最后generate将优化后的AST转换成可执行的代码 Vue中的nextTick如何理解，它是干什么的？ 在vue中，数据发生变化之后DOM并不会立即变化，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新 代码理解 12345this.name = 'JS每日一题' // 如这个绑定在某一个DOM元素上console.log(this.$el.textContent) // 这时DOM还没有更新,所以不会得到文字JS每日一题this.$nextTick(() = &gt;console.log(this.$el.textContent)) // nextTick 是在DOM更新后执行，这里打印JS每日一题 nextTick什么情况下会触发 在同一事件循环中的数据变化后，DOM更新完成, 执行nextTick(callback)内的回调 对事件循环不理解的可以点这里 vue中nextTick的实现 源码地址 https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js 1234567891011121314151617181920212223242526272829303132333435363738function flushCallbacks() &#123; pending = false // 复制一份callbacks const copies = callbacks.slice(0) // 清空callbacks callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; // 顺序执行nexttick传入的回调 copies[i]() &#125;&#125;exportfunction nextTick(cb ? :Function, ctx ? :Object) &#123; let _resolve // 将回调压入callbacks callbacks.push(() = &gt;&#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch(e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true // timerFunc的源码较多，大致意思就是根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数 (见上面的flushCallbacks方法) timerFunc() &#125; // 如果nextTick不传cb,就为nextTick提供一个promise调用 如: nextTick().then(()=&gt; &#123;&#125;) if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve = &gt;&#123; _resolve = resolve &#125;) &#125;&#125; 总结 数据的变化到 DOM 的重新渲染是一个异步过程, 我们必须在 nextTick 后执行DOM相关的操作 这道题考查大家对vue异步更新队列的理解，有一定深度，如果能够很好回答此题，对面试效果有极大帮助 答题思路： nextTick是啥？下一个定义 为什么需要它呢？用异步更新队列实现原理解释 我再什么地方用它呢？抓抓头，想想你在平时开发中使用它的地方 下面介绍一下如何使用nextTick 最后能说出源码实现就会显得你格外优秀 先看看官方定义 Vue.nextTick( [callback, context] ) 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 1234567&gt;// 修改数据&gt;vm.msg = 'Hello'&gt;// DOM 还没有更新&gt;Vue.nextTick(function () &#123;&gt;// DOM 更新了&gt;&#125;)&gt; 回答范例： nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。 比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。 nextTick实现原理? 此题属于原理题目，能够体现面试者对vue理解深度，答好了会加分很多。 答题思路： 此题实际考查vue异步更新策略 说出vue是怎么通过异步、批量的方式更新以提高性能的 最后把源码中实现说一下 回答范例： vue有个批量、异步更新策略，数据变化时，vue开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。然后在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 官方文档在这里 源码中，修改一个数据，组件对应的watcher会尝试入队: 1queue.push(watcher) 并使用nextTick方法添加一个flushSchedulerQueue回调 1nextTick(flushSchedulerQueue) flushSchedulerQueue被加入callbacks数组 123456789callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) // cb就是加入的回调 &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; &#125;) 然后以异步方式启动 1234if (!pending) &#123; pending = true timerFunc()&#125; timerFunc的异步主要利用Promise等微任务方式实现 1234567891011let timerFuncif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() // timerFunc利用p.then向微任务队列添加一个flushCallbacks // 会异步调用flushCallbacks timerFunc = () =&gt; &#123; p.then(flushCallbacks) &#125; isUsingMicroTask = true&#125; flushCallbacks遍历callbacks，执行里面所有回调 12345678function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 其中就有前面加入的flushSchedulerQueue，它主要用于执行queue中所有watcher的run方法，从而使组件们更新 1234for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] watcher.run()&#125; 可能的追问 你平时什么时候会用到nextTick？","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"vue3的新特性","slug":"Vue/vue3的新特性","date":"2020-12-07T16:00:00.000Z","updated":"2021-03-07T04:36:43.416Z","comments":true,"path":"/posts/86248f8a.html","link":"","permalink":"https://yangyfeng.github.io/posts/86248f8a.html","excerpt":"六大亮点 vue3官方文档 Performance：性能更比Vue 2.0强。 Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。 Composition API：组合API Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念” Better TypeScript support：更优秀的 Ts 支持 Custom Renderer API：暴露了自定义渲染API","text":"六大亮点 vue3官方文档 Performance：性能更比Vue 2.0强。 Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。 Composition API：组合API Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念” Better TypeScript support：更优秀的 Ts 支持 Custom Renderer API：暴露了自定义渲染API 1、Performance 重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。 编译模板的优化。 更高效的组件初始化。 update性能提高 1.3~2 倍。 SSR速度提高了 2~3 倍。 2、Tree shaking support 可以将无用模块“剪辑”，仅打包需要的（比如v-model,，用不到就不会打包）。 一个简单“HelloWorld”大小仅为：13.5kb，11.75kb，仅Composition API。 包含运行时完整功能：22.5kb，拥有更多的功能，却比Vue 2更迷你。 很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入 3、Composition API 与React Hooks 类似的东西，实现方式不同。 可与现有的 Options API一起使用 灵活的逻辑组合与复用 vue 3的响应式模块可以和其他框架搭配使用 混入(mixin) 将不再作为推荐使用， Composition API可以实现更灵活且无副作用的复用代码。 Composition API 文档地址 Composition API包含了六个主要API 4、Fragment Fragment翻译为：“碎片” 不再限于模板中的单个根节点 render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。 Just works &lt;Teleport&gt; &lt;Suspense&gt; Suspense翻译为：“悬念” 可在嵌套层级中等待嵌套的异步依赖项 支持async setup() 支持异步组件 虽然React 16引入了Suspense，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。 Vue 3 的&lt;Suspense&gt;更加轻量： 仅 5%应用能感知运行时的调度差异，综合考虑下，Vue3 的&lt;Suspense&gt; 没和 React 一样做运行调度处理 5、更好的TypeScript支持 Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示 JavaScript和TypeScript中的 API 是相同的。事实上，代码也基本相同 支持TSX class组件还会继续支持，但是需要引入vue-class-component@next，该模块目前还处在 alpha 阶段。 还有Vue 3 + TypeScript 插件正在开发，有类型检查，自动补全等功能 6、Custom Renderer API：自定义渲染器 API 正在进行NativeScript Vue集成 用户可以尝试WebGL自定义渲染器，与普通 Vue 应用程序一起使用（Vugel）。 意味着以后可以通过 vue， Dom 编程的方式来进行 webgl 编程 。 感兴趣可以看这里：Getting started vugel 剩余工作 全家桶插件组件过渡到vue3.+ 要点 新工具：vite（法语 “快”） 地址：https://github.com/vuejs/vite 一个简易的http服务器，无需webpack编译打包，根据请求的Vue文件，直接发回渲染，且支持热更新（非常快）","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"}]},{"title":"手写简易版vue，minivue的实现","slug":"Vue/手写简易版vue，minivue的实现","date":"2020-12-07T16:00:00.000Z","updated":"2021-03-07T04:36:29.326Z","comments":true,"path":"/posts/d3643a0f.html","link":"","permalink":"https://yangyfeng.github.io/posts/d3643a0f.html","excerpt":"基于vue2.* vue采取数据劫持，配合观察者模式，通过Object.defineProperty() 来劫持各个属性的setter和getter，在数据变动时，发布消息给依赖收集器dep，去通知观察者，做出对应的回调函数，去更新视图。（也就是在getter中收集依赖，在setter中通知依赖更新。 其实vue主要就是整合Observer，compile和watcher三者，通过Observer来监听 model数据变化表，通过compile来解析编译模板指令，最终利用Watcher搭起observer 和compile的通信桥梁，达到数据变化=&gt;视图变化，视图变化=&gt;数据变化的双向绑定效果。 下面来一张图↓ 这个流程图已经非常形象深刻的表达了vue的运行模式，当你理解了这个流程，再去看vue源码时就会容易很多了 声明一下，下面的代码只简单实现了vue里的 v-model（数据的双向绑定） v-bind/v-on v-text/v-html 没有实现虚拟dom，采用文档碎片（createDocumentFragment）代替 数据只劫持了Object，数组Array没有做处理 代码大致结构如下，初步定义了6个类","text":"基于vue2.* vue采取数据劫持，配合观察者模式，通过Object.defineProperty() 来劫持各个属性的setter和getter，在数据变动时，发布消息给依赖收集器dep，去通知观察者，做出对应的回调函数，去更新视图。（也就是在getter中收集依赖，在setter中通知依赖更新。 其实vue主要就是整合Observer，compile和watcher三者，通过Observer来监听 model数据变化表，通过compile来解析编译模板指令，最终利用Watcher搭起observer 和compile的通信桥梁，达到数据变化=&gt;视图变化，视图变化=&gt;数据变化的双向绑定效果。 下面来一张图↓ 这个流程图已经非常形象深刻的表达了vue的运行模式，当你理解了这个流程，再去看vue源码时就会容易很多了 声明一下，下面的代码只简单实现了vue里的 v-model（数据的双向绑定） v-bind/v-on v-text/v-html 没有实现虚拟dom，采用文档碎片（createDocumentFragment）代替 数据只劫持了Object，数组Array没有做处理 代码大致结构如下，初步定义了6个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300// 定义Vue类class Vue &#123; constructor(options) &#123; // 把数据对象挂载到实例上 this.$el = options.el; this.$data = options.data; this.$options = options; // 如果有需要编译的模板 if (this.$el) &#123; // 数据劫持 就是把对象的所有属性 改成get和set方法 new Observer(this.$data); // 用数据和元素进行编译 new Compiler(this.$el, this); // 3. 通过数据代理实现 主要给methods里的方法this直接访问data this.proxyData(this.$data); &#125; &#125; //用vm代理vm.$data proxyData(data)&#123; for(let key in data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return data[key]; &#125;, set(newVal)&#123; data[key] = newVal; &#125; &#125;) &#125; &#125;&#125; // 编译html模板class Compiler &#123; // vm就是vue对象 constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; if(this.el)&#123; // 如果该元素能获取到，我们开始编译 // 1.把真实的dom放到内存中fragment文档碎片 let fragment = this.node2fragment(this.el); // console.log(fragment); // 2.编译 =&gt; 提取想要的元素节点 v-model和文本节点&#123;&#123;&#125;&#125; this.compile(fragment); // 3.把编译好的fragment再放到页面里 this.el.appendChild(fragment); &#125; &#125; /* 一些辅助方法 */ isElementNode(node) &#123; return node.nodeType === 1; &#125; isDirective(name) &#123; // 判断是不是指令 return name.includes('v-'); &#125; isEventName(attrName)&#123; // 判断是否@开头 return attrName.startsWith('@'); &#125; isBindName(attrName)&#123; // 判断是否:开头 return attrName.startsWith(':'); &#125; /* 核心方法区 */ node2fragment(el)&#123; // 需要将el中的内容全部放到内存中 // 文档碎片 let fragment = document.createDocumentFragment(); let firstChild; while(firstChild = el.firstChild)&#123; fragment.appendChild(firstChild); &#125; return fragment; // 内存中的节点 &#125; compile(fragment)&#123; // 1.获取子节点 let childNodes = fragment.childNodes; // 2.递归循环编译 [...childNodes].forEach(node=&gt;&#123; if(this.isElementNode(node))&#123; this.compileElement(node); // 这里需要编译元素 this.compile(node); // 是元素节点，还需要继续深入的检查 &#125;else&#123; // 文本节点 // 这里需要编译文本 this.compileText(node); &#125; &#125;); &#125; compileElement(node)&#123; // 编译元素 // 带v-model v-html ... let attrs = node.attributes; // 取出当前节点的属性 // attrs是类数组，因此需要先转数组 [...attrs].forEach(attr=&gt;&#123; // console.log(attr); // type=\"text\" v-model=\"content\" v-on:click=\"handleclick\" @click=\"\"... let attrName = attr.name; // type v-model v-on:click @click if(this.isDirective(attrName))&#123; // 判断属性名字是不是包含v- // 取到对应的值放到节点中 let expr = attr.value; // content/变量 handleclick/方法名 // console.log(expr) let [, type] = attrName.split('-'); // model html on:click let [compileKey, detailStr] = type.split(':'); // 处理 on: bind: // node this.vm.$data expr CompileUtil[compileKey](node, this.vm, expr, detailStr); // 删除有指令的标签属性 v-text v-html等，普通的value等原生html标签不必删除 node.removeAttribute('v-' + type); &#125;else if(this.isEventName(attrName))&#123; // 如果是事件处理 @click='handleClick' let [, detailStr] = attrName.split('@'); CompileUtil['on'](node, this.vm, attr.value, detailStr); // 删除有指令的标签属性 node.removeAttribute('@' + detailStr); &#125;else if(this.isBindName(attrName))&#123; // 如果是:开头，动态绑定值 let [, detailStr] = attrName.split(':'); CompileUtil['bind'](node, this.vm, attr.value, detailStr); // 删除有指令的标签属性 node.removeAttribute(':' + detailStr); &#125; &#125;) &#125; compileText(node)&#123; // 编译文本 // 带&#123;&#123;&#125;&#125; let expr = node.textContent; // 取文本中的内容 let reg = /\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g; // &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; if(reg.test(expr))&#123; // node this.$data // console.log(expr); // &#123;&#123;content&#125;&#125; CompileUtil['text'](node, this.vm, expr); &#125; &#125;&#125; // 编译模版具体执行const CompileUtil = &#123; getVal(vm, expr)&#123; // 获取实例上对应的数据 expr = expr.split('.'); // [animal,dog]/[animal,cat] return expr.reduce((prev, next)=&gt;&#123; // vm.$data. return prev[next]; &#125;, vm.$data) &#125;, // 这里实现input输入值变化时 修改绑定的v-model对应的值 setVal(vm, expr, inputValue)&#123; // [animal,dog] let exprs = expr.split('.'), len = exprs.length; exprs.reduce((data,currentVal, idx)=&gt;&#123; if(idx===len-1)&#123; data[currentVal] = inputValue; &#125;else&#123; return data[currentVal] &#125; &#125;, vm.$data) &#125;, getTextVal(vm, expr)&#123; // 获取编译文本后的结果 return expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; // console.log(args); // [\"&#123;&#123;title&#125;&#125;\", \"title\", 0, \"&#123;&#123;title&#125;&#125;\"] // [\"&#123;&#123; animal.dog &#125;&#125;\", \" animal.dog \", 0, \"&#123;&#123; animal.dog &#125;&#125;-vs-&#123;&#123; animal.cat &#125;&#125;\"] return this.getVal(vm, args[1].trim()); &#125;); &#125;, text(node, vm, expr)&#123; // 文本处理 let updateFn = this.updater['textUpdater']; // &#123;&#123;content&#125;&#125; =&gt; \"welcome to animal world\" let value; if(expr.indexOf('&#123;&#123;')!==-1)&#123; // dom里直接写&#123;&#123;&#125;&#125;的时候 value = this.getTextVal(vm, expr); // &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; 对多个值进行监控 expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; new Watcher(vm, args[1].trim(), ()=&gt;&#123; // 如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容 updateFn &amp;&amp; updateFn(node, this.getTextVal(vm, expr)); &#125;) &#125;); &#125;else&#123; // v-text 的时候 value = this.getVal(vm, expr); new Watcher(vm, expr, (newVal)=&gt;&#123; // 当值变化后会调用cb 将新值传递过来 updateFn &amp;&amp; updateFn(node, newVal); &#125;); &#125; updateFn &amp;&amp; updateFn(node, value); &#125;, html(node, vm, expr) &#123; // let updateFn = this.updater['htmlUpdater']; updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)); &#125;, model(node, vm, expr)&#123; // 输入框处理 let updateFn = this.updater['modelUpdater']; // console.log(this.getVal(vm, expr)); // \"welcome to animal world\" // 这里应该加一个监控 数据变化了 应该调用这个watch的callback new Watcher(vm, expr, (newVal)=&gt;&#123; // 当值变化后会调用cb 将新值传递过来 updateFn &amp;&amp; updateFn(node, newVal); &#125;); // 视图 =&gt; 数据 =&gt; 视图 node.addEventListener('input', (e)=&gt;&#123; this.setVal(vm, expr, e.target.value); &#125;) updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)); &#125;, on(node, vm, expr, detailStr) &#123; let fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr]; node.addEventListener(detailStr, fn.bind(vm), false); &#125;, bind(node, vm, expr, detailStr)&#123; // v-bind:src='...' =&gt; href='...' node.setAttribute(detailStr, expr); &#125;, updater:&#123; // 文本更新 textUpdater(node, value)&#123; node.textContent = value; &#125;, // html更新 htmlUpdater(node, value)&#123; node.innerHTML = value; &#125;, // 输入框更新 modelUpdater(node, value)&#123; node.value = value; &#125; &#125;&#125; // 观察者class Observer&#123; constructor(data)&#123; this.observe(data); &#125; observe(data)&#123; // 要对data数据原有属性改成set和get的形式 if(!data || typeof data !== 'object')&#123; // 不是对象就不劫持了 return &#125; // 要劫持 先获取到data的key和value Object.keys(data).forEach(key=&gt;&#123; this.defineReactive(data, key, data[key]); // 劫持 this.observe(data[key]); // 深度递归劫持 &#125;) &#125; // 定义响应式 defineReactive(obj, key, value)&#123; let dep = new Dep(); // 在获取某个值的时候 Object.defineProperty(obj, key, &#123; enumerable: true, // 可枚举 configurable: true, // 可修改 get()&#123; // 当取值的时候 // 订阅数据变化时，往Dev中添加观察者 Dep.target &amp;&amp; dep.addSub(Dep.target); return value; &#125;, // 采用箭头函数在定义时绑定this的定义域 set: (newVal)=&gt;&#123; // 更改data里的属性值的时候 if(value === newVal) return; this.observe(newVal); // 如果设置新值是对象，劫持 value = newVal; // 通知watcher数据发生改变 dep.notify(); &#125; &#125;) &#125;&#125; // 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法class Watcher&#123; constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; // 先获取一下老的值 this.oldVal = this.getOldVal(); &#125; // 获取实例上对应的老值 getOldVal()&#123; // 在利用getValue获取数据调用getter()方法时先把当前观察者挂载 Dep.target = this; const oldVal = CompileUtil.getVal(this.vm, this.expr); // 挂载完毕需要注销，防止重复挂载 (数据一更新就会挂载) Dep.target = null; return oldVal; &#125; // 对外暴露的方法 通过回调函数更新数据 update()&#123; const newVal = CompileUtil.getVal(this.vm, this.expr); if(newVal !== this.oldVal)&#123; this.cb(newVal); // 对应watch的callback &#125; &#125;&#125; // Dep类存储watcher对象，并在数据变化时通知watcherclass Dep&#123; constructor(arg) &#123; // 订阅的数组 this.subs = [] &#125; addSub(watcher)&#123; this.subs.push(watcher); &#125; notify()&#123; // 数据变化时通知watcher更新 this.subs.forEach(w=&gt;w.update()); &#125;&#125; vue源码解析","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"}]},{"title":"如何使用JavaScript实现纯前端读取和导出excel文件","slug":"插件/如何使用JavaScript实现纯前端读取和导出excel文件","date":"2020-12-07T16:00:00.000Z","updated":"2021-03-07T04:41:03.924Z","comments":true,"path":"/posts/ce0a6a78.html","link":"","permalink":"https://yangyfeng.github.io/posts/ce0a6a78.html","excerpt":"1、js-xlsx 介绍由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。 官方github：https://github.com/SheetJS/js-xlsx 本文配套demo在线演示地址：http://demo.haoji.me/2017/02/08-js-xlsx/","text":"1、js-xlsx 介绍由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。 官方github：https://github.com/SheetJS/js-xlsx 本文配套demo在线演示地址：http://demo.haoji.me/2017/02/08-js-xlsx/ 1.1 兼容性 1.2. 如何使用dist目录下有很多个JS文件，一般情况下用xlsx.core.min.js就够了，xlsx.full.min.js则是包含了所有功能模块。 &lt;script type=&quot;text/javascript&quot; src=&quot;./js/xlsx.core.min.js&quot;&gt;&lt;/script&gt; 2、读取excel读取excel主要是通过XLSX.read(data, {type: type});方法来实现，返回一个叫WorkBook的对象，type主要取值如下： base64: 以base64方式读取； binary: BinaryString格式(byte n is data.charCodeAt(n)) string: UTF8编码的字符串； buffer: nodejs Buffer； array: Uint8Array，8位无符号数组； file: 文件的路径（仅nodejs下支持）； 2.1 获取workbook对象读取本地文件 12345678910// 读取本地excel文件function readWorkbookFromLocalFile(file, callback) &#123; var reader = new FileReader(); reader.onload = function(e) &#123; var data = e.target.result; var workbook = XLSX.read(data, &#123;type: 'binary'&#125;); if(callback) callback(workbook); &#125;; reader.readAsBinaryString(file);&#125; 读取网络文件 1234567891011121314// 从网络上读取某个excel文件，url必须同域，否则报错function readWorkbookFromRemoteFile(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = function(e) &#123; if(xhr.status == 200) &#123; var data = new Uint8Array(xhr.response) var workbook = XLSX.read(data, &#123;type: 'array'&#125;); if(callback) callback(workbook); &#125; &#125;; xhr.send();&#125; 读取workbook 1234567891011// 读取 excel文件function outputWorkbook(workbook) &#123; var sheetNames = workbook.SheetNames; // 工作表名称集合 sheetNames.forEach(name =&gt; &#123; var worksheet = workbook.Sheets[name]; // 只能通过工作表名称来获取指定工作表 for(var key in worksheet) &#123; // v是读取单元格的原始值 console.log(key, key[0] === '!' ? worksheet[key] : worksheet[key].v); &#125; &#125;);&#125; 根据!ref确定excel的范围，再根据!merges确定单元格合并（如果有），最后输出整个table，比较麻烦，幸运的是，插件自身已经写好工具类XLSX.utils给我们直接使用，无需我们自己遍历，工具类输出主要包括如下： 有些不常用，常用的主要是： XLSX.utils.sheet_to_csv：生成CSV格式 XLSX.utils.sheet_to_txt：生成纯文本格式 XLSX.utils.sheet_to_html：生成HTML格式 XLSX.utils.sheet_to_json：输出JSON格式 常用的主要是sheet_to_csv或者sheet_to_html，转csv的话会忽略格式、单元格合并等信息，所以复杂表格可能不适用。转html的话会保留单元格合并，但是生成的是代码，而不是，需要对表格进行一些定制时不太方便，所以具体还是要视情况来采用合适的工具类。 这里写一个采用转csv方式输出结果的简单示例，可点击这里查看在线DEMO： 1234567891011121314151617181920212223242526272829var csv = XLSX.utils.sheet_to_csv(worksheet); document.getElementById('result').innerHTML = csv2table(csv);&#125;// 将csv转换成简单的表格，会忽略单元格合并，在第一行和第一列追加类似excel的索引function csv2table(csv)&#123; var html = '&lt;table&gt;'; var rows = csv.split('\\n'); rows.pop(); // 最后一行没用的 rows.forEach(function(row, idx) &#123; var columns = row.split(','); columns.unshift(idx+1); // 添加行索引 if(idx == 0) &#123; // 添加列索引 html += '&lt;tr&gt;'; for(var i=0; i&lt;columns.length; i++) &#123; html += '&lt;th&gt;' + (i==0?'':String.fromCharCode(65+i-1)) + '&lt;/th&gt;'; &#125; html += '&lt;/tr&gt;'; &#125; html += '&lt;tr&gt;'; columns.forEach(function(column) &#123; html += '&lt;td&gt;'+column+'&lt;/td&gt;'; &#125;); html += '&lt;/tr&gt;'; &#125;); html += '&lt;/table&gt;'; return html;&#125; 导出excel导出分为2种，一种是基于现有excel修改，一种是全新生成，前者比较简单，我们这里着重讲后者。 自己手写代码生成 导出excel文件，主要是如何生成一个sheet，我们这里写一个最简单的csv转excel示例 123456789101112131415161718192021222324252627282930313233343536373839// csv转sheet对象function csv2sheet(csv) &#123; var sheet = &#123;&#125;; // 将要生成的sheet csv = csv.split('\\n'); csv.forEach(function(row, i) &#123; row = row.split(','); if(i == 0) sheet['!ref'] = 'A1:'+String.fromCharCode(65+row.length-1)+(csv.length-1); row.forEach(function(col, j) &#123; sheet[String.fromCharCode(65+j)+(i+1)] = &#123;v: col&#125;; &#125;); &#125;); return sheet;&#125;// 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载function sheet2blob(sheet, sheetName) &#123; sheetName = sheetName || 'sheet1'; var workbook = &#123; SheetNames: [sheetName], Sheets: &#123;&#125; &#125;; workbook.Sheets[sheetName] = sheet; // 生成excel的配置项 var wopts = &#123; bookType: 'xlsx', // 要生成的文件类型 bookSST: false, // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: 'binary' &#125;; var wbout = XLSX.write(workbook, wopts); var blob = new Blob([s2ab(wbout)], &#123;type:\"application/octet-stream\"&#125;); // 字符串转ArrayBuffer function s2ab(s) &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF; return buf; &#125; return blob;&#125; 拿到上面的blob对象就可以直接下载了，参考我之前在JS弹出下载对话框里面封装好的openDownloadDialog方法： 1234567891011121314151617181920212223/** * 通用的打开下载对话框方法，没有测试过具体兼容性 * @param url 下载地址，也可以是一个blob对象，必选 * @param saveName 保存文件名，可选 */function openDownloadDialog(url, saveName)&#123; if(typeof url == 'object' &amp;&amp; url instanceof Blob) &#123; url = URL.createObjectURL(url); // 创建blob地址 &#125; var aLink = document.createElement('a'); aLink.href = url; aLink.download = saveName || ''; // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效 var event; if(window.MouseEvent) event = new MouseEvent('click'); else &#123; event = document.createEvent('MouseEvents'); event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); &#125; aLink.dispatchEvent(event);&#125; 所以，最终下载实现如下： 123456// 传入csv，执行后就会弹出下载框function exportExcel(csv) &#123; var sheet = csv2sheet(csv); var blob = sheet2blob(sheet); openDownloadDialog(blob, '导出.xlsx')；&#125; 处理单元格合并 一般来说，前端生成excel而不是csv最主要目的都是为了解决csv不能实现单元格合并的问题，要不然直接导出csv文件就好了，何必引入几百kb的插件 123456789101112var aoa = [ ['主要信息', null, null, '其它信息'], // 特别注意合并的地方后面预留2个null ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()]];var sheet = XLSX.utils.aoa_to_sheet(aoa);sheet['!merges'] = [ // 设置A1-C1的单元格合并 &#123;s: &#123;r: 0, c: 0&#125;, e: &#123;r: 0, c: 2&#125;&#125;];openDownloadDialog(sheet2blob(sheet), '单元格合并示例.xlsx'); 需要注意的地方就是被合并的单元格要用null预留出位置，否则后面的内容（本例中是第四列其它信息）会被覆盖。 | 原文地址：https://www.cnblogs.com/liuxianan/p/js-excel.html","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://yangyfeng.github.io/blogpost/tags/Excel/"},{"name":"插件","slug":"插件","permalink":"https://yangyfeng.github.io/blogpost/tags/插件/"}]},{"title":"vue响应式原理源码剖析","slug":"Vue/vue响应式原理源码剖析","date":"2020-11-26T02:37:00.000Z","updated":"2021-03-07T04:37:11.548Z","comments":true,"path":"/posts/b0d42301.html","link":"","permalink":"https://yangyfeng.github.io/posts/b0d42301.html","excerpt":"vue2更新到vue3对数据的响应式，做了重大的调整。 先回顾下vue2的响应式怎么做的vue2对象响应式原理：Object.defineProperty() vue2数组响应式原理：覆盖可以修改数组7个方法，从数组原型中获取这7个方法，并覆盖为可以发送更新通知的函数实现","text":"vue2更新到vue3对数据的响应式，做了重大的调整。 先回顾下vue2的响应式怎么做的vue2对象响应式原理：Object.defineProperty() vue2数组响应式原理：覆盖可以修改数组7个方法，从数组原型中获取这7个方法，并覆盖为可以发送更新通知的函数实现 对象的属性劫持1234567891011121314151617181920// 具体定义指定的key拦截器function defineReactive(obj, key, val) &#123; // 递归遍历 observe(val) // val实际上是一个闭包 Object.defineProperty(obj, key, &#123; get() &#123; return val &#125;, set(newVal) &#123; if (newVal !== val) &#123; // val可能是对象 observe(newVal) notifyUpdate() val = newVal &#125; &#125; &#125;)&#125; 数组属性的劫持1234567891011121314// 修改数组的7个api的原型const originalProto = Array.prototypeconst arrayProto = Object.create(originalProto);['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].forEach( method =&gt; &#123; arrayProto[method] = function() &#123; // 做之前的事情 originalProto[method].apply(this, arguments) // 通知更新 notifyUpdate() &#125; &#125;) 数据响应123456789101112131415161718// 思想：递归遍历传入obj，定义每个属性的拦截function observe(obj) &#123; if (typeof obj !== 'object' || obj == null) &#123; return obj &#125; // 判断类型：如果是数组则替换它的原型 if (Array.isArray(obj)) &#123; Object.setPrototypeOf(obj, arrayProto) &#125; else &#123; const keys = Object.keys(obj) for (let index = 0; index &lt; keys.length; index++) &#123; const key = keys[index] // 对obj每个key执行拦截 defineReactive(obj, key, obj[key]) &#125; &#125;&#125; 跟新处理123456789101112131415function notifyUpdate() &#123; console.log('页面更新！')&#125;const data = &#123; foo: 'foo', bar: &#123; a: 1 &#125;, tua: [1, 2, 3] &#125;observe(data)// 1.普通更新// data.foo = 'foooooooo'// 2.嵌套属性更新// data.bar.a = 10// data.dong = 'lalala' // no ok// 3.赋值是对象// data.bar = &#123;a:10&#125;// 4.数组// data.tua.push(4) 以上方式会出现什么问题呢？ 需要响应化的数据较大，递归遍历性能不好、消耗较大 新增或删除属性无法监听 数组响应化需要额外实现 修改语法有限制 所以在vue3跟新做了更加优化方案 vue3的响应式原理的实现vue3响应式原理：利用Proxy对象对数据拦截 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// WeakMap 弱引用的方式缓存代理数据和原始数据const toProxy = new WeakMap() // 形如 obj: observedconst toRaw = new WeakMap() // 形如 observed: objfunction isObject(obj) &#123; return typeof obj === 'object' || obj === null&#125;function hasOwn(obj, key) &#123; return obj.hasOwnProperty(key)&#125;// 响应对象数据function reactive(obj) &#123; if (!isObject(obj)) &#123; return obj &#125; // 查找缓存 if (toProxy.has(obj)) &#123; return toProxy.get(obj) &#125; // 传入obj就是代理对象,此时不用反复代理 if (toRaw.has(obj)) &#123; return obj &#125; const observed = new Proxy(obj, &#123; get(target, key, receiver) &#123; // 访问 const res = Reflect.get(target, key, receiver) console.log(`获取$&#123;key&#125;: $&#123;res&#125;`) // 依赖收集 track(target, key) return isObject(res) ? reactive(res) : res &#125;, set(target, key, value, receiver) &#123; // 新增和更新 const hadKey = hasOwn(target, key) // ADD 或 SET const oldVal = target[key] const res = Reflect.set(target, key, value, receiver) if (!hadKey) &#123; console.log(`新增$&#123;key&#125;:$&#123;value&#125;`) trigger(target, 'ADD', key) &#125; else if (oldVal !== value) &#123; console.log(`设置$&#123;key&#125;:$&#123;value&#125;`) trigger(target, 'SET', key) &#125; return res &#125;, deleteProperty(target, key) &#123; // 删除 const hadKey = hasOwn(target, key) const res = Reflect.deleteProperty(target, key) // key存在并且删除成功 if (res &amp;&amp; hadKey) &#123; console.log(`删除$&#123;key&#125;:$&#123;res&#125;`) trigger(target, 'DELETE', key) &#125; return res &#125; &#125;) // 缓存 toProxy.set(obj, observed) toRaw.set(observed, obj) return observed&#125;// 每一个属性的响应回调方法const activeReativeEffectStack = []// 依赖收集执行// 基本结构&#123;target:&#123;key:[eff1，eff2]&#125;&#125;let targetsMap = new WeakMap()function track(target, key) &#123; // 从栈中获取响应函数 const effect = activeReativeEffectStack[activeReativeEffectStack.length - 1] if (effect) &#123; let depsMap = targetsMap.get(target) if (!depsMap) &#123; // 首次访问target depsMap = new Map() targetsMap.set(target, depsMap) &#125; // 存放key let deps = depsMap.get(key) if (!deps) &#123; deps = new Set() depsMap.set(key, deps) &#125; if (!deps.has(effect)) &#123; deps.add(effect) &#125; &#125;&#125;// 数据变化响应回调function effect(fn) &#123; // 1.异常处理 // 2.执行函数 // 3.放置到activeReativeEffectStack const rxEffect = function(...args) &#123; try &#123; activeReativeEffectStack.push(rxEffect) return fn(...args) // 执行函数触发依赖收集 &#125; finally &#123; activeReativeEffectStack.pop() &#125; &#125; rxEffect() // 默认立即执行 return rxEffect&#125;// 触发target.key对应响应函数function trigger(target, type, key) &#123; // 获取依赖表 const depsMap = targetsMap.get(target) if (depsMap) &#123; // 获取响应函数集合 const deps = depsMap.get(key) const effects = new Set() if (deps) &#123; // 执行所有响应函数 deps.forEach(effect =&gt; &#123; // effect() effects.add(effect) &#125;) &#125; // 数组新增或删除 if (type === 'ADD' || type === 'DELETE') &#123; if (Array.isArray(target)) &#123; const deps = depsMap.get('length') if (deps) &#123; deps.forEach(effect =&gt; &#123; effects.add(effect) &#125;) &#125; &#125; &#125; // 获取已存在的Dep Set执行 effects.forEach(effect =&gt; effect()) &#125;&#125;const data = &#123; foo: 'foo', bar: &#123; a: 1 &#125; &#125;const react = reactive(data)// 1.获取// react.foo // ok// 2.设置已存在属性// react.foo = 'foooooooo'// 3.设置不存在属性// react.baz = 'bazzzzzz'// 4.嵌套对象// react.bar.a = 10// 避免重复代理// console.log(reactive(data) === react) // true// reactive(react)effect(() =&gt; &#123; console.log('count发生了变化：', react.foo) // dom&#125;)react.foo = 'fooooooo' vue响应式数据更新的流程","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"}]},{"title":"什么是PWA","slug":"前端工程化/什么是PWA","date":"2020-11-18T01:40:00.000Z","updated":"2020-12-22T09:32:23.005Z","comments":true,"path":"/posts/138dbef8.html","link":"","permalink":"https://yangyfeng.github.io/posts/138dbef8.html","excerpt":"一、背景大家都知道Native app体验确实很好，下载到手机上之后入口也方便。它也有一些缺点: 开发成本高(ios和安卓) 软件上线需要审核 版本更新需要将新版本上传到不同的应用商店 想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下 而web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比Native app还是差一些，还有一些明显的缺点 手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签 没网络就没响应，不具备离线能力 不像APP一样能进行消息推送 那么什么是PWA呢？ 二、What’s PWA?PWA全称Progressive Web App，即渐进式WEB应用。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 解决了哪些问题？ 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。","text":"一、背景大家都知道Native app体验确实很好，下载到手机上之后入口也方便。它也有一些缺点: 开发成本高(ios和安卓) 软件上线需要审核 版本更新需要将新版本上传到不同的应用商店 想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下 而web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比Native app还是差一些，还有一些明显的缺点 手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签 没网络就没响应，不具备离线能力 不像APP一样能进行消息推送 那么什么是PWA呢？ 二、What’s PWA?PWA全称Progressive Web App，即渐进式WEB应用。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 解决了哪些问题？ 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。 三、PWA的实现3.1 Manifest实现添加至主屏幕index.html 1234567&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no\" /&gt; &lt;link rel=\"manifest\" href=\"manifest.json\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt; &lt;link rel=\"icon\" href=\"/e.png\" type=\"image/png\" /&gt;&lt;/head&gt; manifest.json 1234567891011121314151617181920212223242526272829&#123; \"name\": \"Minimal PWA\", // 必填 显示的插件名称 \"short_name\": \"PWA Demo\", // 可选 在APP launcher和新的tab页显示，如果没有设置，则使用name \"description\": \"The app that helps you understand PWA\", //用于描述应用 \"display\": \"standalone\", // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的 \"start_url\": \"/\", // 应用启动时的url \"theme_color\": \"#313131\", // 桌面图标的背景色 \"background_color\": \"#313131\", // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。 \"icons\": [ // 桌面图标，是一个数组 &#123; \"src\": \"icon/lowres.webp\", \"sizes\": \"48x48\", // 以空格分隔的图片尺寸 \"type\": \"image/webp\" // 帮助userAgent快速排除不支持的类型 &#125;, &#123; \"src\": \"icon/lowres\", \"sizes\": \"48x48\" &#125;, &#123; \"src\": \"icon/hd_hi.ico\", \"sizes\": \"72x72 96x96 128x128 256x256\" &#125;, &#123; \"src\": \"icon/hd_hi.svg\", \"sizes\": \"72x72\" &#125; ]&#125;` Manifest参考文档可以打开网站查看添加至主屏幕的动图。 如果用的是安卓手机，可以下载chrome浏览器自己操作看看 3.2 service worker实现离线缓存3.2.1 什么是service workerService Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。 Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。 最主要的特点 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost) 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求 单独的作用域范围，单独的运行环境和执行线程 不能操作页面 DOM。但可以通过事件机制来处理 事件驱动型服务线程 为什么要求网站必须是HTTPS的，大概是因为service worker权限太大能拦截所有页面的请求吧，如果http的网站安装service worker很容易被攻击 浏览器支持情况 浏览器支持情况详见： https://caniuse.com/#feat=serviceworkers 生命周期 当用户首次导航至 URL 时，服务器会返回响应的网页。 第1步:当你调用 register() 函数时， Service Worker 开始下载。 第2步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。 第3步:一旦 Service Worker 成功执行了，install 事件就会激活 第4步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用了！ chrome://serviceworker-internals 来了解当前浏览器中所有已安装Service Worker的详细情况 3.2.2 HTTP缓存与service worker缓存 HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。 service worker缓存 Service Workers 的强大在于它们拦截 HTTP 请求的能力进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ 3.2.3 实现离线缓存index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello Caching World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Image --&gt; &lt;img src=\"/images/hello.png\" /&gt; &lt;!-- JavaScript --&gt; &lt;script async src=\"/js/script.js\"&gt;&lt;/script&gt; &lt;script&gt; // 注册 service worker if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/service-worker.js', &#123;scope: '/'&#125;).then(function (registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;).catch(function (err) &#123; // 注册失败 :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注：Service Worker 的注册路径决定了其 scope 默认作用页面的范围。如果 service-worker.js 是在 /sw/ 页面路径下，这使得该 Service Worker 默认只会收到 页面/sw/ 路径下的 fetch 事件。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。 service-worker.js 1234567891011121314151617181920212223242526272829303132333435363738394041var cacheName = 'helloWorld'; // 缓存的名称 // install 事件，它发生在浏览器安装并注册 Service Worker 时 self.addEventListener('install', event =&gt; &#123; /* event.waitUtil 用于在安装成功之前执行一些预装逻辑 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率 安装成功后 ServiceWorker 状态会从 installing 变为 installed */ event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll([ // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 '/js/script.js', '/images/hello.png' ])) );&#125;); /**为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。*/self.addEventListener('fetch', function (event) &#123; event.respondWith( caches.match(event.request) .then(function (response) &#123; if (response) &#123; return response; &#125; var requestToCache = event.request.clone(); // return fetch(requestToCache).then( function (response) &#123; if (!response || response.status !== 200) &#123; return response; &#125; var responseToCache = response.clone(); caches.open(cacheName) .then(function (cache) &#123; cache.put(requestToCache, responseToCache); &#125;); return response; &#125;) );&#125;); 注：为什么用request.clone()和response.clone()需要这么做是因为request和response是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求Clone the request—a request is a stream and can only be consumed once. 3.2.4 调试相关chrome浏览器打开https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service worker离线缓存功能的网站，打开调试工具 介绍一个图中的1.和2. 勾选可以模拟网站离线情况，勾选后network会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示 当前service worker的scope。它能够拦截https://googlechrome.github.i…，同样也能够拦截https://googlechrome.github.i…/.html下的请求 调试面板具体代表的什么参看https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分 3.3 serice worker实现消息推送 步骤一、提示用户并获得他们的订阅详细信息 步骤二、将这些详细信息保存在服务器上 步骤三、在需要时发送任何消息 不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。 步骤一和步骤二 index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Progressive Times&lt;/title&gt; &lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var endpoint; var key; var authSecret; var vapidPublicKey = 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY'; // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用 function urlBase64ToUint8Array(base64String) &#123; const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/\\-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i &lt; rawData.length; ++i) &#123; outputArray[i] = rawData.charCodeAt(i); &#125; return outputArray; &#125; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('sw.js').then(function (registration) &#123; return registration.pushManager.getSubscription() .then(function (subscription) &#123; if (subscription) &#123; return; &#125; return registration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) &#125;) .then(function (subscription) &#123; var rawKey = subscription.getKey ? subscription.getKey('p256dh') : ''; key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : ''; var rawAuthSecret = subscription.getKey ? subscription.getKey('auth') : ''; authSecret = rawAuthSecret ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : ''; endpoint = subscription.endpoint; return fetch('./register', &#123; method: 'post', headers: new Headers(&#123; 'content-type': 'application/json' &#125;), body: JSON.stringify(&#123; endpoint: subscription.endpoint, key: key, authSecret: authSecret, &#125;), &#125;); &#125;); &#125;); &#125;).catch(function (err) &#123; // 注册失败 :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 步骤三 服务器发送消息给service worker app.js 123456789101112131415161718192021222324252627282930313233343536const webpush = require('web-push'); const express = require('express');var bodyParser = require('body-parser');const app = express();webpush.setVapidDetails( 'mailto:contact@deanhume.com', 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY', 'p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0');app.post('/register', function (req, res) &#123; var endpoint = req.body.endpoint; saveRegistrationDetails(endpoint, key, authSecret); const pushSubscription = &#123; endpoint: req.body.endpoint, keys: &#123; auth: req.body.authSecret, p256dh: req.body.key &#125; &#125;; var body = 'Thank you for registering'; var iconUrl = 'https://example.com/images/homescreen.png'; // 发送 Web 推送消息 webpush.sendNotification(pushSubscription, JSON.stringify(&#123; msg: body, url: 'http://localhost:3111/', icon: iconUrl &#125;)) .then(result =&gt; res.sendStatus(201)) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;);app.listen(3111, function () &#123; console.log('Web push app listening on port 3111!')&#125;); service worker监听push事件，将通知详情推送给用户 service-worker.js 12345678910111213self.addEventListener('push', function (event) &#123; // 检查服务端是否发来了任何有效载荷数据 var payload = event.data ? JSON.parse(event.data.text()) : 'no payload'; var title = 'Progressive Times'; event.waitUntil( // 使用提供的信息来显示 Web 推送通知 self.registration.showNotification(title, &#123; body: payload.msg, url: payload.url, icon: payload.icon &#125;) );&#125;); 扩展知识：service worker的更新 总结PWA的优势 可以将app的快捷方式放置到桌面上，全屏运行，与原生app无异 能够在各种网络环境下使用，包括网络差和断网条件下，不会显示undefind 推送消息的能力 其本质是一个网页，没有原生app的各种启动条件，快速响应用户指令 PWA存在的问题 支持率不高:现在ios手机端不支持pwa，IE也暂时不支持 Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低 各大厂商还未明确支持pwa 依赖的GCM服务在国内无法使用 微信小程序的竞争 尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。 service worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。 service worker实现消息推送，使用浏览器推送功能，吸引用户 渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。 参考文档 第一本 PWA 中文书 PWA 英文书 网站渐进式增强体验(PWA)改造：Service Worker 应用详解 Basic Service Worker Sample 【翻译】Service Worker 入门 Web App Manifest Service Workers: an Introduction The Offline Cookbook 微信小程序和PWA对比分析 Service Worker最佳实践 原文地址","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"}]},{"title":"⼤⼚⾯试章法","slug":"前端每日一题/⼤⼚⾯试章法","date":"2020-11-16T01:22:00.000Z","updated":"2020-12-22T09:30:59.600Z","comments":true,"path":"/posts/37eb3f8a.html","link":"","permalink":"https://yangyfeng.github.io/posts/37eb3f8a.html","excerpt":"简历2⻚以内，简历有点类似相亲的介绍，⼩时候拿过三好学 ⽣就别说了，就像别写你会html+css，别写你⽤vue做 过todolist⼀样 突出⾃⼰的技术亮点 别瞎写精通 markdown就好，别⽤word 突出亮点！ ⽬标公司天眼查，脉脉，知乎 如何描述做过的项⽬ 做过的明星项⽬ 项⽬技术栈和细节 源码深度 优化，性能，体验，极客 填坑 成⻓ ⾯试技巧合计 认识⾃⼰（市场） 阐述优势 谈判得来的 都是纯利润 hr细节(考勤，补贴，996，五险⼀⾦，补贴 ⼀个⾯试题的精讲 精讲面试题之前端⽂件上传1、原理概述 考察全栈思维，http协议 ，node⽂件处理 我⽤vue+element+nodejs来演示 基本答案 （10K）","text":"简历2⻚以内，简历有点类似相亲的介绍，⼩时候拿过三好学 ⽣就别说了，就像别写你会html+css，别写你⽤vue做 过todolist⼀样 突出⾃⼰的技术亮点 别瞎写精通 markdown就好，别⽤word 突出亮点！ ⽬标公司天眼查，脉脉，知乎 如何描述做过的项⽬ 做过的明星项⽬ 项⽬技术栈和细节 源码深度 优化，性能，体验，极客 填坑 成⻓ ⾯试技巧合计 认识⾃⼰（市场） 阐述优势 谈判得来的 都是纯利润 hr细节(考勤，补贴，996，五险⼀⾦，补贴 ⼀个⾯试题的精讲 精讲面试题之前端⽂件上传1、原理概述 考察全栈思维，http协议 ，node⽂件处理 我⽤vue+element+nodejs来演示 基本答案 （10K） 123formData&lt;input type=\"file\" @change=\"handleFileChange\" /&gt;&lt;el-button type=\"primary\" @click=\"handleUpload\"&gt;上传&lt;/el-button&gt; 12345678jshandleFileChange(e) &#123; const [file] = e.target.files; if (!file) return; form.append(\"filename\", this.container.file.name); form.append(\"file\", this.container.file); request(&#123;url: '/upload', 9 data: form&#125;) &#125;, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152nodeconst http = require(\"http\")const path = require('path')const Controller = require('./controller')const schedule = require('./schedule')const server = http.createServer()const UPLOAD_DIR = path.resolve(__dirname, \"..\", \"target\"); // ⼤⽂件存储⽬录// schedule.start(UPLOAD_DIR) const ctrl = new Controller(UPLOAD_DIR) server.on(\"request\", async (req, res) =&gt; &#123; res.setHeader(\"Access-Control-Allow\u0002Origin\", \"*\") res.setHeader(\"Access-Control-Allow\u0002Headers\", \"*\") if (req.method === \"OPTIONS\") &#123; res.status = 200 res.end() return &#125; if (req.method === \"POST\") &#123; if (req.url == '/upload') &#123; await ctrl.handleUpload(req, res) return &#125; &#125; &#125;) server.listen(3000, () =&gt; console.log(\"正在监听 3000 端⼝\")) Controller.js async handleUpload(req, res) &#123; const multipart = new multiparty.Form() multipart.parse(req, async (err, field, file) =&gt; &#123; if (err) &#123; console.log(err) return &#125; const [chunk] = file.file const [filename] = field.filename const filePath = path.resolve(this.UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;extractExt(filename)&#125;`) const chunkDir = path.resolve(this.UPLOAD_DIR, fileHash) // ⽂件存在直接返回 if (fse.existsSync(filePath)) &#123; res.end(\"file exist\") return &#125; if (!fse.existsSync(chunkDir)) &#123; await fse.mkdirs(chunkDir) &#125; await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`) res.end(\"received file chunk\") &#125;) &#125; 总结： formData httpserver fs⽂件处理 multiparty解析post数据 加分项-拖拽，粘贴 考点: 拖拽事件drop，clipboardData 123456789101112131415161718&lt;div class=\"drop-box\" id=\"drop-box\"&gt;// 拖拽box.addEventListener(\"drop\", function (e) &#123; e.preventDefault(); //取消浏览器默认拖拽效果 var fileList = e.dataTransfer.files; //获取拖拽中的⽂件对象 var len = fileList.length; //⽤来获取⽂件的⻓度（其实是获得⽂件数量） const [file] = e.target.files; if (!file) return; // ...上传 &#125;, false)// 粘贴 box.addEventListener('paste', function (event) &#123; var data = (event.clipboardData) // .... &#125;); ⼤⽂件上传(20K) blob.slice分⽚ 思想+语法 123456789101112const chunks = this.createFileChunk(this.container.file);createFileChunk(file, size = SIZE) &#123; // ⽣成⽂件块 const chunks = []; let cur = 0; while (cur &lt; file.size) &#123; chunks.push(&#123; file: file.slice(cur, cur + size) &#125;); cur += size; &#125; return chunks; &#125; 所有切⽚挨个发请求，然后merge 12345678910111213141516async handleMerge(req, res) &#123; const data = await resolvePost(req) const &#123; fileHash, filename, size &#125; = data const ext = extractExt(filename) const filePath = path.resolve(this.UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`) await this.mergeFileChunk(filePath, fileHash, size) res.end(JSON.stringify(&#123; code: 0, message: \"file merged success\" &#125;)) &#125; 断点续传+秒传 md5计算，缓存思想 ⽂件⽤md5计算⼀个指纹，上传之前，先问后端，这个⽂件的hash在不在，在的话就不⽤传了，就是所谓的断点续传，如果整个⽂件都存在了 就是秒传 123456789101112131415161718192021222324async handleVerify(req, res) &#123; const data = await resolvePost(req) const &#123; filename, hash &#125; = data const ext = extractExt(filename) const filePath = path.resolve(this.UPLOAD_DIR, `$&#123;hash&#125;$&#123;ext&#125;`) // ⽂件是否存在 let uploaded = false let uploadedList = [] if (fse.existsSync(filePath)) &#123; uploaded = true &#125; else &#123; // ⽂件没有完全上传完毕，但是可能存在部分切⽚上传完毕了 uploadedList = await getUploadedList(path.resolve(this.UPLOAD_DIR, hash)) &#125; res.end( JSON.stringify(&#123; uploaded, uploadedList // 过滤诡异的隐藏⽂件 &#125;) ) &#125; 计算hash优化(25+) 1、web-worker ⼤⽂件的md5太慢了,启⽤webworker计算 123456789101112131415161718192021222324252627282930313233343536373839// web-worker self.importScripts('spark-md5.min.js') self.onmessage = e =&gt; &#123; // 接受主线程的通知 const &#123; chunks &#125; = e.data const spark = new self.SparkMD5.ArrayBuffer() let progress = 0 let count = 0 const loadNext = index =&gt; &#123; const reader = new FileReader() reader.readAsArrayBuffer(chunks[index].file) reader.onload = e =&gt; &#123; // 累加器 不能依赖index， count++ // 增量计算md5 spark.append(e.target.result) if (count === chunks.length) &#123; // 通知主线程，计算结束 self.postMessage(&#123; progress: 100, hash: spark.end() &#125;) &#125; else &#123; // 每个区块计算结束，通知进度即可 progress += 100 / chunks.length self.postMessage(&#123; progress &#125;) // 计算下⼀个 loadNext(count) &#125; &#125; &#125; // 启动 loadNext(0) &#125; 1、time-slice(30+) react fifiber架构学习，利⽤浏览器空闲时间 requestIdleCallback 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960requestIdelCallback(myNonEssentialWork); function myNonEssentialWork(deadline) &#123; // deadline.timeRemaining()可以获取到当前帧剩余时间 // 当前帧还有时间 并且任务队列不为空 while (deadline.timeRemaining() &gt; 0 &amp;&amp; tasks.length &gt; 0) &#123; doWorkIfNeeded(); &#125; if (tasks.length &gt; 0) &#123; requestIdleCallback(myNonEssentialWork); &#125; &#125; async calculateHashIdle(chunks) &#123; return new Promise(resolve =&gt; &#123; const spark = new SparkMD5.ArrayBuffer(); let count = 0; // 根据⽂件内容追加计算 const appendToSpark = async file =&gt; &#123; return new Promise(resolve =&gt; &#123; const reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onload = e =&gt; &#123; spark.append(e.target.result); resolve(); &#125;; &#125;); &#125;; const workLoop = async deadline =&gt; &#123; // 有任务，并且当前帧还没结束 while (count &lt; chunks.length &amp;&amp; deadline.timeRemaining() &gt; 1) &#123; await appendToSpark(chunks[count].file); count++; // 没有了 计算完毕 if (count &lt; chunks.length) &#123; // 计算中 this.hashProgress = Number( ((100 * count) / chunks.length).toFixed(2) ); console.log(this.hashProgress) &#125; else &#123; // 计算完毕 this.hashProgress = 100; resolve(spark.end()); &#125; &#125; window.requestIdleCallback(workLoop); &#125;; &#125;) &#125; 3、算法优化 精讲面试题之请求并发数控制和重试 1、基本实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576async sendRequest(forms, max = 4) &#123; return new Promise(resolve =&gt; &#123; const len = forms.length; let idx = 0; let counter = 0; const start = async () =&gt; &#123; // 有请求，有通道 while (idx &lt; len &amp;&amp; max &gt; 0) &#123; max--; // 占⽤通道 console.log(idx, \"start\"); const form = forms[idx].form; const index = forms[idx].index; + idx++ request(&#123; url: '/upload', data: form, onProgress: this.createProgresshandler(this.chunks[ index]), requestList: this.requestList &#125;).then(() =&gt; &#123; max++; // 释放通道 counter++; if (counter === len) &#123; resolve(); &#125; else &#123; start(); &#125; &#125;); &#125; &#125; start(); &#125;); &#125; async uploadChunks(uploadedList = []) &#123; // 这⾥⼀起上传，碰⻅⼤⽂件就是灾难 // 没被hash计算打到，被⼀次性的tcp链接把浏览器稿挂了 // 异步并发控制策略，我记得这个也是头条⼀个⾯试题 // ⽐如并发量控制成4 const list = this.chunks.filter(chunk =&gt; uploadedList.indexOf(chunk.hash) == -1) .map((&#123; chunk, hash, index &#125;, i) =&gt; &#123; const form = new FormData(); form.append(\"chunk\", chunk); form.append(\"hash\", hash); form.append(\"filename\", this.container.file.name); form.append(\"fileHash\", this.container.hash); return &#123; form, index &#125;; &#125;).map((&#123; form, index &#125;) =&gt; request(&#123; url: \"/upload\", data: form, onProgress: this.createProgresshandler(this.chunks[index]), requestList: this.requestList &#125;) ); // 直接全量并发 await Promise.all(list); // 控制并发 const ret = await this.sendRequest(list, 4) if (uploadedList.length + list.length === this.chunks.length) &#123; // 上传和已经存在之和 等于全部的再合并 await this.mergeRequest(); &#125; &#125; 2、慢启动策略 TCP拥塞控制的问题 其实就是根据当前⽹络情况，动态 调整切⽚的⼤⼩ chunk中带上size值，不过进度条数量不确定了，修改createFileChunk， 请求加上时间统计) ⽐如我们理想是30秒传递⼀个 初始⼤⼩定为1M，如果上传花了10秒，那下⼀个区块⼤⼩变成3M 如果上传花了60秒，那下⼀个区块⼤⼩变成500KB以此类推 并发+慢启动的逻辑有些复杂，我⾃⼰还没绕明⽩，囧所以先⼀次只传⼀个切⽚，来演示这个逻辑，新建⼀个handleUpload1函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950async handleUpload1() &#123; // @todo数据缩放的⽐率 可以更平缓 // @todo 并发+慢启动 // 慢启动上传逻辑 const file = this.container.file if (!file) return; this.status = Status.uploading; const fileSize = file.size let offset = 1024 * 1024 let cur = 0 let count = 0 this.container.hash = await this.calculateHashSample(); while (cur &lt; fileSize) &#123; // 切割offfset⼤⼩ const chunk = file.slice(cur, cur + offset) cur += offset const chunkName = this.container.hash + \"-\" + count; const form = new FormData(); form.append(\"chunk\", chunk); form.append(\"hash\", chunkName); form.append(\"filename\", file.name); form.append(\"fileHash\", this.container.hash); form.append(\"size\", chunk.size); let start = new Date().getTime() await request(&#123; url: '/upload', data: form &#125;) const now = new Date().getTime() const time = ((now - start) / 1000).toFixed(4) let rate = time / 30 // 速率有最⼤2和最⼩0.5 if (rate &lt; 0.5) rate = 0.5 if (rate &gt; 2) rate = 2 // 新的切⽚⼤⼩等⽐变化 console.log(`切⽚$&#123;count&#125;⼤⼩是$&#123;this.format(offset)&#125;,耗时$&#123;time&#125;秒，是30秒的$&#123;rate&#125;倍，修正⼤⼩为$&#123;this.format(offset/rate)&#125;`) // 动态调整offset offset = parseInt(offset / rate) // if(time) count++ &#125; &#125; //切⽚0⼤⼩是1024.00KB,耗时13.2770秒，是30秒的0.5倍，修正⼤⼩为2.00MB//切⽚1⼤⼩是2.00MB,耗时25.4130秒，是30秒的0.8471倍，修正⼤⼩为2.36MB//切⽚2⼤⼩是2.36MB,耗时14.1260秒，是30秒的0.5倍，修正⼤⼩为4.72MB 3、碎⽚清理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 为了⽅便测试，我改成每5秒扫⼀次， 过期1钟的删除做演示 const fse = require('fs-extra') const path = require('path') const schedule = require('node\u0002schedule') // 空⽬录删除 function remove(file, stats) &#123; const now = new Date().getTime() const offset = now - stats.ctimeMs if (offset &gt; 1000 * 60) &#123; // ⼤于60秒的碎⽚ console.log(file, '过期了，浪费空间的玩意，删除') fse.unlinkSync(file) &#125; &#125; async function scan(dir, callback) &#123; const files = fse.readdirSync(dir) files.forEach(filename =&gt; &#123; const fileDir = path.resolve(dir, filename) const stats = fse.statSync(fileDir) if (stats.isDirectory()) &#123; return scan(fileDir, remove) &#125; if (callback) &#123; callback(fileDir, stats) &#125; &#125;) &#125; let start = function (UPLOAD_DIR) &#123; // 每5秒 schedule.scheduleJob(\"*/5 * * * * *\", function () &#123; console.log('开始扫描') scan(UPLOAD_DIR) &#125;) &#125; exports.start = start 开始扫描/upload/target/625c.../625c...-0 过期了，删除/upload/target/625c.../625c...-1 过期了，删除/upload/target/625c.../625c...-10 过期了，删除/upload/target/625c.../625c...-11 过期了，删除/upload/target/625c.../625c...-12 过期了，删除 面试题之后续问题 requestIdleCallback兼容性，如何⾃⼰实现⼀个react也是⾃⼰写的调度逻辑,React⾃⼰实现的requestIdleCallback(https://www.dazhuanlan.com/2019/10/20/5dabc56a750fd/) 并发+慢启动配合 抽样hash+全量哈希+时间切⽚配合 ⼤⽂件切⽚下载 websocket推送进度 ⽂件碎⽚分机器存储以及⽂件碎⽚备份","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"NodeJs中数据库的使用","slug":"Node/NodeJs中数据库的使用","date":"2020-09-09T10:29:00.000Z","updated":"2021-03-07T04:34:17.740Z","comments":true,"path":"/posts/e4aa7462.html","link":"","permalink":"https://yangyfeng.github.io/posts/e4aa7462.html","excerpt":"1.Node.js 连接 MySQLcnpm install mysql 连接mysql: 123456789101112131415var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : '123456', database : 'test'&#125;);connection.connect(); connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;); 数据库连接参数说明 1234567891011121314151617181920212223242526272829303132333435363738参数 描述host 主机地址 （默认：localhost）user 用户名password 密码port 端口号 （默认：3306）database 数据库名charset 连接字符集（默认：'UTF8_GENERAL_CI'，注意字符集的字母都要大写）localAddress 此IP用于TCP连接（可选）socketPath 连接到unix域路径，当使用 host 和 port 时会被忽略timezone 时区（默认：'local'）connectTimeout 连接超时（默认：不限制；单位：毫秒）stringifyObjects 是否序列化对象typeCast 是否将列值转化为本地JavaScript类型值 （默认：true）queryFormat 自定义query语句格式化方法supportBigNumbers 数据库支持bigint或decimal类型列时，需要设此option为true （默认：false）bigNumberStrings supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false）dateStrings 强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false）debug 开启调试（默认：false）multipleStatements 是否许一个query中有多个MySQL语句 （默认：false）flags 用于修改连接标志ssl 使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件","text":"1.Node.js 连接 MySQLcnpm install mysql 连接mysql: 123456789101112131415var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : '123456', database : 'test'&#125;);connection.connect(); connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;); 数据库连接参数说明 1234567891011121314151617181920212223242526272829303132333435363738参数 描述host 主机地址 （默认：localhost）user 用户名password 密码port 端口号 （默认：3306）database 数据库名charset 连接字符集（默认：'UTF8_GENERAL_CI'，注意字符集的字母都要大写）localAddress 此IP用于TCP连接（可选）socketPath 连接到unix域路径，当使用 host 和 port 时会被忽略timezone 时区（默认：'local'）connectTimeout 连接超时（默认：不限制；单位：毫秒）stringifyObjects 是否序列化对象typeCast 是否将列值转化为本地JavaScript类型值 （默认：true）queryFormat 自定义query语句格式化方法supportBigNumbers 数据库支持bigint或decimal类型列时，需要设此option为true （默认：false）bigNumberStrings supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false）dateStrings 强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false）debug 开启调试（默认：false）multipleStatements 是否许一个query中有多个MySQL语句 （默认：false）flags 用于修改连接标志ssl 使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件 2.Node.js 连接 MongoDB： MongoDB是一种文档导向数据库管理系统，由C++撰写而成。MongoDB 教程。 安装驱动 1$ cnpm install mongodb 增删改查 要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。如果数据库不存在，MongoDB 将创建数据库并建立连接。 创建连接 12345678var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/mydb\"; MongoClient.connect(url, function(err, db) &#123; if (err) throw err; console.log(\"数据库已创建!\"); db.close();&#125;); 创建集合 我们可以使用 createCollection() 方法来创建集合： 创建集合 123456789101112var MongoClient = require('mongodb').MongoClient;var url = 'mongodb://localhost:27017/mydb';MongoClient.connect(url, function (err, db) &#123; if (err) throw err; console.log('数据库已创建'); var dbase = db.db(\"mydb\"); dbase.createCollection('runoob', function (err, res) &#123; if (err) throw err; console.log(\"创建集合!\"); db.close(); &#125;);&#125;); 数据库操作( CURD ) 与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 插入数据 以下实例我们连接数据库 runoob 的 site 表，并插入两条数据： 插入数据 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; # 数据库为 runoob var insertData = function(db, callback) &#123; //连接到表 site var collection = db.collection('site'); //插入数据 var data = [&#123;\"name\":\"菜鸟教程\",\"url\":\"www.runoob.com\"&#125;,&#123;\"name\":\"菜鸟工具\",\"url\":\"c.runoob.com\"&#125;]; collection.insert(data, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); insertData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行以下命令输出就结果为： 12345678910111213$ node test.js //连接成功！&#123; result: &#123; ok: 1, n: 2 &#125;, ops: [ &#123; name: '菜鸟教程', url: 'www.runoob.com', _id: 58c25e13a08de70d3b9d4116 &#125;, &#123; name: '菜鸟工具', url: 'c.runoob.com', _id: 58c25e13a08de70d3b9d4117 &#125; ], insertedCount: 2, insertedIds: [58c25e13a08de70d3b9d4116, 58c25e13a08de70d3b9d4117]&#125; 从输出结果来看，数据已插入成功。 我们也可以打开 MongoDB 的客户端查看数据，如： 123456789101112show dbsadmin 0.000GBlocal 0.000GBrunoob 0.000GB # 自动创建了 runoob 数据库show tablessite # 自动创建了 site 集合（数据表）db.site.find() # 查看集合中的数据&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c8\"), \"name\" : \"菜鸟教程\", \"url\" : \"www.runoob.com\" &#125;&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c9\"), \"name\" : \"菜鸟工具\", \"url\" : \"c.runoob.com\" &#125; 查询数据 以下实例检索 name 为 “菜鸟教程” 的实例： 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; var selectData = function(db, callback) &#123; //连接到表 var collection = db.collection('site'); //查询数据 var whereStr = &#123;\"name\":'菜鸟教程'&#125;; collection.find(whereStr).toArray(function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); selectData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行以下命令输出就结果为： 连接成功！ 123[ &#123; _id: 58c25f300cd56e0d7ddfc0c8, name: '菜鸟教程', url: 'www.runoob.com' &#125; ] 更新数据 我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 https://www.runoob.com： 1234567891011121314151617181920212223242526var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; var updateData = function(db, callback) &#123; //连接到表 var collection = db.collection('site'); //更新数据 var whereStr = &#123;\"name\":'菜鸟教程'&#125;; var updateStr = &#123;$set: &#123; \"url\" : \"https://www.runoob.com\" &#125;&#125;; collection.update(whereStr,updateStr, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); updateData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行成功后，进入 mongo 管理工具查看数据已修改： 123db.site.find()&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c8\"), \"name\" : \"菜鸟教程\", \"url\" : \"https://www.runoob.com\" &#125;&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c9\"), \"name\" : \"菜鸟工具\", \"url\" : \"c.runoob.com\" &#125; 删除数据 以下实例将 name 为 “菜鸟工具” 的数据删除 : 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; var delData = function(db, callback) &#123; //连接到表 var collection = db.collection('site'); //删除数据 var whereStr = &#123;\"name\":'菜鸟工具'&#125;; collection.remove(whereStr, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); delData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行成功后，进入 mongo 管理工具查看数据已删除： 12db.site.find()&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c8\"), \"name\" : \"菜鸟教程\", \"url\" : \"https://www.runoob.com\" &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://yangyfeng.github.io/blogpost/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://yangyfeng.github.io/blogpost/tags/Node/"}]},{"title":"http协议","slug":"Http/http协议","date":"2020-09-09T10:20:00.000Z","updated":"2021-03-07T04:33:49.154Z","comments":true,"path":"/posts/6a5e2f06.html","link":"","permalink":"https://yangyfeng.github.io/posts/6a5e2f06.html","excerpt":"","text":"HTTP 简介： HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写 HTTP是因特网上应用最为广泛的一种网络传输协议，是一个无状态的请求/响应协议 HTTP是基于客户端/服务端（C/S）的架构模型 HTTP是一个基于TCP/IP通信协议来传递数据 HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS默认HTTP的端口号为80，HTTPS的端口号为443 HTTP的请求响应模型： HTTP协议永远都是客户端发起请求，服务器回送响应 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系 HTTP 工作原理： HTTP协议工作于客户端-服务端架构上。浏览器作为Http客户端通过地址栏 Url将请求发送到Http服务端即Web服务器上。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 工作流程： 一次完整的Http事务：http://blog.csdn.net/yipiankongbai/article/details/25029183 一次HTTP操作称为一个事务，其工作过程可分为六步： 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 域名解析 -&gt; 三次握手 -&gt; 建立连接 -&gt; 发送请求 -&gt; 响应请求 -&gt; 接收响应 任何一步发生错误，都会将错误信息返回到客户端 1）域名解析 ：将网站名称转变成IP地址：localhost–&gt;127.0.0.1 2）发起TCP的3次握手 ： 客户端发出一个SYN消息 -》 服务器使用SYN+ACK应答表示接收到了这个消息 -》 客户机再以ACK消息响应 -》 建立起可靠的TCP连接，数据传递 3）客户端与服务端建立连接 4）客户端发送请求给服务端，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 5）服务端接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 6）客户端接收服务端所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 HTTP请求方法： HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP 响应头信息： HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 HTTP状态码： 下面是常见的HTTP状态码： 200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP content-type：http://www.runoob.com/http/http-content-type.html","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://yangyfeng.github.io/blogpost/tags/Http/"}]},{"title":"TCP3次握手","slug":"Http/TCP3次握手","date":"2020-09-09T10:17:00.000Z","updated":"2021-03-07T04:33:56.752Z","comments":true,"path":"/posts/6a5e2f06.html","link":"","permalink":"https://yangyfeng.github.io/posts/6a5e2f06.html","excerpt":"","text":"什么是http?为了提供可靠的传送，TCP在发送新的数据之前，以特定的顺序将数据包的序号，并需要这些包传送给目标机之后的确认消息。TCP总是用来发送大批量的数据。当应用程序在收到数据后要做出确认时也要用到TCP。 过程 第一次 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://yangyfeng.github.io/blogpost/tags/Http/"}]},{"title":"create-react-app(注意事项)","slug":"React/create-react-app(注意事项)","date":"2020-09-09T10:01:00.000Z","updated":"2021-03-07T04:39:25.191Z","comments":true,"path":"/posts/6a5e2f06.html","link":"","permalink":"https://yangyfeng.github.io/posts/6a5e2f06.html","excerpt":"React.createClass is not a function在React16以上，已经摒弃React.createClass()这个方法 取而代之的是1class Welcome extends React.Component&#123;&#125; 配置webpack 前置条件(precondition) Creating a New Application 安装yarn 1npm install yarn -g 安装依赖 1yarn install 显示webpack配置 1npm run eject 添加alias 可以根据项目自行配置 12345678alias: &#123; 'react-native': 'react-native-web', 'src':path.join(__dirname, '..', 'src'), 'language':path.join(__dirname, '..', 'src/language'), 'router':path.join(__dirname, '..', 'src/router'), 'Modebase':path.join(__dirname, '..', 'src/Modebase'), 'containers':path.join(__dirname, '..', 'src/containers') &#125; 添加cssnext(postcs)一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。","text":"React.createClass is not a function在React16以上，已经摒弃React.createClass()这个方法 取而代之的是1class Welcome extends React.Component&#123;&#125; 配置webpack 前置条件(precondition) Creating a New Application 安装yarn 1npm install yarn -g 安装依赖 1yarn install 显示webpack配置 1npm run eject 添加alias 可以根据项目自行配置 12345678alias: &#123; 'react-native': 'react-native-web', 'src':path.join(__dirname, '..', 'src'), 'language':path.join(__dirname, '..', 'src/language'), 'router':path.join(__dirname, '..', 'src/router'), 'Modebase':path.join(__dirname, '..', 'src/Modebase'), 'containers':path.join(__dirname, '..', 'src/containers') &#125; 添加cssnext(postcs)一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。 修改webpack.config.dev.js添加postcss插件 1234567891011&#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), require('postcss-cssnext', &#123; browsers: ['last 2 version'] &#125; ], &#125; &#125; webPack按需加载 添加react-router4 使用react-router-dom，参考初探 React Router 4.0 1yarn add react-router-dom 在react-router4中进行代码拆分 react-router升级到4后，便没有了getComponent这个参数。所以我们得换种方式，react-router4官方示例也提供了code splitting的方法，利用webpack结合bundle-loader，它是在require.ensure基础上封装的，更友好的实现异步加载过程。 添加Bundle.js组件 1234567891011121314151617export default class Bundle extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; mod: null &#125;; &#125; load = props =&gt; &#123; this.setState(&#123; mod: null &#125;); props.load(mod =&gt; &#123; this.setState(&#123; mod: mod ? mod : null &#125;); &#125;); &#125; componentWillMount() &#123; this.load(this.props); &#125; render() &#123; return this.state.mod ? this.props.children(this.state.mod) : null &#125; &#125; 使用require.ensure()来进行模块的异步加载 1&lt;Bundle load=&#123;(cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(require('containers/Buttons/containers').default); &#125;,'Buttons'); &#125;&#125;&gt; &#123;(Buttons) =&gt; &lt;Buttons &#123;...props&#125;/&gt;&#125; &lt;/Bundle&gt; webPack提取公共模块 首先把入口处改写为下面这样，把公共的方法提取出来 123456789entry: &#123; app:[ require.resolve('./polyfills'), paths.appIndexJs, require.resolve('react-error-overlay'), require.resolve('react-dev-utils/webpackHotDevClient') ], vendor: ['react', 'react-dom', 'react-router','react-router-dom', 'mobx', 'mobx-react'] &#125; 提取公共模块 1new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor.[hash:8].js' &#125;) Webpack DLL 用法 Dll使用方法其实挺简单的。网上也有很多例子。 我遇到一些坑这里和大家说明一下 首先在主目录下面新建 webpack.dll.dev.js 1234567891011121314const webpack = require('webpack'); const path = require('path'); module.exports = &#123; entry: &#123; vendor: [path.join(__dirname, 'src', 'vendor.js')], &#125;, output: &#123; path: path.join(__dirname, 'dll'), filename: '[name].js', library: '[name]', &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, 'dll', '[name]-manifest.json'), filename: '[name].js', name: '[name]', &#125;), ] &#125;; 这个Webpack文件主要的功能是在根目录生成dll文件夹。里面包含有vendor.js（index.html需要添加的js）和vendor-manifest.json （DllPlugin生成的json文件） 在主webpack文件里面通过DllReferencePlugin插件引用 然后再package.json里面添加 webpack –config webpack.dll.dev.js 然后在主webpack文件添加如下代码 1const manifest = require('../dll/vendor-manifest.json'); plugins: [ new webpack.DllReferencePlugin(&#123; manifest &#125;) ] 下面就是dll比较坑的地方，如何在index.html中引入verdor.js呢。 首先我们思考直接在public底下的index.html中直接引用，这个dllplugin的包并不会被打进内存里，需要指定一个static目录 解决办法使用AddAssetHtmlPlugin 在htmlwebpack后插入一个AddAssetHtmlPlugin插件，用于将vendor插入打包后的页面 1new AddAssetHtmlPlugin(&#123; filepath: require.resolve('../dll/vendor.js'), includeSourcemap: false &#125;) 节省了近30S!!! 使用UglifyJsPlugin压缩代码 1new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125; &#125;) 添加ANTD全局组件和css 修改webpack","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Create-React-App","slug":"Create-React-App","permalink":"https://yangyfeng.github.io/blogpost/tags/Create-React-App/"},{"name":"React","slug":"React","permalink":"https://yangyfeng.github.io/blogpost/tags/React/"}]},{"title":"React 脚手架工具（create-react-app）","slug":"React/React 脚手架工具（crate-react-app）","date":"2020-09-09T09:55:00.000Z","updated":"2021-03-07T04:39:32.269Z","comments":true,"path":"/posts/a2043eea.html","link":"","permalink":"https://yangyfeng.github.io/posts/a2043eea.html","excerpt":"介绍在开发react应用时，应该没有人用传统的方法引入react的源文件(js)，然后在html编辑吧。 大家都是用webpack + es6来结合react开发前端应用。 这个时候，我们可以手动使用npm来安装各种插件，来从头到尾自己搭建环境。 比如： 12345npm install react react-dom --savenpm install babel babel-loader babel-core babel-preset-es2015 babel-preset-react --savenpm install babel webpack webpack-dev-server -g","text":"介绍在开发react应用时，应该没有人用传统的方法引入react的源文件(js)，然后在html编辑吧。 大家都是用webpack + es6来结合react开发前端应用。 这个时候，我们可以手动使用npm来安装各种插件，来从头到尾自己搭建环境。 比如： 12345npm install react react-dom --savenpm install babel babel-loader babel-core babel-preset-es2015 babel-preset-react --savenpm install babel webpack webpack-dev-server -g 类似这样的脚手架，我扫了网络上比较多人用和关注的，一共发现了三个，它们分别是： 123react-boilerplatereact-redux-starter-kitcreate-react-app(facebook官方开发) 特点安装和使用(默认监听3000端口) 1234567npm install -g create-react-appcreate-react-app my-appcd my-app/npm start 源码结构简单清晰 如果你使用过webpack-dev-server或webpack搭建过开发环境，你就会发现，create-react-app的开发环境也有类似webpack-dev-server的–inline –hot自动刷新的功能。 翻看了一下源码，没有找到webpack.config.js文件，如果有使用webpack就应该有这个文件，好奇怪。 看了一下node_modules目录，也没找到webpack相关的东西。 package.json package.json中也没有webpack相关的东西,但是在react-scripts中依赖了webpack 线上编译命令 编译出来的文件很小，且文件名还带hash值，方便我们做cache，而且它还提供一个服务器，让我们在本地也能看到线上生产环境类似的效果 1npm run build 运行下面两条命令，可以查看线上生产环境的运行效果 123npm install -g pushstate-serverpushstate-server build api开发 CORS问题:毕竟端口不同，而线上环境却没有这个问题，因为你都控制线上环境的react应用和api应用，跑在同一个端口上。 按照以往思路，解决的方法可能是用环境变量，比如 const apiBaseUrl = process.env.NODE_ENV === ‘development’ ? ‘localhost:3001’ : ‘/‘ 但是这样搞起来，还是有些复杂，然而，create-react-app提供了一个超级简单的方法，只需要在package.json文件中，加一个配置项就可以了。 “proxy”: “http://localhost:3001/&quot;, 执行npm run eject 暴露配置文件等 报错解决方案： 1先执行git add . 和 git commit -m \"init\" 在执行 npm run eject","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Create-React-App","slug":"Create-React-App","permalink":"https://yangyfeng.github.io/blogpost/tags/Create-React-App/"},{"name":"React","slug":"React","permalink":"https://yangyfeng.github.io/blogpost/tags/React/"}]},{"title":"Devops是什么","slug":"开发工具/devops是什么","date":"2020-09-09T09:33:00.000Z","updated":"2021-03-07T04:40:14.027Z","comments":true,"path":"/posts/cfdabafc.html","link":"","permalink":"https://yangyfeng.github.io/posts/cfdabafc.html","excerpt":"DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。","text":"DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 传统的软件组织将开发、IT 运营和质量保障设为各自分离的部门，在这种环境下如何采用新的开发方法（例如敏捷软件开发），是一个重要的课题。按照从前的工作方式，开发和部署，不需要 IT 支持或者 QA 深入的跨部门的支持；而现在却需要极其紧密的多部门协作。而 DevOps 考虑的还不止是软件部署，它是一套针对这几个部门间沟通与协作问题的流程和方法。 需要频繁交付的企业可能更需要对 DevOps 有一个大致的了解。Flickr 发展了自己的 DevOps 能力，使之能够支撑业务部门“每天部署 10 次”的要求，如果一个组织要生产面向多种用户、具备多样功能的应用程序，其部署周期必然会很短。这种能力也被称为持续部署，并且经常与精益创业方法联系起来。从 2009 年起，相关的工作组、专业组织和博客快速涌现。 DevOps 的引入能对产品交付、测试、功能开发和维护（包括──曾经罕见但如今已屡见不鲜的──“热补丁”）起到意义深远的影响。在缺乏 DevOps 能力的组织中，开发与运营之间存在着信息“鸿沟”──例如运营人员要求更好的可靠性和安全性，开发人员则希望基础设施响应更快，而业务用户的需求则是更快地将更多的特性发布给最终用户使用。这种信息鸿沟就是最常出问题的地方。 以下几方面因素可能促使一个组织引入 DevOps： 使用敏捷或其他软件开发过程与方法 业务负责人要求加快产品交付的速率 虚拟化和云计算基础设施（可能来自内部或外部供应商）日益普遍 数据中心自动化技术和配置管理工具的普及 有一种观点认为，当前占主导地位的“传统”美国式管理风格（“斯隆模型 vs 丰田模型”）会导致“烟囱式自动化”，从而造成开发与运营之间的鸿沟，因此需要 DevOps 能力来克服由此引发的问题。 DevOps 经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/tags/开发工具/"},{"name":"Devops","slug":"Devops","permalink":"https://yangyfeng.github.io/blogpost/tags/Devops/"}]},{"title":"面试题集锦（1）","slug":"前端每日一题/面试题集锦（1）","date":"2020-09-08T16:00:00.000Z","updated":"2021-03-07T05:03:22.530Z","comments":true,"path":"/posts/714f78f3.html","link":"","permalink":"https://yangyfeng.github.io/posts/714f78f3.html","excerpt":"什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：网络协议不同，如http协议访问https协议。端口不同，如80端口访问8080端口。域名不同，如qianduanblog.com访问baidu.com。子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。域名和域名对应ip,如www.a.com访问20.205.28.90.2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。实现方法：通过nginx代理；注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。(2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\", \"Access-Control-Allow-Origin\":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。实例如下：1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = \"text/javascript\"; _script.src = \"http://localhost:8888/jsonp?callback=testjsonp\"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。","text":"什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：网络协议不同，如http协议访问https协议。端口不同，如80端口访问8080端口。域名不同，如qianduanblog.com访问baidu.com。子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。域名和域名对应ip,如www.a.com访问20.205.28.90.2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。实现方法：通过nginx代理；注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。(2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\", \"Access-Control-Allow-Origin\":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。实例如下：1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = \"text/javascript\"; _script.src = \"http://localhost:8888/jsonp?callback=testjsonp\"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。 介绍一下 JS 的基本数据类型。1Undefined、Null、Boolean、Number、String 如何利用JavaScript实现一个自定义事件，存在on，off，emit三个方法？这个题目的意义在哪里？我想，应该是对于一些特定的业务逻辑，比如在注册一个“通知”的事件，在与Native交互之后，假设这个交互是在入口级别的页面里，那么如何发送给具体某个业务呢？事件应该是最简单的一种方式，在某个具体的业务中注册一个事件，然后在与Native交互完，拿到某些数据后，然后触发这个事件。 我们来一步一步实现一个最简单的事件类Event，不考虑任何其他复杂的情况。假设在这个Event类的内部有一个this._events = [] 数组来维系整个事件系统，我们分别实现on，off，emit三个方法即可。 on（注册一个事件）：1234567Event.prototype.on = function(type,fun)&#123; let cbs = this._events[type]; cbs ? cbs.push(fun) : this._events[type] = []; if (!cbs) &#123; this._events[type].push(fun) &#125; &#125; 这里为什么要将this._events设计为二维数组？因为事件可以是多个，但是事件名可能相同。这个逻辑意图非常的明显，根据type参数从this._events中获取是否存在。如果不存在，创建一个type为key的数组，并将事件句柄程序push到数组中。 off（注销一个事件）：123456789101112131415161718192021222324252627Event.prototype.off = function (type, fun) &#123; let cbs = this._events[type]; //事件列队中无事件 if (!cbs) &#123; return this; &#125; //删除所有的事件 if (!event &amp;&amp; !fun) &#123; this._events = &#123;&#125;; return this; &#125; //只有事件名称时 if (event &amp;&amp; !fun) &#123; this._events[type] = null; return this; &#125; //删除某个事件队列中的某个事件 let cb; let i = cbs.length; while (i--) &#123; cb = cbs[i]; if (cb === fun || cb.fun === fun) &#123; cbs.splice(i, 1); break; &#125; &#125; &#125; 虽然注销事件方法的逻辑可能相比之下稍许多了些，但它的实现也非常简单，只要只存在事件组key名的情况，或者删除某个事件队列中的某个事件句柄程序即可。 emit（触发一个事件）：123456789101112Event.prototype.emit = function(type)&#123; let cbs = this._events[type]; let args = tools.toArray(arguments,1); if (cbs) &#123; let i = 0; let j = cbs.length; for(;i&lt;j;i++)&#123; let cb = cbs[i]; cb.apply(this,args); &#125; &#125;&#125; 逻辑依然非常简单，通过事件名从this._events获取相应的事件句柄程序数组，然后将arguments转成数组，（这里考虑的是可能会传入参数）如果事件句柄程序数组存在，进行循环，再讲args参数apply给每一个取出来的事件句柄程序。 ##请描述一个网页从开始请求道最终显示的完整过程？12345678一个网页从请求到最终显示的完整过程一般可以分为如下7个步骤：（1）在浏览器中输入网址；（2）发送至DNS服务器并获得域名对应的WEB服务器IP地址；（3）与WEB服务器建立TCP连接；（4）浏览器向WEB服务器的IP地址发送相应的HTTP请求；（5）WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址；（6）浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面；（7）分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部数据显示。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？12345678Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。（1）与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概5M左右。（2）LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。（3）使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。 说说js中的event loop机制？首先javascript是单线程机制，就是指当我们在执行一个任务的时候，其它的事情都得等待他执行完毕 在js中所有任务分为两种, 同步任务及异步任务 执行栈执行主线程任务，当有操作dom，ajax交互，使用定时器异步操作的时候，这些任务会被移入到 callback queue 任务队列中当主线程任务执行完毕为空时，会读取callback queue队列中的函数，进入主线程执行上述过程会不断重复，也就是常说的Event Loop(事件循环) 在一个事件循环中,异步任务返回结果后会被扔进一个任务列队中，根据异步事件上的类型，这个事件会被放到对应的宏任务或者微任务列队中去， 当执行栈为空的时候，主线程会先查看微任务中的事件列队，如果微任务不是空先依次执行微任务，如果是空的再去宏任务列队中取出一个事件并把对应的回调加入到当前执行栈，如此反复，进入循环 下面用一道题来加深印象 1234567891011setTimeout(function () &#123; console.log(1);&#125;);new Promise( (resolve,reject) =&gt; &#123; console.log(2)&#125;).then( (val) =&gt; &#123; console.log(val);&#125;)输出的结果是2,1 解释： 定时器是宏任务，Promise是异步的是微任务。所以先执行微任务 console.log(2),在执行宏任务console.log(1) 怎么理解js中的内存泄漏?内存泄漏的定义为当程序不再需要的内存，由于某种原因其不会返回到操作系统或可用内存池，内存泄漏会导致一系列问题，比如: 运行缓阳，崩溃，高延迟等 js中常见的内存泄露: 1、意外的全局变量 2、遗忘的计时器或回调函数 3、脱离文档的DOM引用 4、闭包 怎么理解js中是原型链? 如何实现继承? 每个构造函数都有一个原型对象 每个原型对象都包含一个指向构造函数的指针 每个实例都包含一个指向原型对象的指针 查找方式是一层层向上查找直至顶层Object.prototype 实现继承的方式常用的有: 原型链继承 借用构造函数(call,apply) 组合继承(原型链＋构造函数) 原型式继承 寄生式组合式继承 new 运算符具体干了什么?1、创建一个空的对象 2、将空的对象的proto成员指向构造函数的prototype成员对象 3、调用构造函数将this指向前面创建的对象","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"文章置顶","slug":"博客文档/文章置顶","date":"2020-09-08T09:57:47.506Z","updated":"2020-12-11T09:15:44.090Z","comments":true,"path":"/posts/7a527409.html","link":"","permalink":"https://yangyfeng.github.io/posts/7a527409.html","excerpt":"文章的Front-matter填写top: true就置顶了。1top: true 这是一个示例博客。源码目录：https://github.com/xaoxuu/blog-example","text":"文章的Front-matter填写top: true就置顶了。1top: true 这是一个示例博客。源码目录：https://github.com/xaoxuu/blog-example 没有更多了哦。","categories":[{"name":"博客文档","slug":"博客文档","permalink":"https://yangyfeng.github.io/blogpost/categories/博客文档/"}],"tags":[]},{"title":"less在vue中的使用","slug":"CSS预处理/less在vue中的使用","date":"2020-09-07T16:00:00.000Z","updated":"2021-03-07T04:36:03.786Z","comments":true,"path":"/posts/8136685c.html","link":"","permalink":"https://yangyfeng.github.io/posts/8136685c.html","excerpt":"","text":"less在vue中的使用首先vue环境搭建成功 第一步：安装 less 和less-loader 1安装less依赖：npm install less less-loader --save 第二步：修改webpack.base.config.js文件，配置loader加载依赖，让其支持外部的less,在原来的代码上添加 1234567// 此种方法在控制台中标签样式显示的是style标签样式&#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\",&#125;, 1234567// 可以在控制台中看到当前标签样式来自于哪个less文件&#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\", options: &#123; sourceMap: true &#125;&#125; 第三步：在vue文件中的style标签中添加lang=”less”即可在标签中使用less，或者外部引入less","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Less","slug":"Less","permalink":"https://yangyfeng.github.io/blogpost/tags/Less/"},{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"}]},{"title":"go语言的安装","slug":"Golang/go语言的安装","date":"2020-09-07T16:00:00.000Z","updated":"2021-03-07T04:31:16.623Z","comments":true,"path":"/posts/7b1282c0.html","link":"","permalink":"https://yangyfeng.github.io/posts/7b1282c0.html","excerpt":"","text":"简介Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、v数组安全、编译迅速 语言用途Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 语言环境安装Go 语言支持以下系统： Linux FreeBSD Mac OS X（也称为 Darwin） Window 使用这个地址：https://golang.google.cn/dl/。 Go 环境变量 将%GOPATH%\\bin添加到Path里 测试是否安装成功 至此就可以开始你的第一个Go程序了！！！！ 原文地址：https://blog.csdn.net/shumeigang/article/details/88664961","categories":[{"name":"后端","slug":"后端","permalink":"https://yangyfeng.github.io/blogpost/categories/后端/"}],"tags":[{"name":"GoLang","slug":"GoLang","permalink":"https://yangyfeng.github.io/blogpost/tags/GoLang/"}]},{"title":"microsoft vs code换主题","slug":"开发工具/microsoft vs code换主题","date":"2020-09-07T11:47:00.000Z","updated":"2021-03-07T04:43:53.065Z","comments":true,"path":"/posts/e8b3e153.html","link":"","permalink":"https://yangyfeng.github.io/posts/e8b3e153.html","excerpt":"01、菜单选择 -&gt; 参考下图 02、对话框说明 -&gt; 参考下图","text":"01、菜单选择 -&gt; 参考下图 02、对话框说明 -&gt; 参考下图 01、菜单选择 -&gt; 参考下图 02、对话框说明 -&gt; 参考下图","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://yangyfeng.github.io/blogpost/tags/VsCode/"}]},{"title":"vscode汉化教程","slug":"开发工具/vscode汉化教程","date":"2020-09-07T10:55:00.000Z","updated":"2021-03-07T04:43:53.066Z","comments":true,"path":"/posts/e8b3e153.html","link":"","permalink":"https://yangyfeng.github.io/posts/e8b3e153.html","excerpt":"VSCODE默认情况下是英文的。 相关推荐：《vscode使用教程》","text":"VSCODE默认情况下是英文的。 相关推荐：《vscode使用教程》 点击左侧菜单栏最底下的四方形按钮打开扩展程序界面，在输入框内输入Chinese并找到【Chinese (Simplified) Language Pack for Visual Studio Code】这个插件。在这个插件的详细界面点击【Install】按钮进行安装。 安装完成后按快捷键【CTRL+SHILF+P】打开命令面板并输入【config】后找到【Configure Display Language】选项并点击。 在接下来的二级菜单选择【zh-cn】，此时编辑器会弹出个访问窗口是否要重启编辑器生效语言的修改，点击【restart】按钮重新启动编辑器。 重启编辑器后就汉化成中文成功了 以上就是vscode如何汉化的详细内容","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://yangyfeng.github.io/blogpost/tags/VsCode/"}]},{"title":"microsoft vs code常用主题收集","slug":"开发工具/microsoft vs code常用主题收集","date":"2020-09-07T10:55:00.000Z","updated":"2020-12-11T09:16:00.808Z","comments":true,"path":"/posts/230490ec.html","link":"","permalink":"https://yangyfeng.github.io/posts/230490ec.html","excerpt":"页面太白不喜欢，黑色又太压抑怎么办？","text":"页面太白不喜欢，黑色又太压抑怎么办？ Slack Theme（本人很喜欢） cozygreen（近视眼必备&lt;(▰˘◡˘▰)&gt;）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/tags/开发工具/"}]},{"title":"什么是前端工程化","slug":"前端工程化/什么是前端工程化","date":"2020-09-04T08:20:00.000Z","updated":"2020-12-22T09:32:05.940Z","comments":true,"path":"/posts/b4383892.html","link":"","permalink":"https://yangyfeng.github.io/posts/b4383892.html","excerpt":"前端工程化是现代前端的必备技能快狗打车前端团队为例。 前端的开发框架以 Vue 为主，使用 Webpack 解决接口 mock、代码检查、代码编译、构建、压缩、添加版本号、部署等全流程的工作。涉及到的技术点有 Vue、Vuex、ESlint、stylelint、mock、Webpack、Sass、PostCSS 等。对前端的要求相比几年前已经从单纯的 JS、CSS 问题变成了更多工程化为主的问题。 前端工程化是一个很大的话题，甚至到现在都没有一个准确的定义。笔者对前端工程化的理解是：一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化。","text":"前端工程化是现代前端的必备技能快狗打车前端团队为例。 前端的开发框架以 Vue 为主，使用 Webpack 解决接口 mock、代码检查、代码编译、构建、压缩、添加版本号、部署等全流程的工作。涉及到的技术点有 Vue、Vuex、ESlint、stylelint、mock、Webpack、Sass、PostCSS 等。对前端的要求相比几年前已经从单纯的 JS、CSS 问题变成了更多工程化为主的问题。 前端工程化是一个很大的话题，甚至到现在都没有一个准确的定义。笔者对前端工程化的理解是：一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化。 实现前端工程化的好处在前端领域越来越繁荣，越来越复杂的今天，学习前端工程化又能给我们带来哪些好处呢？ 1. 极大提升开发效率 前端工程化的演进可以极大地提升开发效率。前端发展到现在，社区涌现出大量的优秀框架和工具，得以将前端工程师从繁重的工作中解脱出来。 举个例子，同样地给一个 dom 元素绑定一个 click 事件，使用纯 JS 可能这样做： 123document.getElementById('myDom').addEventListener('click', function(e)&#123; // do some thing&#125;) 我们引入 jQuery 的情况下，就简单了许多： 123$('#myDom').click(function()&#123; // do some thing&#125;) 如果在 Vue 中，既简单又清晰： 123456789&lt;div @click=\"doSomething\"&gt;&lt;/div&gt;// ...methods: &#123; doSomething: function () &#123; // do some thing &#125;&#125; 如果有大量的事件绑定，没有开发工具的支撑，将有大量重复的代码需要写，想想就头疼。效率之低下可见一斑。 为了减少请求数，前端开发者通常会把大量尺寸较小、细碎的小图片合并成一张大的透明的雪碧图，在 CSS 中通过设置元素的 background-position 来使用图片。如果是完全手动去拼图、测距，将耗费大量的时间。但在雪碧图插件 webpack-spriteSmith 的帮助下，小图可以自动拼成雪碧图，并生成对应的 CSS 样式，插件能帮助我们处理这种毫无技术含量的体力活，效率加倍。 再举一个例子，没有前端脚手架的情况下，如果从零开发一个项目，需要花费大量的时间去初始化项目，比如安装各种 npm 包、配置各种 Webpack 的 loader、配置热加载。如果碰到环境搭建不顺利的情况，还需要花费很长时间去排查问题，单单一个项目初始化的动作就足以耗费一两天的时间。有脚手架工具的情况下，只需要简单的一个初始化命令，2 分钟的时间就可以完成项目的初始化。前端只需要聚焦到业务开发本身，效率大幅提升。 2. 降低大型项目的开发难度 首先前端工程化中提倡模块化、组件化。模块化的思想将大型项目的功能进行分解，分拆成一个个独立的模块。每个模块的开发难度直线下降。同时基于版本控制工具 Git，多个开发者可以并行开发，提升开发效率。项目在后期迭代的时候，由于每个模块相对独立，耦合性极低，一个功能的调整往往只需要修改其中的一个模块就可以，风险可控。不至于出现改动一处代码，引发全局问题的情况。 其次，前端工程化提倡用完善的流程规范和代码规范来保证大型应用的质量和可维护性。比如通过 ESlint、stylelint 对代码进行自动校验，通过评审、详细设计、开发、联调、测试、上线等每个环节的控制，确保项目的高质量和按时交付。向主分支合并代码必须经过 code review。流程规范确保了大型项目质量和可维护性的同时能够如期交付。 更易获得面试官青睐 依稀记得六七年前去面试，遇到面试题大概是这种风格：“如何实现水平垂直居中”，“js 事件委托的原理是什么”，“常见的 css hack 方式有什么？”，“$(function(){})与 window.onload 有什么区别？” 今天面试遇到的面试题大概是这种风格：“能讲下 Vue 实现双向数据绑定的原理吗？”，“Webpack 中如何配置 Babel？”，“promise 和 await/async 的区别是什么？” 如果想进入大公司工作，前端工程化更是需要具备的基本素质。大公司的业务往往非常复杂，而且对稳定性的要求极高。与之相对应的前端工程化程度很高，各种配套的基础建设很成熟。比如美团点评体系化的工程化方案、移动组件库 Vix、自动化测试工具 Freekite、Hybrid 功能体验的解决方案 Titans 等。想得到这些公司的青睐，候选人需要在前端工程化领域有较深的积累。 前端的岗位技能已经发生深刻的变化。有人甚至戏言成前端工程师为前端配置工程师。 fouber（张云龙）曾经在自己的博文中说： 1\"前端是一种技术问题较少、工程问题较多的软件开发领域。” 所以前端工程化是每个现代前端人应该必备的技能。 谁需要前端工程化？3. 初中级前端工程师 对于初级中级前端工程师来说，由于工作经验较少，技术的宽度和广度都不足，对前端工程化的认知其实也是不够的，一上来整体掌握前端工程化肯定是有困难的。对于这部分同学来讲，首要的事情要学会去”用”，循序渐进地去了解其中的原理。例如在开发之余，自己学一学如何实现一个简单的脚手架工具，了解一下日常开发必备的脚手架是如何实现的，以点带面地学习里面用到的技术点。 期望晋升的前端工程师 前端工程化能力也是一个资深前端的必备技能。工作好多年了，如果连前端工程化都知之甚少，甚至连一个基本的脚手架都不能自己搭建，这是不及格的。如果将来带团队，怎么能指导团队同学，怎么能带领团队进步呢？如果去参加公司的晋升，也是没有说服力的。因为想要晋升高 T，必然需要在效率和性能优化等方面有深厚的积累和贡献。 所以，无论你是处在什么阶段，深入了解一下前端工程化都是极有必要的。 前端应用越来越复杂，对前端工程化的要求越来越高。脚手架作为目前前端工程化的一个重要的组成部分，在开发过程中扮演了至关重要的角色。现在几乎所有主流前端几框架都有自己配套的脚手架，无疑给开发者带来了极大的便利。但正如上文所述，很多开发者由于本身入行较短，或者很多工作多年的开发者由于公司业务的原因，没有机会接触到前端工程化领域。 学习目录开篇词：到底什么是前端工程化 第一部分：模板设计 第01课：模板功能设计第02课：Webpack 基本介绍第03课：搭建项目模板框架第04课：前端模块化解决方案第05课：搭建本地开发环境第06课：搭建本地 Mock 服务第07课：引入代码检查工具第08课：自动生成雪碧图第09课：根据浏览器构建第10课：根据环境构建第11课：集成移动端调试工具第12课：引入单元测试第13课：引入 e2e 测试第14课：Webpack 构建性能优化第15课：添加部署功能第16课：聚合项目配置并模板化 第二部分：命令行设计 第17课：cli 功能设计（上）第18课：cli 功能设计（下） 结语：开放的心态才是更高阶的工程化 学完后至少有以下几点收获： 对前端工程化有一个系统认知； 能独立设计一套前端工程化解决方案； 知识广度上有大幅提升； 进入更好的平台，获得更好的薪酬。","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"}]},{"title":"webpack依赖加载cdn配置","slug":"Vue/webpack依赖加载cdn配置","date":"2019-07-16T05:27:58.000Z","updated":"2021-03-07T04:44:19.961Z","comments":true,"path":"/posts/f8a3109a.html","link":"","permalink":"https://yangyfeng.github.io/posts/f8a3109a.html","excerpt":"CDN服务商的选择要使用cdn功能，就需要cdn服务商，我们可以自己搭建，也可以使用一些比较知名的服务商，庆幸的是市面上有不少的免费cdn服务商，如： BootCDN unpkg 其中BootCDN 是 Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务，项目资源同步于 cdnjs 仓库。界面相对比较好看，且支持搜索功能，可以在线测试cdn是否正常，所以下面以Bootcdn为例说明。 webpack的作用在前段项目开发中，我们经常使用webpack进行项目搭建， 主要作用有两个，分别是 1.启动服务器环境，用于调试代码 2.构建项目，生成静态资源 在webpack中使用cdn是在打包生成静态资源的时候做处理，主要原理是使用html-webpack-plugin动态插入cdn链接。 关于webpack的使用这里不做过多的介绍，将以vue–cli 2.x生成的默认项目为例做介绍","text":"CDN服务商的选择要使用cdn功能，就需要cdn服务商，我们可以自己搭建，也可以使用一些比较知名的服务商，庆幸的是市面上有不少的免费cdn服务商，如： BootCDN unpkg 其中BootCDN 是 Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务，项目资源同步于 cdnjs 仓库。界面相对比较好看，且支持搜索功能，可以在线测试cdn是否正常，所以下面以Bootcdn为例说明。 webpack的作用在前段项目开发中，我们经常使用webpack进行项目搭建， 主要作用有两个，分别是 1.启动服务器环境，用于调试代码 2.构建项目，生成静态资源 在webpack中使用cdn是在打包生成静态资源的时候做处理，主要原理是使用html-webpack-plugin动态插入cdn链接。 关于webpack的使用这里不做过多的介绍，将以vue–cli 2.x生成的默认项目为例做介绍 html-webpack-plugin的使用html-webpack-plugin是webpack的一个插件，可以动态的创建和编辑html内容，在html中使用esj语法可以读取到配置中的参数，简化了html文件的构建。 我们这次主要是使用它来动态插入cdn链接，如link标签和script标签。 创建Vue项目vue-cli 2.x1vue init webpack webpack-cdn-demo 创建名为webpack-cdn-demo，类型为webpack的vue项目，如果安装的vue-cli是3.x版本，命令不太一样，详细可看vue-cli 3。 安装依赖12$ cd webpack-cdn-demo$ npm install 启动项目1$ npm run dev 目录结构 1234567891011+-- build| +-- utils.js js 工具类| +-- webpack.base.conf.js webpack基础配置| +-- webpack.dev.conf.js webpack开发配置| +-- webpack.prod.conf.js webpack构建配置+-- config+-- src| +-- App.vue vue文件组件| +-- main.js 入口文件+-- index.html 页面+-- package.json 项目文件 其中build文件夹中的webpack.prod.conf.js是我们主要注意的文件,我们在该文件中动态设置不需要被打包的模块并构建出合适的链接。 确定需要使用CDN的模块在webpack项目中，所引入的第三方资源会被统一打包进vender文件中，我们通过webpack的externals属性可以设置打包时排除该模块，详情说明见外部扩展(externals)。 在前面的步骤中，我们创建的项目包括vue、vue-router，在正式开发在还会有ui库，如element-ui，为了方便演示，我们再安装element-ui和axios两个模块，并实现在构建是把这是个模块以cdn的形式引入。 所需模块 vue vue-router element-ui axios 1npm install element-ui axios -S 注意安装时记得 -S，它的作用是安装完后在package.json项目文件中插入记录，后续操作需要读取已安装模块 确定CDN资源URI对于cdn，我们可以自己搭建，也可以使用专业的cdn服务商，这里使用免费的cdn bootcdn。选用免费cdn有很多好处，但毕竟有隐患，那就是服务有可能会奔溃。 bootcdn https://www.bootcdn.cn 依次搜索出前面模块，结果如下: 模块 版本 js css vue 2.5.2 https://cdn.bootcss.com/vue/2.5.2/vue.min.js - vue-router 3.0.1 https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js - element-ui 2.6.3 https://cdn.bootcss.com/element-ui/2.6.1/index.js https://cdn.bootcss.com/element-ui/2.6.1/theme-chalk/index.css axios 0.18.0 https://cdn.bootcss.com/axios/0.18.0/axios.min.js - 按照规律，得出cdn资源路径规则为 1https://cdn.bootcss.com + 模块名 + 版本号 + 具体路径 其他cdn服务商同理 打包前的处理build/utils.js添加读取事件使用cdn其实也就是在webpack热启动和打包项目的时候动态插入script和style链接，为了方便维护，我们通过在build/utils.js文件上添加几个方法，将来在webpack.dev.conf.js和webpack.prod.conf.js上可以使用。 如果没有build/utils.js，可以在其他文件上添加，只要在后续步骤中能操作到就行 添加cdn根地址 12// build/utils.js 国内免费cdn镜像源exports.cdnBaseHttp = 'https://cdn.bootcss.com'; 添加cdn模块 按照需要删改 1234567// build/utils.js external配置exports.externalConfig = [ &#123; name: 'vue', scope: 'Vue', js: 'vue.min.js' &#125;, &#123; name: 'vue-router', scope: 'VueRouter', js: 'vue-router.min.js' &#125;, &#123; name: 'axios', scope: 'axios', js: 'axios.min.js' &#125;, &#123; name: 'element-ui', scope: 'ELEMENT', js: 'index.js', css: 'theme-chalk/index.css' &#125;,]; name 模块名称，与package.json同名 scope 模块作用域命名 js js地址 css css地址 这里特别注意scope，它是webpack配置的external参数下的信息，比如vue的作用域命名是Vue，vue-router的作用域命名是VueRouter，element-ui的作用域命名是ELEMENT，同理，jq的作用域命名是JQuery，具体做法是先引入该资源，然后在控制台依次输入近似的值，一个个匹配(目前没找到更好的做法)。 添加获取版本号方法 123456789101112// build/utils.js 获取模块版本号exports.getModulesVersion = () =&gt; &#123; let mvs = &#123;&#125;; let regexp = /^npm_package_.&#123;0,3&#125;dependencies_/gi; for (let m in process.env) &#123; // 从node内置参数中读取，也可直接import 项目文件进来 if (regexp.test(m)) &#123; // 匹配模块 // 获取到模块版本号 mvs[m.replace(regexp, '').replace(/_/g, '-')] = process.env[m].replace(/(~|\\^)/g, ''); &#125; &#125; return mvs;&#125;; 导出不需要被打包的cdn模块配置重点 123456789101112131415161718// build/utils.jsexports.getExternalModules = config =&gt; &#123; let externals = &#123;&#125;; // 结果 let dependencieModules = this.getModulesVersion(); // 获取全部的模块和版本号 config = config || this.externalConfig; // 默认使用utils下的配置 config.forEach(item =&gt; &#123; // 遍历配置 if (item.name in dependencieModules) &#123; let version = dependencieModules[item.name]; // 拼接css 和 js 完整链接 item.css = item.css &amp;&amp; [this.cdnBaseHttp, item.name, version, item.css].join('/'); item.js = item.js &amp;&amp; [this.cdnBaseHttp, item.name, version, item.js].join('/'); externals[item.name] = item.scope; // 为打包时准备 &#125; else &#123; throw new Error('相关依赖未安装，请先执行npm install ' + item.name); &#125; &#125;); return externals;&#125;; webpack.dev.conf.js添加cdn配置在webpack热启动本地调试的时候，我们可以使用cdn。 获取cdn配置 12345// build/webpack.dev.conf.js 大概在15行const externalConfig = JSON.parse(JSON.stringify(utils.externalConfig)); // 读取配置utils.getExternalModules(externalConfig); // 获取到合适的路径（引用类型，自动改变）// const devWebpackConfig = merge ....... 在build/webpack.dev.conf.js中，默认已经引入了utils.js，所以可以直接调用相关方法，如果是自定义的文件，记得引入。 HtmlWebpackPlugin插件中导出cdn 紧接着我们在该文件下找到devWebpackConfig下的plugins下的HtmlWebpackPlugin插件，它的作用是动态构建html页面，原始配置如下： 123456new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true&#125;),// 代表处理根目录下的index.html文件 我们可以往里面添加点自定义属性，方便在index.html中调用。，修改如下： 1234567new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, cdnConfig: externalConfig, // cdn配置 onlyCss: true, //dev下只加载css&#125;), 其中cdnConfig和onlyCss自定义属性，在html上通过htmlWebpackPlugin.options可以读取到。 更多html-webpack-plugin配置情况官网，这里暂时不需要更多。 webpack.prod.conf.js添加cdn配置和忽略模块在打包的时候，我们使用cdn，配置和前面dev的差不多，只不过需要做多一步。 获取cdn配置 12345// build/webpack.prod.conf.js 大概在15行const externalConfig = JSON.parse(JSON.stringify(utils.externalConfig)); // 读取配置const externalModules = utils.getExternalModules(externalConfig); // 获取到合适路径和忽略模块// const webpackConfig = merge(baseWebpackConfig.... 注意此处的externalModules，后面用到，也就是比dev多的步骤。 webpck配置加多个属性externals externals代表构建时不需要被处理的模块，也就是前面说的scope需要注意的地方。 123456// build/webpack.prod.conf.jsconst webpackConfig = merge(baseWebpackConfig, &#123; externals: externalModules, // 构建时忽略的资源 // 其他属性&#125; HtmlWebpackPlugin插件中导出cdn 和dev一样，我们修改webpackConfig下的plugins下的HtmlWebpackPlugin插件配置 (这里的默认配置比dev的多，主要是css压缩和js压缩相关) 12345new HtmlWebpackPlugin(&#123; // 其他默认配置 cdnConfig: externalConfig, // cdn配置 onlyCss: false, //加载css&#125;), 加入和dev一样的两个配置，不过需要把onlyCss改为true，因为我们希望打包时不单单使用css。 index.html插入相关链接webpack配置已经完成，在html-webpack-plugin中已经添加了相关参数，我们再在页面上可以直接使用，使用语法是ejs，和asp.net，jsp，php类似。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- 其他标签 --&gt; &lt;% htmlWebpackPlugin.options.cdnConfig.forEach(function(item)&#123; if(item.css)&#123; %&gt; &lt;link href=\"&lt;%= item.css %&gt;\" rel=\"stylesheet\" /&gt; &lt;% &#125;&#125;) %&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 其他标签 --&gt; &lt;% htmlWebpackPlugin.options.cdnConfig.forEach(function(item)&#123; if(item.js &amp;&amp; !htmlWebpackPlugin.options.onlyCss)&#123; %&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= item.js %&gt;\"&gt;&lt;/script&gt; &lt;% &#125;&#125;) %&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 通过&lt;% %&gt; 和 htmlWebpackPlugin.options 用js遍历插入link标签和script标签。 ps: 修改了webpack配置，需要重启项目才会生效 愉快的开发此时启动项目，查看控制台或者查看源代码，可以清楚的相关资源来源 有一个更好的插件webpack-cdn-plugin 原文链接","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yangyfeng.github.io/blogpost/tags/Webpack/"}]},{"title":"git子目录创建分支","slug":"Git/git子目录创建分支","date":"2019-07-13T06:01:41.000Z","updated":"2021-03-07T04:42:05.853Z","comments":true,"path":"/posts/2bdc4097.html","link":"","permalink":"https://yangyfeng.github.io/posts/2bdc4097.html","excerpt":"使用场景 例如，在项目Game中有一个子目录AI。Game和AI分别是一个独立的git项目，可以分开维护。为了避免直接复制粘贴代码，我们希望Game中的AI子目录与AI的git项目关联，有3层意思： 1.AI子目录使用AI的git项目来填充，内容保持一致。 2.当AI的git项目代码有更新，可以拉取更新到Game项目的AI子目录来。 3.反过来，当Game项目的AI子目录有变更，还可以推送这些变更到AI的git项目。 用git subtree可以轻松满足上面的需求。","text":"使用场景 例如，在项目Game中有一个子目录AI。Game和AI分别是一个独立的git项目，可以分开维护。为了避免直接复制粘贴代码，我们希望Game中的AI子目录与AI的git项目关联，有3层意思： 1.AI子目录使用AI的git项目来填充，内容保持一致。 2.当AI的git项目代码有更新，可以拉取更新到Game项目的AI子目录来。 3.反过来，当Game项目的AI子目录有变更，还可以推送这些变更到AI的git项目。 用git subtree可以轻松满足上面的需求。 git subtree用法1. 第一次添加子目录，建立与git项目的关联建立关联总共有2条命令。 1234567语法：git remote add -f &lt;子仓库名&gt; &lt;子仓库地址&gt; 解释：其中-f意思是在添加远程仓库之后，立即执行fetch。语法：git subtree add --prefix=&lt;子目录名&gt; &lt;子仓库名&gt; &lt;分支&gt; --squash 解释：–squash意思是把subtree的改动合并成一次commit，这样就不用拉取子项目完整的历史记录。–prefix之后的=等号也可以用空格。 示例12git remote add -f ai https://github.com/aoxu/ai.git git subtree add --prefix=ai ai master --squash 2. 从远程仓库更新子目录更新子目录有2条命令。12语法：git fetch &lt;远程仓库名&gt; &lt;分支&gt; 语法：git subtree pull --prefix=&lt;子目录名&gt; &lt;远程分支&gt; &lt;分支&gt; --squash 示例12git fetch ai master git subtree pull --prefix=ai ai --squash 3. 从子目录push到远程仓库（确认你有写权限）推送子目录的变更有1条命令。1语法：git subtree push --prefix=&lt;子目录名&gt; &lt;远程分支名&gt; 分支 示例1git subtree push --prefix=ai ai master 原文地址：http://cssor.com/git-subtree-usage.html","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangyfeng.github.io/blogpost/tags/Git/"}]},{"title":"git常用命令","slug":"Git/git常用命令","date":"2019-07-13T05:48:01.000Z","updated":"2021-03-07T04:42:05.853Z","comments":true,"path":"/posts/423abe9e.html","link":"","permalink":"https://yangyfeng.github.io/posts/423abe9e.html","excerpt":"推送到远程仓库：http://blog.csdn.net/u011043843/article/details/33336625 github设置添加SSH：https://blog.csdn.net/binyao02123202/article/details/20130891","text":"推送到远程仓库：http://blog.csdn.net/u011043843/article/details/33336625 github设置添加SSH：https://blog.csdn.net/binyao02123202/article/details/20130891 一.设置git的全局变量(用户名和邮箱)121. git config --global user.name”用户名(建议是英文)” 创建用户名2. git config --global user.email”邮箱地址” 创建邮箱 二.创建一个新的仓库12341. git clone &lt;url&gt; 从远程服务器克隆一个完全一样的版本库到本地 ：2. git add . 暂存文件3. git commit -a &lt;注释&gt; 提交4. git push -u origin master 推送（推送到主分支） 三.本地已经创建该目录123451. git init .初始化2. git remote add origin ssh://git.com/lsy/demo.git 增加一个远程服务端 3. git add 文件名/工程名 .（所有文件） 暂存文件4. git commit -m “Initial commit” 提交5. git push -u origin master 推送（推送到主分支） 四.存在git仓库12341. cd demo 进入该仓库2. git remote add origin ssh://git.com/lsy/hhh.git（git pull 同步代码到本地）增加一个远程服务端3. git push -u origin --all（上传代码到远程库） 推送4. git push -u origin --tags 推送标签到主机 五.常用命令：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. git branch 查看本地所有分支2. git branch -a 查看远程所有的分支3. git branch -r 查看远程所有分支(不包括当前分支)4. git push origin --delete &lt;name&gt; 可以删除远程分支5. git branch -d &lt;name&gt; 可以删除本地分支（在主分支中）6. git status 查看当前状态 7. git commit -am \"init\" 提交并且加注释 8. git subtree push --prefix= [目录地址(dist)] origin [分支名称(gh-pages)] 单个目录托管命令9. git remote add origin git@192.168.1.119:ndshow10. git push origin master 将文件给推到服务器上 11. git remote show origin 显示远程库origin里的资源 12. git push origin master:develop 提交本地master分支作为远程的develop分支13. git checkout --track origin/dev 切换到远程dev分支14. git checkout -b dev 建立一个新的本地分支dev15. git merge origin/dev 将分支dev与当前分支进行合并16. git checkout dev 切换到本地dev分支17. git remote show 查看远程库18. git remote remove &lt;name&gt; 删除remote19. git add . 暂存文件全部20. git rm 文件名(包括路径) 从git中删除指定文件21. git clone git:// 下载22. github.com/schacon/grit.git 从服务器上将代码给拉下来23. git config --list 看所有用户24. git ls-files 看已经被提交的25. git rm [file name] 删除一个文件26. git commit -a 提交当前repos的所有的改变27. git add [file name] 添加一个文件到git index28. git commit -v 当你用－v参数的时候可以看commit的差异29. git commit -m \"This is the message describing the commit\" 添加commit信息30. git commit -a -a是代表add，把所有的change加到git index里然后再commit31. git commit -a -v 一般提交命令32. git log 看你commit的日志33. git diff 查看尚未暂存的更新34. git rm a.a 移除文件(从暂存区和工作区中删除)35. git rm --cached a.a 移除文件(只从暂存区中删除)36. git commit -m \"remove\" 移除文件(从Git中删除)37. git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)38. git diff --cached 或 $ git diff --staged 查看尚未提交的更新39. git stash push 将文件给push到一个临时空间中40. git stash pop 将文件从临时空间pop下来41. git remote add origin git@github.com:username/Hello-World.git42. git push origin master 将本地项目给提交到服务器中43. git pull 本地与服务器端同步44. git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。45. git push origin serverfix:awesomebranch46. git fetch 相当于是从远程获取最新版本到本地，不会自动merge47. git commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：48. git branch branch_0.1 master 从主分支master创建branch_0.1分支49. git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.050. git checkout branch_1.0/master 切换到branch_1.0/master分支51. git branch 删除远程branch52. git push origin :branch_remote_name53. git branch -r -d branch_remote_name54. git reset --hard commit_id 版本回退55. git log可以查看提交历史56. git reflog查看命令历史","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangyfeng.github.io/blogpost/tags/Git/"}]},{"title":"vue.config.js配置","slug":"Vue/vue.config.js配置","date":"2019-07-13T05:41:06.000Z","updated":"2021-03-07T04:36:06.173Z","comments":true,"path":"/posts/4de2b0c3.html","link":"","permalink":"https://yangyfeng.github.io/posts/4de2b0c3.html","excerpt":"在项目根目录下创建vue.config.js文件：详细代码如下：","text":"在项目根目录下创建vue.config.js文件：详细代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177const webpack = require('webpack')const path = require('path'); function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; /* vue-cli3 项目配置文件 */ /* 基本路径 默认情况下，我们假设您的应用程序将部署在域的根上 例如：https://www.my-app.com/ 如果应用程序部署在子路径上，则需要指定 这里的子路径，例如，如果应用程序部署在 https://www.foobar.com/my-app/ 然后把这个变成 '/my-app/' 例如：https://www.example.com/project/v1.1/index.html baseUrl 为 /project/v1.1/ baseUrl: process.env.NODE_ENV === 'production' ? '/online/' : '/' */ baseUrl: '/', // 输出文件目录 // 在npm run build时 生成文件的目录 type:string, default:'dist' outputDir: 'dist', /* 构建多页时使用 index: &#123; // 入口 entry: 'src/index/main.js', // 模板 template: 'public/index.html', // output as dist/index.html filename: 'index.html' &#125; */ pages: &#123; type: Object, Default: undefined &#125;, // 用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下 // 网络请求的静态目录为 public 不参与打包 请求地址 ./ 直接指向 public 目录 assetsDir: 'assets', // 指定生成的 index.html 的输出路径 (打包之后，改变系统默认的index.html的文件名) indexPath: 'index.html', /* 如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置 lintOnSave: process.env.NODE_ENV !== 'production eslint-loader eslint检查,是否在保存的时候检查 lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint */ lintOnSave: true, // 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变) filenameHashing: false, /* 使用编译器生成全在浏览器 是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false) https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only */ runtimeCompiler: false, /* babel-loader在默认情况下跳过`node_modules`模块 显式地使用此选项来转换依赖项 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来 */ transpileDependencies: [ /* string or regex */ ], // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, /* 调整内部webpack配置 see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。 chainWebpack: config =&gt; &#123; config.module .rule('images') .use('url-loader') .loader('url-loader') .tap(options =&gt; &#123; // 修改它的选项... return options &#125;), config.entry.app = [\"babel-polyfill\", resolve('src/main.js')], // 别名 config.resolve.alias .set('@', resolve('src')) .set('./@assets', resolve('src/assets')) .set('@components', resolve('src/components')) .set('@font', resolve('src/font')); &#125;, */ /* configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125; */ // 插件配置 configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; jQuery: 'jquery', $: 'jquery' &#125;) ] &#125;, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125;, // 启用 CSS modules for all css / pre-processor files. modules: false &#125;, // 在生产中使用Babel＆TS thread-loader // 默认情况下，如果机器有超过1个内核 parallel: require('os').cpus().length &gt; 1, // PWA（渐进式WEB应用） 插件相关配置 https://segmentfault.com/a/1190000012353473 // see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: &#123;&#125;, // 它支持webPack-dev-server的所有选项 // See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#configuring-proxy devServer: &#123; // 主机名 host: process.env.HOST || 'localhost', // 端口号 port: process.env.PORT || 8080, // 是否支持https安全访问 https: false, // 配置自动启动浏览器 process.platform === 'darwin' open: true, // 热更新（webpack已实现了，这里false即可） hotOnly: false, compress: true, /* 配置跨域处理,只有一个代理 proxy: 'http://localhost:4000' 配置多个代理 &#123; '/api': &#123; target: '&lt;url&gt;', ws: true, changeOrigin: true &#125;, '/foo': &#123; target: '&lt;other_url&gt;' &#125; &#125; */ proxy: null, // 请求之前 before: app =&gt; &#123;&#125; &#125;, // 第三方插件配置 css loader pluginOptions: &#123; 'style-resources-loader': &#123; preProcessor: 'less', patterns: [] &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"}]},{"title":"vue轮子工厂","slug":"Vue/vue轮子工厂","date":"2019-07-13T05:26:53.000Z","updated":"2021-03-07T04:36:49.955Z","comments":true,"path":"/posts/da177769.html","link":"","permalink":"https://yangyfeng.github.io/posts/da177769.html","excerpt":"Vue轮子工厂","text":"Vue轮子工厂 组件名字 组件描述 组件git创库地址 element element - 饿了么出品的Vue2的web UI工具套件 https://github.com/ElemeFE/element Vux Vux - 基于Vue和WeUI的组件库 https://github.com/airyland/vux mint-ui mint-ui - Vue 2的移动UI元素 https://github.com/ElemeFE/mint-ui iview iview - 基于 Vuejs 的开源 UI 组件库 https://github.com/iview/iview Keen-UI Keen-UI - 轻量级的基本UI组件合集 https://github.com/JosephusPaye/Keen-UI vue-material vue-material - 通过Vue Material和Vue 2建立精美的app应用 https://github.com/marcosmoura/vue-material muse-ui muse-ui - 三端样式一致的响应式 UI 库 https://github.com/museui/muse-ui vuetify vuetify - 为移动而生的Vue JS 2组件框架 https://github.com/vuetifyjs/vuetify vonic vonic - 快速构建移动端单页应用 https://github.com/wangdahoo/vonic eme eme - 优雅的Markdown编辑器 https://github.com/egoist/eme vue-multiselect vue-multiselect - Vue.js选择框解决方案 https://github.com/monterail/vue-multiselect vue-table vue-table - 简化数据表格 https://github.com/ratiw/vue-table VueCircleMenu VueCircleMenu - 漂亮的vue圆环菜单 https://github.com/OYsun/VueCircleMenu vue-chat vue-chat - vuejs和vuex及webpack的聊天示例 https://github.com/Coffcer/vue-chat radon-ui radon-ui - 快速开发产品的Vue组件库 https://github.com/luojilab/radon-ui vue-waterfall vue-waterfall - Vue.js的瀑布布局组件 https://github.com/MopTym/vue-waterfall vue-carbon vue-carbon - 基于 vue 开发MD风格的移动端 https://github.com/myronliu347/vue-carbon vue-beauty vue-beauty - 由vue和ant design创建的优美UI组件 https://github.com/FE-Driver/vue-beauty vue-blu vue-blu - 帮助你轻松创建web应用 https://github.com/chenz24/vue-blu vueAdmin vueAdmin - 基于vuejs2和element的简单的管理员模板 https://github.com/taylorchen709/vueAdmin vue-syntax-highlight vue-syntax-highlight - Sublime Text语法高亮 https://github.com/vuejs/vue-syntax-highlight vue-infinite-scroll vue-infinite-scroll - VueJS的无限滚动指令 https://github.com/ElemeFE/vue-infinite-scroll Vue.Draggable Vue.Draggable - 实现拖放和视图模型数组同步 https://github.com/David-Desmaisons/Vue.Draggable vue-awesome-swiper vue-awesome-swiper - vue.js触摸滑动组件 https://github.com/surmon-china/vue-awesome-swiper vue-calendar vue-calendar - 日期选择插件 https://github.com/jinzhe/vue-calendar bootstrap-vue bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件 https://github.com/pi0/bootstrap-vue vue-swipe vue-swipe - VueJS触摸滑块 https://github.com/ElemeFE/vue-swipe vue-amap vue-amap - 基于Vue 2和高德地图的地图组件 https://github.com/ElemeFE/vue-amap vue-chartjs vue-chartjs - vue中的Chartjs的封装 https://github.com/apertureless/vue-chartjs vue-datepicker vue-datepicker - 日历和日期选择组件 https://github.com/hilongjw/vue-datepicker markcook markcook - 好看的markdown编辑器 https://github.com/jrainlau/markcook vue-google-maps vue-google-maps - 带有双向数据绑定Google地图组件 https://github.com/GuillaumeLeclerc/vue-google-maps vue-progressbar vue-progressbar - vue轻量级进度条 https://github.com/hilongjw/vue-progressbar vue-picture-input vue-picture-input - 移动友好的图片文件输入组件 https://github.com/alessiomaffeis/vue-picture-input vue-infinite-loading vue-infinite-loading - VueJS的无限滚动插件 https://github.com/PeachScript/vue-infinite-loading vue-upload-component vue-upload-component - Vuejs文件上传组件 https://github.com/lian-yue/vue-upload-component vue-datetime-picker vue-datetime-picker - 日期时间选择控件 https://github.com/Haixing-Hu/vue-datetime-picker vue-scroller vue-scroller - Vonic UI的功能性组件 https://github.com/wangdahoo/vue-scroller vue2-calendar vue2-calendar - 支持lunar和日期事件的日期选择器 https://github.com/icai/vue2-calendar vue-video-player vue-video-player - VueJS视频及直播播放器 https://github.com/surmon-china/vue-video-player vue-fullcalendar vue-fullcalendar - 基于vue.js的全日历组件 https://github.com/Wanderxx/vue-fullcalendar rubik rubik - 基于Vuejs2的开源 UI 组件库 https://github.com/ccforward/rubik VueStar VueStar - 带星星动画的vue点赞按钮 https://github.com/OYsun/VueStar vue-mugen-scroll vue-mugen-scroll - 无限滚动组件 https://github.com/egoist/vue-mugen-scroll mint-loadmore mint-loadmore - VueJS的双向下拉刷新组件 https://github.com/mint-ui/mint-loadmore vue-tables-2 vue-tables-2 - 显示数据的bootstrap样式网格 https://github.com/matfish2/vue-tables-2 vue-virtual-scroller vue-virtual-scroller - 带任意数目数据的顺畅的滚动 https://github.com/Akryum/vue-virtual-scroller DataVisualization DataVisualization - 数据可视化 https://github.com/SimonZhangITer/DataVisualization vue-quill-editor vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器 https://github.com/surmon-china/vue-quill-editor Vueditor Vueditor - 所见即所得的编辑器 https://github.com/hifarer/Vueditor vue-html5-editor vue-html5-editor - html5所见即所得编辑器 https://github.com/PeakTai/vue-html5-editor vue-msgbox vue-msgbox - vuejs的消息框 https://github.com/ElemeFE/vue-msgbox vue-slider vue-slider - vue 滑动组件 https://github.com/warpcgd/vue-slider vue-core-image-upload vue-core-image-upload - 轻量级的vue上传插件 https://github.com/Vanthink-UED/vue-core-image-upload vue-slide vue-slide - vue轻量级滑动组件 https://github.com/hilongjw/vue-slide vue-lazyload-img vue-lazyload-img - 移动优化的vue图片懒加载插件 https://github.com/JALBAA/vue-lazyload-img vue-drag-and-drop-list vue-drag-and-drop-list - 创建排序列表的Vue指令 https://github.com/Alex-fun/vue-drag-and-drop-list vue-progressive-image vue-progressive-image - Vue的渐进图像加载插件 https://github.com/MatteoGabriele/vue-progressive-image vuwe vuwe - 基于微信WeUI所开发的专用于Vue2的组件库 https://github.com/vuwe/vuwe vue-dropzone vue-dropzone - 用于文件上传的Vue组件 https://github.com/rowanwins/vue-dropzone vue-charts vue-charts - 轻松渲染一个图表 https://github.com/hchstera/vue-charts vue-swiper vue-swiper - 易于使用的滑块组件 https://github.com/weilao/vue-swiper vue-images vue-images - 显示一组图片的lightbox组件 https://github.com/littlewin-wang/vue-images vue-carousel-3d vue-carousel-3d - VueJS的3D轮播组件 https://github.com/Wlada/vue-carousel-3d vue-region-picker vue-region-picker - 选择中国的省份市和地区 https://github.com/QingWei-Li/vue-region-picker vue-typer vue-typer - 模拟用户输入选择和删除文本的Vue组件 https://github.com/cngu/vue-typer vue-impression vue-impression - 移动Vuejs2 UI元素 https://github.com/NewDadaFE/vue-impression vue-datatable vue-datatable - 使用Vuejs创建的DataTableView https://github.com/galenyuan/vue-datatable vue-instant vue-instant - 轻松创建自动提示的自定义搜索控件 https://github.com/santiblanko/vue-instant vue-dragging vue-dragging - 使元素可以拖拽 https://github.com/hilongjw/vue-dragging vue-slider-component vue-slider-component - 在vue1和vue2中使用滑块 https://github.com/NightCatSama/vue-slider-component vue2-loading-bar vue2-loading-bar - 最简单的仿Youtube加载条视图 https://github.com/BosNaufal/vue2-loading-bar vue-datepicker vue-datepicker - 漂亮的Vue日期选择器组件 https://github.com/weifeiyue/vue-datepicker vue-video vue-video - Vue.js的HTML5视频播放器 https://github.com/hilongjw/vue-video vue-toast-mobile vue-toast-mobile - VueJS的toast插件 https://github.com/ElemeFE/vue-toast-mobile vue-image-crop-upload vue-image-crop-upload - vue图片剪裁上传组件 https://github.com/dai-siki/vue-image-crop-upload vue-tooltip vue-tooltip - 带绑定信息提示的提示工具 https://github.com/Akryum/vue-tooltip vue-highcharts vue-highcharts - HighCharts组件 https://github.com/weizhenye/vue-highcharts vue-touch-ripple vue-touch-ripple - vuejs的触摸ripple组件 https://github.com/surmon-china/vue-touch-ripple coffeebreak coffeebreak - 实时编辑CSS组件工具 https://github.com/Kocisov/coffeebreak vue-datasource vue-datasource - 创建VueJS动态表格 https://github.com/coderdiaz/vue-datasource vue2-timepicker vue2-timepicker - 下拉时间选择器 https://github.com/phoenixwong/vue2-timepicker vue-date-picker vue-date-picker - VueJS日期选择器组件 https://github.com/Bubblings/vue-date-picker vue-scrollbar vue-scrollbar - 最简单的滚动区域组件 https://github.com/BosNaufal/vue-scrollbar vue-quill vue-quill - vue组件构建quill编辑器 https://github.com/CroudSupport/vue-quill vue-google-signin-button vue-google-signin-button - 导入谷歌登录按钮 https://github.com/phanan/vue-google-signin-button vue-svgicon vue-svgicon - 创建svg图标组件的工具 https://github.com/MMF-FE/vue-svgicon vue-float-label vue-float-label - VueJS浮动标签模式 https://github.com/bkzl/vue-float-label vue-baidu-map vue-baidu-map - 基于 Vue 2的百度地图组件库 https://github.com/Dafrok/vue-baidu-map vue-social-sharing vue-social-sharing - 社交分享组件 https://github.com/nicolasbeauvais/vue-social-sharing vue2-editor vue2-editor - HTML编辑器 https://github.com/davidroyer/vue2-editor vue-tagsinput vue-tagsinput - 基于VueJS的标签组件 https://github.com/Ginhing/vue-tagsinput vue-easy-slider vue-easy-slider - Vue 2.x的滑块组件 https://github.com/shhdgit/vue-easy-slider datepicker datepicker - 基于flatpickr的时间选择组件 https://github.com/vue-bulma/datepicker vue-chart vue-chart - 强大的高速的vue图表解析 https://github.com/miaolz123/vue-chart vue-music-master vue-music-master - vue手机端网页音乐播放器 https://github.com/yunyi1895/vue-music-master handsontable handsontable - 网页表格组件 https://github.com/vue-bulma/handsontable vue-simplemde vue-simplemde - VueJS的Markdown编辑器组件 https://github.com/F-loat/vue-simplemde vue-popup-mixin vue-popup-mixin - 用于管理弹出框的遮盖层 https://github.com/myronliu347/vue-popup-mixin cubeex cubeex - 包含一套完整的移动UI https://github.com/fangyongbao/cubeex vue-fullcalendar vue-fullcalendar - vue FullCalendar封装 https://github.com/CroudSupport/vue-fullcalendar vue-material-design vue-material-design - Vue MD风格组件 https://github.com/loujiayu/vue-material-design vue-morris vue-morris - Vuejs组件封装Morrisjs库 https://github.com/bbonnin/vue-morris we-vue we-vue - Vue2及weui1开发的组件 https://github.com/tianyong90/we-vue vue-image-clip vue-image-clip - 基于vue的图像剪辑组件 https://github.com/legeneek/vue-image-clip vue-bootstrap-table vue-bootstrap-table - 可排序可检索的表格 https://github.com/jbaysolutions/vue-bootstrap-table vue-radial-progress vue-radial-progress - Vue.js放射性进度条组件 https://github.com/wyzant-dev/vue-radial-progress vue-slick vue-slick - 实现流畅轮播框的vue组件 https://github.com/staskjs/vue-slick vue-pull-to-refresh vue-pull-to-refresh - Vue2的上拉下拉 https://github.com/bajian/vue-pull-to-refresh vue-form-2 vue-form-2 - 全面的HTML表单管理的解决方案 https://github.com/matfish2/vue-form-2 vue-side-nav vue-side-nav - 响应式的侧边导航 https://github.com/vue-comps/vue-side-nav mint-indicator mint-indicator - VueJS移动加载指示器插件 https://github.com/mint-ui/mint-indicator chartjs chartjs - Vue Bulma的chartjs组件 https://github.com/vue-bulma/chartjs vue-scroll vue-scroll - vue滚动 https://github.com/suguangwen/vue-scroll vue-ripple vue-ripple - 制作谷歌MD风格涟漪效果的Vue组件 https://github.com/BosNaufal/vue-ripple vue-touch-keyboard vue-touch-keyboard - VueJS虚拟键盘组件 https://github.com/icebob/vue-touch-keyboard vue-chartkick vue-chartkick - VueJS一行代码实现优美图表 https://github.com/ankane/vue-chartkick vue-ztree vue-ztree - 用 vue 写的树层级组件 https://github.com/lisiyizu/vue-ztree vue-m-carousel vue-m-carousel - vue 移动端轮播组件 https://github.com/shiye515/vue-m-carousel vue-datepicker-simple vue-datepicker-simple - 基于vue的日期选择器 https://github.com/dai-siki/vue-datepicker-simple vue-tabs vue-tabs - 多tab页轻型框架 https://github.com/alexqdjay/vue-tabs vue-verify-pop vue-verify-pop - 带气泡提示的vue校验插件 https://github.com/aweiu/vue-verify-pop vue-parallax vue-parallax - 整洁的视觉效果 https://github.com/vue-comps/vue-parallax vue-img-loader vue-img-loader - 图片加载UI组件 https://github.com/JackGit/vue-img-loader vue-typewriter vue-typewriter - vue组件类型 https://github.com/eduardostuart/vue-typewriter vue-smoothscroll vue-smoothscroll - smoothscroll的VueJS版本 https://github.com/Teddy-Zhu/vue-smoothscroll vue-city vue-city - 城市选择器 https://github.com/xinxingyu/vue-city vue-tree vue-tree - vue树视图组件 https://github.com/weibangtuo/vue-tree vue-ios-alertview vue-ios-alertview - iOS7+ 风格的alertview服务 https://github.com/Treri/vue-ios-alertview dd-vue-component dd-vue-component - 订单来了的公共组件库 https://github.com/ibufu/dd-vue-component paco-ui-vue paco-ui-vue - PACOUI的vue组件 https://github.com/yeseason/paco-ui-vue vue-cmap vue-cmap - Vue China map可视化组件 https://github.com/doodlewind/vue-cmap vue-button vue-button - Vue按钮组件 https://github.com/steven5538/vue-button vue.js vue.js - 流行的轻量高效的前端组件化方案 https://github.com/vuejs/vue vue-admin vue-admin - Vue管理面板框架 https://github.com/fundon/vue-admin electron-vue electron-vue - Electron及VueJS快速启动样板 https://github.com/SimulatedGREG/electron-vue vue-2.0-boilerplate vue-2.0-boilerplate - Vue2单页应用样板 https://github.com/petervmeijgaard/vue-2.0-boilerplate vue-spa-template vue-spa-template - 前后端分离后的单页应用开发 https://github.com/hanan198501/vue-spa-template Framework7-Vue Framework7-Vue - VueJS与Framework7结合 https://github.com/nolimits4web/Framework7-Vue vue-bulma vue-bulma - 轻量级高性能MVVM Admin UI框架 https://github.com/wangxg2016/vue-bulma vue-webgulp vue-webgulp - 仿VueJS Vue loader示例 https://github.com/rodzzlessa24/vue-webgulp vue-element-starter vue-element-starter - vue启动页 https://github.com/Metnew/vue-element-starter vuex vuex - 专为 Vue.js 应用程序开发的状态管理模式 https://github.com/vuejs/vuex vuelidate vuelidate - 简单轻量级的基于模块的Vue.js验证 https://github.com/monterail/vuelidate qingcheng qingcheng - qingcheng主题 https://github.com/zerqu/qingcheng vue-desktop vue-desktop - 创建管理面板网站的UI库 https://github.com/ElemeFE/vue-desktop vue-meta vue-meta - 管理app的meta信息 https://github.com/declandewet/vue-meta vue-axios vue-axios - 将axios整合到VueJS的封装 https://github.com/imcvampire/vue-axios vue-svg-icon vue-svg-icon - vue2的可变彩色svg图标方案 https://github.com/cenkai88/vue-svg-icon avoriaz avoriaz - VueJS测试实用工具库 https://github.com/eddyerburgh/avoriaz vue-framework7 vue-framework7 - 结合VueJS使用的Framework7组件 https://github.com/lmk123/vue-framework7 vue-bootstrap-modal vue-bootstrap-modal - vue的Bootstrap样式组件 https://github.com/Coffcer/vue-bootstrap-modal vuep vuep - 用实时编辑和预览来渲染Vue组件 https://github.com/QingWei-Li/vuep vue-online vue-online - reactive的在线和离线组件 https://github.com/Sopamo/vue-online vue-lazy-render vue-lazy-render - 用于Vue组件的延迟渲染 https://github.com/yeyuqiudeng/vue-lazy-render vue-password-strength-meter vue-password-strength-meter - 交互式密码强度计 https://github.com/apertureless/vue-password-strength-meter element-admin element-admin - 支持 vuecli 的 Element UI 的后台模板 https://github.com/lynzz/element-admin vue-electron vue-electron - 将选择的API封装到Vue对象中的插件 https://github.com/SimulatedGREG/vue-electron cleave cleave - 基于cleave.js的Cleave组件 https://github.com/vue-bulma/cleave vue-events vue-events - 简化事件的VueJS插件 https://github.com/cklmercer/vue-events vue-shortkey vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件 https://github.com/iFgR/vue-shortkey vue-cordova vue-cordova - Cordova的VueJS插件 https://github.com/kartsims/vue-cordova vue-router-transition vue-router-transition - 页面过渡插件 https://github.com/weinot/vue-router-transition vue-gesture vue-gesture - VueJS的手势事件插件 https://github.com/mlyknown/vue-gesture http-vue-loader http-vue-loader - 从html及js环境加载vue文件 https://github.com/FranckFreiburger/http-vue-loader vue-qart vue-qart - 用于qartjs的Vue2指令 https://github.com/superman66/vue-qart vuemit vuemit - 处理VueJS事件 https://github.com/gocanto/vuemit vue-websocket vue-websocket - VueJS的Websocket插件 https://github.com/icebob/vue-websocket vue-local-storage vue-local-storage - 具有类型支持的Vuejs本地储存插件 https://github.com/pinguinjkeke/vue-local-storage lazy-vue lazy-vue - 懒加载图片 https://github.com/gocanto/lazy-vue vue-bus vue-bus - VueJS的事件总线 https://github.com/yangmingshan/vue-bus vue-reactive-storage vue-reactive-storage - vue插件的Reactive层 https://github.com/ropbla9/vue-reactive-storage vue-notifications vue-notifications - 非阻塞通知库 https://github.com/se-panfilov/vue-notifications vue-lazy-component vue-lazy-component - 懒加载组件或者元素的Vue指令 https://github.com/Coffcer/vue-lazy-component v-media-query v-media-query - vue中添加用于配合媒体查询的方法 https://github.com/AStaroverov/v-media-query vue-observe-visibility vue-observe-visibility - 当元素在页面上可见或隐藏时检测 https://github.com/Akryum/vue-observe-visibility vue-ts-loader vue-ts-loader - 在Vue装载机检查脚本 https://github.com/HerringtonDarkholme/vue-ts-loader vue-pagination-2 vue-pagination-2 - 简单通用的分页组件 https://github.com/matfish2/vue-pagination-2 vuex-i18n vuex-i18n - 定位插件 https://github.com/dkfbasel/vuex-i18n Vue.resize Vue.resize - 检测HTML调整大小事件的vue指令 https://github.com/David-Desmaisons/Vue.resize vuex-shared-mutations vuex-shared-mutations - 分享某种Vuex mutations https://github.com/xanf/vuex-shared-mutations vue-file-base64 vue-file-base64 - 将文件转换为Base64的vue组件 https://github.com/BosNaufal/vue-file-base64 modal modal - Vue Bulma的modal组件 https://github.com/vue-bulma/modal Famous-Vue Famous-Vue - Famous库的vue组件 https://github.com/irwansyahwii/Famous-Vue leo-vue-validator leo-vue-validator - 异步的表单验证组件 https://github.com/LeoHuiyi/leo-vue-validator Vue-Easy-Validator Vue-Easy-Validator - 简单的表单验证 https://github.com/MetinSeylan/Vue-Easy-Validator vue-truncate-filter vue-truncate-filter - 截断字符串的VueJS过滤器 https://github.com/imcvampire/vue-truncate-filter vue-zoombox vue-zoombox - 一个高级zoombox https://github.com/vue-comps/vue-zoombox vue-input-autosize vue-input-autosize - 基于内容自动调整文本输入的大小 https://github.com/syropian/vue-input-autosize vue-lazyloadImg vue-lazyloadImg - 图片懒加载插件 https://github.com/yodfz/vue-lazyloadImg nuxt.js nuxt.js - 用于服务器渲染Vue app的最小化框架 https://github.com/nuxt/nuxt.js express-vue express-vue - 简单的使用服务器端渲染vue.js https://github.com/danmademe/express-vue vue-ssr vue-ssr - 非常简单的VueJS服务器端渲染模板 https://github.com/ccforward/vue-ssr vue-ssr vue-ssr - 结合Express使用Vue2服务端渲染 https://github.com/hilongjw/vue-ssr vue-easy-renderer vue-easy-renderer - Nodejs服务端渲染 https://github.com/leaves4j/vue-easy-renderer DejaVue DejaVue - Vuejs可视化及压力测试 https://github.com/MiCottOn/DejaVue vue-play vue-play - 展示Vue组件的最小化框架 https://github.com/vue-play/vue-play vscode-VueHelper vscode-VueHelper - 目前vscode最好的vue代码提示插件 https://github.com/OYsun/vscode-VueHelper vue-generate-component vue-generate-component - 轻松生成Vue js组件的CLI工具 https://github.com/NetanelBasal/vue-generate-component vue-multipage-cli vue-multipage-cli - 简单的多页CLI https://github.com/xwpongithub/vue-multipage-cli VuejsStarterKit VuejsStarterKit - vuejs starter套件 https://github.com/MetinSeylan/VuejsStarterKit koel koel - 基于网络的个人音频流媒体服务 https://github.com/phanan/koel pagekit pagekit - 轻量级的CMS建站系统 https://github.com/pagekit/pagekit vuedo vuedo - 博客平台 https://github.com/Vuedo/vuedo jackblog-vue jackblog-vue - 个人博客系统 https://github.com/jackhutu/jackblog-vue vue-cnode vue-cnode - 重写vue版cnode社区 https://github.com/lzxb/vue-cnode CMS-of-Blog CMS-of-Blog - 博客内容管理器 https://github.com/ycwalker/CMS-of-Blog rss-reader rss-reader - 简单的rss阅读器 https://github.com/mrgodhani/rss-reader vue-ghpages-blog vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客 https://github.com/viko16/vue-ghpages-blog swoole-vue-webim swoole-vue-webim - Web版的聊天应用 https://github.com/wh469012917/swoole-vue-webim vue-dashing-js vue-dashing-js - nuvo-dashing-js的fork https://github.com/thelinuxlich/vue-dashing-js fewords fewords - 功能极其简单的笔记本 https://github.com/sapjax/fewords vue-blog vue-blog - 使用Vue2.0 和Vuex的vue-blog https://github.com/surmon-china/vue-blog Vue-cnodejs Vue-cnodejs - 基于vue重写Cnodejs.org的webapp https://github.com/shinygang/Vue-cnodejs NeteaseCloudWebApp NeteaseCloudWebApp - 高仿网易云音乐的webapp https://github.com/javaSwing/NeteaseCloudWebApp vue-zhihu-daily vue-zhihu-daily - 知乎日报 with Vuejs https://github.com/hilongjw/vue-zhihu-daily vue-wechat vue-wechat - vue.js开发微信app界面 https://github.com/useryangtao/vue-wechat vue2-demo vue2-demo - 从零构建vue2 + vue-router + vuex 开发环境 https://github.com/lzxb/vue2-demo eleme eleme - 高仿饿了么app商家详情 https://github.com/liangxiaojuan/eleme vue-demo vue-demo - vue简易留言板 https://github.com/kenberkeley/vue-demo maizuo maizuo - vue/vuex/redux仿卖座网 https://github.com/zhengguorong/maizuo spa-starter-kit spa-starter-kit - 单页应用启动套件 https://github.com/codecasts/spa-starter-kit vue-music vue-music - Vue 音乐搜索播放 https://github.com/Sioxas/vue-music douban douban - 模仿豆瓣前端 https://github.com/jiakeqi/douban vue-Meizi vue-Meizi - vue最新实战项目 https://github.com/liangxiaojuan/vue-Meizi zhihudaily-vue zhihudaily-vue - 知乎日报web版 https://github.com/yatessss/zhihudaily-vue vue-demo-kugou vue-demo-kugou - vuejs仿写酷狗音乐webapp https://github.com/lavyun/vue-demo-kugou VueDemo_Sell_Eleme VueDemo_Sell_Eleme - Vue2高仿饿了么外卖平台 https://github.com/SimonZhangITer/VueDemo_Sell_Eleme vue2.0-taopiaopiao vue2.0-taopiaopiao - vue2.0与express构建淘票票页面 https://github.com/canfoo/vue2.0-taopiaopiao vue-leancloud-blog vue-leancloud-blog - 一个前后端完全分离的单页应用 https://github.com/jiangjiu/vue-leancloud-blog node-vue-server-webpack node-vue-server-webpack - Node.js+Vue.js+webpack快速开发框架 https://github.com/yjj5855/node-vue-server-webpack mi-by-vue mi-by-vue - VueJS仿小米官网 https://github.com/wendaosanshou/mi-by-vue vue-fis3 vue-fis3 - 流行开源工具集成demo https://github.com/okoala/vue-fis3 vue2.x-douban vue2.x-douban - Vue2实现简易豆瓣电影webApp https://github.com/superman66/vue2.x-douban vue-demo-maizuo vue-demo-maizuo - 使用Vue2全家桶仿制卖座电影 https://github.com/ChuckCZC/vue-demo-maizuo vue-zhihudaily vue-zhihudaily - 知乎日报 Web 版本 https://github.com/iHaPBoy/vue-zhihudaily vue-adminLte-vue-router vue-adminLte-vue-router - vue和adminLte整合应用 https://github.com/liujians/vue-adminLte-vue-router vue-axios-github vue-axios-github - 登录拦截登出功能 https://github.com/superman66/vue-axios-github Zhihu-Daily-Vue.js Zhihu-Daily-Vue.js - Vuejs单页网页应用 https://github.com/pomelo-chuan/Zhihu-Daily-Vue.js hello-vue-django hello-vue-django - 使用带有Django的vuejs的样板项目 https://github.com/rokups/hello-vue-django vue-cnode vue-cnode - vue单页应用demo https://github.com/wszgxa/vue-cnode x-blog x-blog - 开源的个人blog项目 https://github.com/CommanderXL/x-blog vue-express-mongodb vue-express-mongodb - 简单的前后端分离案例 https://github.com/xrr2016/vue-express-mongodb websocket_chat websocket_chat - 基于vue和websocket的多人在线聊天室 https://github.com/secreter/websocket_chat photoShare photoShare - 基于图片分享的社交平台 https://github.com/beidan/photoShare vue-zhihudaily-2.0 vue-zhihudaily-2.0 - 使用Vue2.0+vue-router+vuex创建的zhihudaily https://github.com/cs1707/vue-zhihudaily-2.0 notepad notepad - 本地存储的记事本 https://github.com/lin-xin/notepad vueBlog vueBlog - 前后端分离博客 https://github.com/elva2596/vueBlog vue-ruby-china vue-ruby-china - VueJS框架搭建的rubychina平台 https://github.com/hql123/vue-ruby-china Zhihu_Daily Zhihu_Daily - 基于Vue和Nodejs的Web单页应用 https://github.com/littlewin-wang/Zhihu_Daily vue-koa-demo vue-koa-demo - 使用Vue2和Koa1的全栈demo https://github.com/Molunerfinn/vue-koa-demo vue2.x-Cnode vue2.x-Cnode - 基于vue全家桶的Cnode社区 https://github.com/vincentSea/vue2.x-Cnode life-app-vue life-app-vue - 使用vue2完成多功能集合到小webapp https://github.com/shaqihe/life-app-vue github-explorer github-explorer - 寻找最有趣的GitHub库 https://github.com/SidKwok/github-explorer vue-trip vue-trip - vue2做的出行webapp https://github.com/wenye123/vue-trip vue-ssr-boilerplate vue-ssr-boilerplate - 精简版的ofvue-hackernews-2 https://github.com/albertchan/vue-ssr-boilerplate vue-bushishiren vue-bushishiren - 不是诗人应用 https://github.com/nswbmw/vue-bushishiren houtai houtai - 基于vue和Element的后台管理系统 https://github.com/peng1992/houtai ios7-vue ios7-vue - 使用vue2.0 vue-router vuex模拟ios7 https://github.com/QRL909109/ios7-vue Framework7-VueJS Framework7-VueJS - 使用移动框架的示例 https://github.com/tyllo/Framework7-VueJS cnode-vue cnode-vue - 基于vue和vue-router构建的cnodejs web网站SPA https://github.com/BubblyPoker/cnode-vue vue-cli-multipage-bootstrap vue-cli-multipage-bootstrap - 将vue官方在线示例整合到组件中 https://github.com/zhoou/vue-cli-multipage-bootstrap vue-cnode vue-cnode - 用 Vue 做的 CNode 官网 https://github.com/jiananle/vue-cnode HyaReader HyaReader - 移动友好的阅读器 https://github.com/GitaiQAQ/HyaReader zhihu-daily zhihu-daily - 轻松查看知乎日报内容 https://github.com/xrr2016/zhihu-daily seeMusic seeMusic - 跨平台云音乐播放器 https://github.com/Alex-xd/seeMusic vue-cnode vue-cnode - 使用cNode社区提供的接口 https://github.com/Damonlw/vue-cnode zhihu-daily-vue zhihu-daily-vue - 知乎日报 https://github.com/moonou/zhihu-daily-vue sls-vuex2-demo sls-vuex2-demo - vuex2商城购物车demo https://github.com/sailengsi/sls-vuex2-demo vue-dropload vue-dropload - 用以测试下拉加载与简单路由 https://github.com/ITCNZ/vue-dropload vue-cnode-mobile vue-cnode-mobile - 搭建cnode社区 https://github.com/soulcm/vue-cnode-mobile Vuejs-SalePlatform Vuejs-SalePlatform - vuejs搭建的售卖平台demo https://github.com/fishenal/Vuejs-SalePlatform v-notes v-notes - 简单美观的记事本 https://github.com/Halfeld/v-notes vue-starter vue-starter - VueJs项目的简单启动页 https://github.com/BosNaufal/vue-starter vue-memo vue-memo - 用 vue写的记事本应用 https://github.com/youknowznm/vue-memo","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://yangyfeng.github.io/blogpost/tags/Vue/"}]},{"title":"给文章加bgm","slug":"博客文档/给文章加bgm","date":"2018-12-29T16:00:00.000Z","updated":"2020-12-11T09:15:38.098Z","comments":true,"path":"/posts/3090f597.html","link":"","permalink":"https://yangyfeng.github.io/posts/3090f597.html","excerpt":"","text":"1234567---title: 给文章加bgmdate: 2018-12-30music: type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID---","categories":[{"name":"博客文档","slug":"博客文档","permalink":"https://yangyfeng.github.io/blogpost/categories/博客文档/"}],"tags":[]}]}