{"meta":{"title":"峰享会","subtitle":"路漫漫其修远兮，吾将上下而求索！","description":"集合了开发技能，生活趣事，未来科技，情感互动于一体。","author":"漫道求索","url":"https://yangyfeng.github.io"},"pages":[{"title":"404 Not Found","date":"2020-09-08T09:57:47.453Z","updated":"2020-09-08T09:57:47.453Z","comments":true,"path":"404.html","permalink":"https://yangyfeng.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-09-08T09:57:47.520Z","updated":"2020-09-08T09:57:47.520Z","comments":true,"path":"about/index.html","permalink":"https://yangyfeng.github.io/about/index.html","excerpt":"","text":"我是个快乐的前端小码农，现就职于北京 喜欢古风音乐 现在做大数据可视化展示 每写一行代码，都是人类的一次进步 博客主题文档 欢迎留言～"},{"title":"我的朋友们","date":"2020-09-08T09:57:47.522Z","updated":"2020-09-08T09:57:47.522Z","comments":true,"path":"friends/index.html","permalink":"https://yangyfeng.github.io/friends/index.html","excerpt":"","text":"海内存知己，天涯若比邻！ 相见即是缘分，欢迎各位大佬留言互换友链！ 必须要有名称、头像链接、至少一个标签或者一个简介哦～ 各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 漫道求索头像： https://s2.ax1x.com/2019/07/12/Zhm4jf.jpg网址： https://yangyfeng.github.io/yangyfeng.github.io/标签： 前端开发、大数据可视化"},{"title":"所有归档","date":"2020-09-08T09:57:47.520Z","updated":"2020-09-08T09:57:47.520Z","comments":true,"path":"blogpost/archives/index.html","permalink":"https://yangyfeng.github.io/blogpost/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-09-08T09:57:47.521Z","updated":"2020-09-08T09:57:47.521Z","comments":true,"path":"blogpost/categories/index.html","permalink":"https://yangyfeng.github.io/blogpost/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-09-08T09:57:47.521Z","updated":"2020-09-08T09:57:47.521Z","comments":true,"path":"blogpost/tags/index.html","permalink":"https://yangyfeng.github.io/blogpost/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue面试题（2）","slug":"面试/vue面试题（2）","date":"2020-12-20T16:00:00.000Z","updated":"2020-12-21T08:54:58.442Z","comments":true,"path":"/posts/e210f74f.html","link":"","permalink":"https://yangyfeng.github.io/posts/e210f74f.html","excerpt":"v-if和v-for哪个优先级更高？ 分析：此题考查常识，文档中曾有详细说明；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者应用能力。 思路分析：总分总模式 先给出结论 为什么是这样的 它们能放一起吗 如果不能，那应该怎样 总结 回答范例： v-for优先于v-if被解析 我曾经做过实验，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件 实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。 通常有两种情况下导致我们这样做： 为了过滤列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。此时把 v-if 移动至容器元素上 (比如 ul、ol)即可。 文档中明确指出永远不要把 v-if 和 v-for 同时用在同一个元素上，显然这是一个重要的注意事项。 看过源码里面关于代码生成的部分 知其所以然： 做个测试 12345678910111213ƒ anonymous() &#123; with(this) &#123; return _c('div', &#123; attrs: &#123; \"id\": \"app\" &#125; &#125;, _l((items), function(item) &#123; return (item.isActive) ? _c('div', &#123; key: item.id &#125;, [_v(\"\\n \" + _s(item.name) + \"\\n \")]) : _e() &#125;), 0) &#125;&#125; 源码中找答案 compiler/codegen/index.js","text":"v-if和v-for哪个优先级更高？ 分析：此题考查常识，文档中曾有详细说明；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者应用能力。 思路分析：总分总模式 先给出结论 为什么是这样的 它们能放一起吗 如果不能，那应该怎样 总结 回答范例： v-for优先于v-if被解析 我曾经做过实验，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件 实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。 通常有两种情况下导致我们这样做： 为了过滤列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。此时把 v-if 移动至容器元素上 (比如 ul、ol)即可。 文档中明确指出永远不要把 v-if 和 v-for 同时用在同一个元素上，显然这是一个重要的注意事项。 看过源码里面关于代码生成的部分 知其所以然： 做个测试 12345678910111213ƒ anonymous() &#123; with(this) &#123; return _c('div', &#123; attrs: &#123; \"id\": \"app\" &#125; &#125;, _l((items), function(item) &#123; return (item.isActive) ? _c('div', &#123; key: item.id &#125;, [_v(\"\\n \" + _s(item.name) + \"\\n \")]) : _e() &#125;), 0) &#125;&#125; 源码中找答案 compiler/codegen/index.js 你知道key的作用吗？分析：这是一道特别常见的问题，主要考查大家对虚拟DOM和patch细节的掌握程度，能够反映面试者理解层次。 思路分析：总分总模式 给出结论，key的作用是用于优化patch性能 key的必要性 实际使用方式 总结：可从源码层面描述一下vue如何判断两个节点是否相同 回答范例： key的作用主要是为了更高效的更新虚拟DOM。 vue在patch过程中判断两个节点是否是相同节点是key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，vue只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个patch过程比较低效，影响性能。 实际使用中在渲染一组列表时key必须设置，而且必须是唯一标识，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。 测试代码 使用key: 123456789101112131415161718192021// 首次循环patch AA B C D EA B F C D E// 第2次循环patch BB C D EB F C D E// 第3次循环patch EC D EF C D E// 第4次循环patch DC DF C D// 第5次循环patch CC F C// oldCh全部处理结束，newCh中剩下的F，创建F并插入到C前面 不使用key 源码中找答案 src\\core\\vdom\\patch.js - sameVnode() 你了解vue中的diff算法吗？题目分析：vue基于虚拟DOM做更新，diff又是其核心部分，因此常被问道，此题考查面试者深度。 答题思路：3w1h 定义diff 它的必要性 它在哪里被使用 它如何运作 提升：说一些细节 回答范例： diff算法是虚拟DOM技术的产物，vue里面实际叫做patch，它的核心实现来自于snabbdom；通过新旧虚拟DOM作对比（即patch），将变化的地方转换为DOM操作 在vue 1中是没有patch的，因为界面中每个依赖都有专门的watcher负责更新，这样项目规模变大就会成为性能瓶颈，vue 2中为了降低watcher粒度，每个组件只有一个watcher，但是当需要更新的时候，怎样才能精确找到发生变化的地方？这就需要引入patch才行。 组件中数据发生变化时，对应的watcher会通知更新并执行其更新函数，它会执行渲染函数获取全新虚拟dom：newVnode，此时就会执行patch比对上次渲染结果oldVnode和新的渲染结果newVnode。 patch过程遵循深度优先、同层比较的策略；两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。 vue中组件之间的通信方式？ 题目分析： vue是组件化开发框架，所以对于vue应用来说组件间的数据通信非常重要。此题主要考查大家vue基本功，对于vue基础api运用熟练度。另外一些边界知识如provide/inject/$attrs/$listeners则体现了面试者的知识面。 思路分析：总分 总述知道的所有方式 按组件关系阐述使用场景 回答范例： 组件通信方式大体有以下8种： props $emit/$on $children/$parent $attrs/$listeners ref $root eventbus vuex 根据组件之间关系讨论组件通信最为清晰有效 父子组件 props $emit/$on $parent / $children ref $attrs / $listeners 兄弟组件 $parent eventbus vuex 跨层级关系 provide/inject $root eventbus vuex 简单说一说你对vuex理解？ 分析：此题考查实践能力，能说出用法只能60分。更重要的是对vuex设计理念和实现原理的解读。 回答策略：3w1h 首先给vuex下一个定义 vuex解决了哪些问题，解读理念 什么时候我们需要vuex 你的具体用法 简述原理，提升层级 首先是官网定义： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 回答范例： vuex是vue专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。 vuex主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。vuex通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。 vuex并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用vuex的必要。一个简单的store 模式就足够了。反之，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。 我在使用vuex过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入state对象中，它本身一棵状态树，组件中使用store实例的state访问这些状态；然后有配套的mutation方法修改这些状态，并且只能用mutation修改状态，在组件中调用commit方法提交mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写action，执行结束如果有状态修改仍然需要提交mutation，组件中调用这些action使用dispatch方法派发。最后是模块化，通过modules选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置namespace，那么在提交mutation和派发action时还需要额外的命名空间前缀。 vuex在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了vue的数据响应化特性实现的，它会利用Vue将state作为data对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。 vue-router中如何保护路由？ 此题是考查项目实践能力，项目中基本都有路由守卫的需求，保护指定路由考查的就是这个知识点。 答题整体思路： 阐述vue-router中路由保护策略 描述具体实现方式 简单说一下它们是怎么生效的 回答范例： vue-router中保护路由安全通常使用导航守卫来做，通过设置路由导航钩子函数的方式添加守卫函数，在里面判断用户的登录状态和权限，从而达到保护指定路由的目的。 具体实现有几个层级：全局前置守卫beforeEach、路由独享守卫beforeEnter或组件内守卫beforeRouteEnter。以全局守卫为例来说，可以使用router.beforeEach((to,from,next)=&gt;{})方式设置守卫，每次路由导航时，都会执行该守卫，从而检查当前用户是否可以继续导航，通过给next函数传递多种参数达到不同的目的，比如如果禁止用户继续导航可以传递next(false)，正常放行可以不传递参数，传递path字符串可以重定向到一个新的地址等等。 这些钩子函数之所以能够生效，也和vue-router工作方式有关，像beforeEach只是注册一个hook，当路由发生变化，router准备导航之前会批量执行这些hooks，并且把目标路由to，当前路由from，以及后续处理函数next传递给我们设置的hook。 可能的追问： 1、能不能说说全局守卫、路由独享守卫和组件内守卫区别？ 作用范围 组件实例的获取 12345beforeRouteEnter(to,from,next) &#123; next(vm =&gt; &#123; &#125;)&#125; 名称/数量/顺序 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 2、你项目中的路由守卫是怎么做的？ 3、前后端路由一样吗？ 4、前端路由是用什么方式实现的？ 5、你前面提到的next方法是怎么实现的？ 你了解哪些Vue性能优化方法？ 答题思路：根据题目描述，这里主要探讨Vue代码层面的优化 路由懒加载 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: () =&gt; import('./Foo.vue') &#125; ]&#125;) keep-alive缓存页面 1234567&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 使用v-show复用DOM 1234567891011&lt;template&gt; &lt;div class=&quot;cell&quot;&gt; &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt; &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/div&gt; &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; v-for 遍历避免同时使用 v-if 1234567891011121314151617181920&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125; &#125; &#125;&lt;/script&gt; 长列表性能优化 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化 123456789export default &#123; data: () =&gt; (&#123; users: [] &#125;), async created() &#123; const users = await axios.get(\"/api/users\"); this.users = Object.freeze(users); &#125;&#125;; 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容 123456789101112&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot;&gt; &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt; &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot; /&gt; &lt;/template&gt;&lt;/recycle-scroller&gt; 参考vue-virtual-scroller、vue-virtual-scroll-list 事件的销毁 Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 123456created() &#123; this.timer = setInterval(this.refresh, 2000)&#125;,beforeDestroy() &#123; clearInterval(this.timer)&#125; 图片懒加载 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。 1&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt; 参考项目：vue-lazyload 第三方插件按需引入 像element-ui这样的第三方组件库可以按需引入避免体积太大。 12345import Vue from 'vue';import &#123; Button, Select &#125; from 'element-ui'; Vue.use(Button) Vue.use(Select) 无状态的组件标记为函数式组件 123456789101112&lt;template functional&gt; &lt;div class=&quot;cell&quot;&gt; &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt; &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&apos;value&apos;]&#125;&lt;/script&gt; 子组件分割 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;ChildComp/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123; ChildComp: &#123; methods: &#123; heavy () &#123; /* 耗时任务 */ &#125; &#125;, render (h) &#123; return h(&apos;div&apos;, this.heavy()) &#125; &#125; &#125;&#125;&lt;/script&gt; 变量本地化 123456789101112131415161718192021222324&lt;template&gt; &lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt; &#123;&#123; result &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; heavy &#125; from &apos;@/utils&apos;export default &#123; props: [&apos;start&apos;], computed: &#123; base () &#123; return 42 &#125;, result () &#123; const base = this.base // 不要频繁引用this.base let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(base) &#125; return result &#125; &#125;&#125;&lt;/script&gt; SSR 说一说你对vue响应式理解？ 烂大街的问题，但却不是每个人都能回答到位。因为如果你只是看看别人写的网文，通常没什么底气，也经不住面试官推敲，但像我们这样即看过源码还造过轮子的，回答这个问题就会比较有底气。 答题思路： 啥是响应式？ 为什么vue需要响应式？ 它能给我们带来什么好处？ vue的响应式是怎么实现的？有哪些优缺点？ vue3中的响应式的新变化 回答范例： 所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。 mvvm框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。 以vue为例说明，通过数据响应式加上虚拟DOM和patch算法，可以使我们只需要操作数据，完全不用接触繁琐的dom操作，从而大大提升开发效率，降低开发难度。 vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。 为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的Proxy机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，我们甚至不需要引入vue都可以体验。 你如果想要扩展某个Vue组件时会怎么做？ 此题属于实践题，着重考察大家对vue常用api使用熟练度，答题时不仅要列出这些解决方案，同时最好说出他们异同。 答题思路： 按照逻辑扩展和内容扩展来列举，逻辑扩展有：mixins、extends、composition api；内容扩展有slots； 分别说出他们使用使用方法、场景差异和问题。 作为扩展，还可以说说vue3中新引入的composition api带来的变化 回答范例： 常见的组件扩展方法有：mixins，slots，extends等 混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 12345678910111213// 复用代码：它是一个配置对象，选项和组件里面一样const mymixin = &#123; methods: &#123; dosomething()&#123;&#125; &#125;&#125;// 全局混入：将混入对象传入Vue.mixin(mymixin)// 局部混入：做数组项设置到mixins选项，仅作用于当前组件const Comp = &#123; mixins: [mymixin]&#125; 插槽主要用于vue组件中的内容分发，也可以用于组件扩展。 子组件Child 123&lt;div&gt; &lt;slot&gt;这个内容会被父组件传递的内容替换&lt;/slot&gt;&lt;/div&gt; 父组件Parent 123&lt;div&gt; &lt;Child&gt;来自老爹的内容&lt;/Child&gt;&lt;/div&gt; 如果要精确分发到不同位置可以使用具名插槽，如果要使用子组件中的数据可以使用作用域插槽。 组件选项中还有一个不太常用的选项extends，也可以起到扩展组件的目的 123456789101112// 扩展对象const myextends = &#123; methods: &#123; dosomething()&#123;&#125; &#125;&#125;// 组件扩展：做数组项设置到extends选项，仅作用于当前组件// 跟混入的不同是它只能扩展单个对象// 另外如果和混入发生冲突，该选项优先级较高，优先起作用const Comp = &#123; extends: myextends&#125; 混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中有机组合使用。例如： 123456789101112// 复用逻辑1function useXX() &#123;&#125;// 复用逻辑2function useYY() &#123;&#125;// 逻辑组合const Comp = &#123; setup() &#123; const &#123;xx&#125; = useXX() const &#123;yy&#125; = useYY() return &#123;xx, yy&#125; &#125;&#125; 可能的追问 : Vue.extend方法你用过吗？它能用来做组件扩展吗？ Vue2和Vue3中的响应式原理对比，分别的具体实现思路此题非常好，既考察深度又考察广度，面试者要对两个版本的响应式原理都有深入理解才能答好。 答题思路： 可以先说vue2响应式原理 然后说出它的问题 最后说出vue3是怎么解决的 回答范例： vue2数据响应式实现根据对象类型做不同处理，如果是object，则通过Object.defineProperty(obj,key,descriptor)拦截对象属性访问 1234567891011function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; return val &#125;, set(v) &#123; val = v notify() &#125; &#125;)&#125; 如果是数组，则覆盖数组的7个变更方法实现变更通知 123456789101112const arrayProto = Array.prototypeconst arrayMethods = Object.create(arrayProto);['push','pop','shift','unshift','splice','sort','reverse'] .forEach(function (method) &#123; const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) notify() return result &#125;)&#125;) 可以看到vue2中有几个问题： 初始化时需要遍历对象所有key，如果对象层级较深，性能不好 通知更新过程需要维护大量dep实例和watcher实例，额外占用内存较多 动态新增、删除对象属性无法拦截，只能用特定set/delete api代替 不支持新的Map、Set等数据结构 vue3中为了解决以上问题，使用原生的Proxy代替： 12345678910111213141516function defineReactive(obj) &#123; return new Proxy(obj, &#123; get(target, key) &#123; track(target, key) return Reflect.get(target, key) &#125;, set(target, key, val) &#123; Reflect.set(target, key, val) trigger(target, key) &#125;, deleteProperty(target, key) &#123; Reflect.deleteProperty(target, key) trigger(target, key) &#125; &#125;)&#125; 可以同时支持object和array，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能取得很大进步。 面试题剖析","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"},{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"面试题集锦（2）","slug":"面试/面试题集锦（2）","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-21T08:54:54.854Z","comments":true,"path":"/posts/63fad71d.html","link":"","permalink":"https://yangyfeng.github.io/posts/63fad71d.html","excerpt":"","text":"web安全攻击手段有哪些？以及如何防范常见的有xss, csrf, sql注入 xss(cross site scripting) 跨站脚本攻击 定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行 XSS攻击分为3类：存储型（持久型）、反射型（非持久型）、基于DOM 如何防范: 设置HttpOnly以避免cookie劫持的危险过滤，对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御 csrf(cross site request forgery) 跨站请求伪造 定义: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式 如何防范: 验证 HTTP Referer 字段请求地址中添加 token 并验证HTTP 头中自定义属性并验证 sql注入(SQL injection) 定义: 在未授权情况下，非法访问数据库信息 如何防范: 杜绝用户提交的参数入库并且执行在代码层，不准出现sql语句在web输入参数处，对所有的参数做sql转义上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试 前端优化手段有哪些？ 静态资源合并压缩(js,css, images) 请求数量优化 Gzip压缩 带宽优化 CDN 就近节点，减少DNS查找 按需加载 lazyload 减少请求 骨架屏 优化白屏 web缓存 缓存ajax数据 减少重绘和重排 批量更新ＤＯＭ样式 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 如何理解es6中的Decorator（装饰器）？定义 Decorator是ES7中的提案，概念借鉴于python， 它作用于一个目标类为其添加属性于方法 我们用一个比喻来理解Decorator, 把孙悟空看成是一个类，那么棒子就是装饰器为其装备的武器 代码理解: 123456789101112131415161718@stickclass Monkey &#123; &#125;function stick(target) &#123;// 第一个参数就是目标类的本身 target.ATK = 100000&#125;Monkey.ATK// 为悟空装备了棒子，攻击力提高了100000// 如果一个参数不够用，可以在装饰器外层再包一层function stick(atk) &#123; return function (targt) &#123; target.ATK = atk &#125;&#125;@stick(200000)// 这样我们就为悟空增加了200000攻击力class Monkey &#123; &#125; Decorator 不仅能修饰类，也能修饰类的方法 123456class Monkey &#123; @setName name() &#123; this.name = '孙悟空' &#125;&#125; Decorator 只能修饰类及类的方法,不能修饰于函数,因为存在函数提升 Mixin 在修饰器基础上，我们可以实现mixin(混入),意思在一个对象中混入另一个对象的方法 代码示例: 12345678910111213141516171819export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;const skill = &#123; shapeshifting() &#123; console.log('72变') &#125;&#125;@mixins(skill)class Monkey &#123;&#125;Object.assign(Monkey.prototype, skill)const swk = new Monkey()swk.shapeshifting() // 72变 使用Decorator的好处 扩展功能，相对于继承增加了更多的灵活性 代码可读性更高，装饰器正确命名相当于注释","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"深入webpack","slug":"前端工程化/深入webpack","date":"2020-12-15T16:00:00.000Z","updated":"2020-12-18T07:52:14.781Z","comments":true,"path":"/posts/a441c8bd.html","link":"","permalink":"https://yangyfeng.github.io/posts/a441c8bd.html","excerpt":"","text":"实现步骤：0、读取webpack.config.js 1、解析文件依赖 2、替换require为webpack_require 3、本地使用{}存储所有的文件，然后通过使用为webpack_require获取文件内容，执行函数方式为evel的包裹代码字符串 代码实现index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#! /usr/bin/env node// 读取configconst path = require('path')const fs = require('fs')// 默认配置const defaultConfig = &#123; entry: './src/index.js', output: &#123; filename: 'build.js' &#125;&#125;// 最终的配置const config = &#123; ...defaultConfig, ...require(path.resolve('./mywebpack.config.js'))&#125;class MyWebPack &#123; constructor(config) &#123; this.config = config this.entry = config.entry // 根目录 this.root = process.cwd() // 存储所有代码 this.modules = &#123;&#125; &#125; start() &#123; console.log('解析依赖') const entryPath = path.resolve(this.root, this.entry) this.createModule(entryPath, this.entry) // 生成新文件 this.generaleFile() &#125; // 代码字符串 generaleModuleString() &#123; let fnTmp = '' for (const name in this.modules) &#123; fnTmp += `\"$&#123;name&#125;\":$&#123;this.modules[name].replace(/\\r|\\n/g, \"\")&#125;,` &#125; fnTmp = fnTmp.substring(0, fnTmp.length - 1) return `&#123;$&#123;fnTmp&#125;&#125;` &#125; // 生成新文件 generaleFile() &#123; let template = fs.readFileSync(path.resolve(__dirname, './template.js'), 'utf-8') this.template = template.replace('__entry__', this.entry).replace('__modules_content__', this.generaleModuleString()) fs.mkdirSync(\"./mydist\"); fs.writeFileSync('./mydist/' + this.config.output.filename, this.template) console.log('写入文件完毕'); &#125; // 创建依赖 createModule(modulePath, name) &#123; // 出现了循环依赖 // if (this.modules[modulePath]) return const fileContent = fs.readFileSync(modulePath, 'utf-8') // 替换后的代码和依赖数组 const &#123; code, deps &#125; = this.parse(fileContent, path.dirname(name)) this.modules[name] = `function (module, module.exports, __mywebpack_require__) &#123; eval(\\`$&#123;code&#125;\\`) &#125;` // 循环获取所有依赖数组的内容 deps.forEach(dep =&gt; &#123; this.createModule(path.join(this.root, dep), './' + dep) &#125;) console.log(this.modules) &#125; // 文件解析 parse(code, parent) &#123; let deps = [] let r = /require\\('(.*)'\\)/g // require('xxx') 将require替换__mywebpack_require__ code = code.replace(r, function (match, arg) &#123; const retPath = path.join(parent, arg.replace(/'|\"/g, '')) deps.push(retPath) return `__mywebpack_require__(\"./$&#123;retPath&#125;\")` &#125;) return &#123; code, deps &#125; &#125;&#125;const mywebpack = new MyWebPack(config)mywebpack.start() template.js 12345678910111213141516171819!function (modules) &#123; // 缓存 const installModules = &#123;&#125; // 替换后的require function __mywebpack_require__(moduleId) &#123; // 是否缓存 if (installModules[moduleId]) &#123; return installModules[moduleId].exports &#125; let modules = installModules[moduleId] = &#123; exports: &#123;&#125; &#125; modules[moduleId].call(modules.exports, module, exports, __mywebpack_require__) return module.exports &#125; // 入口 return __mywebpack_require__(\"__entry__\")&#125;(__modules_content__)","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"},{"name":"webpack","slug":"webpack","permalink":"https://yangyfeng.github.io/blogpost/tags/webpack/"}]},{"title":"深入前端模块化","slug":"前端工程化/深入前端模块化","date":"2020-12-15T16:00:00.000Z","updated":"2020-12-16T08:32:14.915Z","comments":true,"path":"/posts/c00659d0.html","link":"","permalink":"https://yangyfeng.github.io/posts/c00659d0.html","excerpt":"什么是前端的模块化？理解的不太透彻。 平常一直用的也只有ES6模块化，对于其他几种模块化规范用的也少，理解不够深，但是经常会见到一些面试题是问这几种模块化规范的区别，所以这次做一个整理总结 一、对于模块化的理解1、什么是模块化？模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的AMD规范，CMD规范，以及ES6自带的模块化规范 2、模块化带来的好处？ 解决命名冲突 提供复用性 提高代码可维护性 灵活架构，焦点分离，方便模块间组合、分解 多人协作互不干扰 3、模块化规范的发展进程 原始写法（全局function） 模块就是实现特定**功能的一组方法，只要把不同的函数（以及记录状态的变量）简单的放在一起，就算是一个模块。 123456function m1 () &#123; // ...&#125;function m2 () &#123; // ...&#125; 这样写上面的函数 m1() 和 m2() ，组成了一个模块，在使用的时候直接调用就可以了。 但是带来的问题也很明显：&quot;污染&quot;了全局变量 ，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系 namespace写法（简单对象） 为了解决上面写法带来的缺点，可以吧模块写成一个对象，所有的模块成员都放到这个对象里面，这样减少了全局变量，减少命名冲突 123456789101112131415161718const myModule = new Object(&#123; count: 0, m1: function () &#123; console.log('m1:' + this.count); &#125;, m2: function () &#123; console.log('m2:' + this.count) &#125;&#125;)// 调用myModule.m1() // m1:0// 改变模块内部状态myModule.count = 5;myModule.m1() // m1:5 上面的函数 m1 和 m2 ，都封装在myModule对象里。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 立即执行函数写法（匿名函数自执行 ，闭包） 12345678910111213const myModule = (function () &#123; let count = 0; let m1 = function () &#123; console.log('m1:' + count) &#125;; let m2 = function () &#123; console.log('m2:' + count) &#125; return &#123; m1, m2 &#125;;&#125;)()// 这样写在外面就无法读取内部的 count 变量console.log(myModule.count); // undefined 立即执行函数增强(引入依赖) 12345const myModule = (function ($) &#123; // 这里面就可以使用JQuery&#125;)(JQuery)// 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显","text":"什么是前端的模块化？理解的不太透彻。 平常一直用的也只有ES6模块化，对于其他几种模块化规范用的也少，理解不够深，但是经常会见到一些面试题是问这几种模块化规范的区别，所以这次做一个整理总结 一、对于模块化的理解1、什么是模块化？模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的AMD规范，CMD规范，以及ES6自带的模块化规范 2、模块化带来的好处？ 解决命名冲突 提供复用性 提高代码可维护性 灵活架构，焦点分离，方便模块间组合、分解 多人协作互不干扰 3、模块化规范的发展进程 原始写法（全局function） 模块就是实现特定**功能的一组方法，只要把不同的函数（以及记录状态的变量）简单的放在一起，就算是一个模块。 123456function m1 () &#123; // ...&#125;function m2 () &#123; // ...&#125; 这样写上面的函数 m1() 和 m2() ，组成了一个模块，在使用的时候直接调用就可以了。 但是带来的问题也很明显：&quot;污染&quot;了全局变量 ，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系 namespace写法（简单对象） 为了解决上面写法带来的缺点，可以吧模块写成一个对象，所有的模块成员都放到这个对象里面，这样减少了全局变量，减少命名冲突 123456789101112131415161718const myModule = new Object(&#123; count: 0, m1: function () &#123; console.log('m1:' + this.count); &#125;, m2: function () &#123; console.log('m2:' + this.count) &#125;&#125;)// 调用myModule.m1() // m1:0// 改变模块内部状态myModule.count = 5;myModule.m1() // m1:5 上面的函数 m1 和 m2 ，都封装在myModule对象里。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 立即执行函数写法（匿名函数自执行 ，闭包） 12345678910111213const myModule = (function () &#123; let count = 0; let m1 = function () &#123; console.log('m1:' + count) &#125;; let m2 = function () &#123; console.log('m2:' + count) &#125; return &#123; m1, m2 &#125;;&#125;)()// 这样写在外面就无法读取内部的 count 变量console.log(myModule.count); // undefined 立即执行函数增强(引入依赖) 12345const myModule = (function ($) &#123; // 这里面就可以使用JQuery&#125;)(JQuery)// 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显 二、模块化规范1. CommonJS(1)简介Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。 (2)特点 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 (3)基本语法12暴露模块：module.exports = value或exports.xxx = value引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径 CommonJS暴露的模块到底是什么? CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 1234567// example.jslet count = 5;let incrementCount = function () &#123; return ++count&#125;module.exports.count = count;module.exports.incrementCount = incrementCount; 1234// require.jsconst example = require('./example.js');console.log(example.count); // 5console.log(example.incrementCount()); // 6 require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 (4)模块的加载机制CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（ES6输入的是值的引用） 1234567// example.jslet count = 5;let incrementCount = function () &#123; return ++count&#125;module.exports = &#123; count, incrementCount &#125;; 1234567// require.jsconst example = require('./example.js');console.log(example.count); // 5example.incrementCount();console.log(example.count); // 5 2. AMD(1)简介CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 此外AMD规范比CommonJS规范在浏览器端实现要来着早。 (2)基本语法1234567/*** @param id* @param dependencies* @param factory*/define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。 factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 (3)用例定义一个名为 myModule 的模块，它依赖 jQuery 模块： 1234567define('myModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用require(['myModule'], function(myModule) &#123;&#125;); 依赖多个模块的定义： 1234define(['jquery', './math.js'], function($, math) &#123; // $ 和 math 一次传入 factory $('body').text('hello world');&#125;); 模块输出： 123456789define(['jquery'], function($) &#123; var HelloWorldize = function(selector)&#123; $(selector).text('hello world'); &#125;; // HelloWorldize 是该模块输出的对外接口 return HelloWorldize;&#125;); 在模块定义内部引用依赖： 1234define(function(require) &#123; var $ = require('jquery'); $('body').text('hello world');&#125;); 3. CMD(1)简介CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。 (2)基本语法123456/*** @param &#123;String&#125; id* @param &#123;Array&#125; dependencies* @param &#123;Function | Object | String&#125; factory*/define(id?, dependencies?, factory) factory 为对象、字符串时，表示模块的接口就是该对象、字符串。 123define(&#123; \"foo\": \"bar\" &#125;);define('I am a template. My name is &#123;&#123;name&#125;&#125;.'); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module： 123456define(function(require, exports, module) &#123; // 模块代码&#125;); (3)简单用例定义没有依赖的模块： 1234define(function(require, exports, module)&#123; exports.xxx = value module.exports = value&#125;) 定义有依赖的模块： 123456789define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require('./module2') //引入依赖模块(异步) require.async('./module3', function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) 4. ES6模块化(1) 简介ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 (2) 基本语法export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 1234567891011121314/** 定义模块 **/var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;;/** 引用模块 **/import &#123; basicNum, add &#125; from './math';function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; 导出模块还可以有种默认导出的写法 module.export : 123456789// export-default.jsexport default function () &#123; console.log('foo');&#125;// 模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。// import-default.jsimport customName from './export-default'; customName(); // 'foo' (3) ES6 模块与 CommonJS 模块的差异 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块输出的是一个值的拷贝， ES6 模块输出的是一个值的引用 差异一： 是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 差异二： 123456789101112// export.jsexport let num = 5;export let incrementNum = function() &#123; ++num;&#125;;// import.jsimport &#123; num, num2, incrementNum &#125; from '../export.js';console.log(num); // 5console.log(incrementNum());console.log(num); // 6 从上面我们不难看出 ES6 模块化 与上面CommonJS不一样的地方 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。CommonJS输入的是值的拷贝（原始类型），如果是函数、对象，也是用的引用 三、总结 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 前端模块化详解(完整版)","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"},{"name":"模块化","slug":"模块化","permalink":"https://yangyfeng.github.io/blogpost/tags/模块化/"}]},{"title":"为什么前端需要学习node","slug":"Node/为什么前端需要学习node","date":"2020-12-14T16:00:00.000Z","updated":"2020-12-15T08:33:17.940Z","comments":true,"path":"/posts/fbba48cc.html","link":"","permalink":"https://yangyfeng.github.io/posts/fbba48cc.html","excerpt":"","text":"理解解决跨域、token鉴权、Rsetful风格、XSS、CSRF等问题，学习后端的思维。（与后端有效沟通） 如何只用js语言如何开发一个全栈的应用（快速开发全栈应用） 学习全栈和架构思维的有效途径（践行工程化思想）","categories":[{"name":"Node","slug":"Node","permalink":"https://yangyfeng.github.io/blogpost/categories/Node/"}],"tags":[]},{"title":"vue性能优化","slug":"Vue/vue性能优化","date":"2020-12-10T16:00:00.000Z","updated":"2020-12-11T09:14:10.312Z","comments":true,"path":"/posts/93532fe.html","link":"","permalink":"https://yangyfeng.github.io/posts/93532fe.html","excerpt":"1、使用单文件组件我们写的tmplate配置，实际上需要编译为render函数在执行的 当使用DOM内模板或者JS内的字符串模板时，模板会在运行时被编译为render函数，通常情况这个过程已经足够快乐，但是对性能敏感的应用还是有影响的。 预编译模板最简单的方式就是使用单文件组件，单文件组件将相关的构建设置自动预编译好了，所以构建的代码已经包含了编译出来的render函数了，而不是原始的模板字符串了，减少了重新编译的过程了。（单文件组件导入使用直接使用vue-loader来处理，没有vue-tmplate的出来，使用起来会足够快速的。）","text":"1、使用单文件组件我们写的tmplate配置，实际上需要编译为render函数在执行的 当使用DOM内模板或者JS内的字符串模板时，模板会在运行时被编译为render函数，通常情况这个过程已经足够快乐，但是对性能敏感的应用还是有影响的。 预编译模板最简单的方式就是使用单文件组件，单文件组件将相关的构建设置自动预编译好了，所以构建的代码已经包含了编译出来的render函数了，而不是原始的模板字符串了，减少了重新编译的过程了。（单文件组件导入使用直接使用vue-loader来处理，没有vue-tmplate的出来，使用起来会足够快速的。） 2、使用Objaec.freeze()提升性能参考vue源码，定义响应式的时候，如果freeze后的数据，不会加上setter和getter https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js 1234const property = Object.getOwnPropertyDescriptor(obj, key)if (property &amp;&amp; property.configurable === false) &#123; return&#125; 3、扁平化数据storestore数据扁平化，减少数据层级嵌套，减少遍历。 4、列表渲染优化如果的我们的应用存在无限长或者无限滚动的长列表，那么采用 窗口化的技术来优化，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。 vue-virtual-scroll-list vue-virtual-scroller 可以使用上面的两个库来处理 5、骨架屏 webpack骨架屏的实践方案: https://www.jianshu.com/p/ec4bf33ab2c8 6、 ssr服务端渲染 实现方案可以采用nuxt.js 7、 路由懒加载https://router.vuejs.org/zh/guide/advanced/lazy-loading.html 8、 gzip、缓存控制、cdn开启GZIP 体积对比图：1541KB vs 466KB 耗时对比图：333ms vs 225ms 操作步骤： 1、安装包（新版本的好像配置还要改~~） npm install --save-dev compression-webpack-plugin 2、webpack的配置 123productionGzip: true,productionGzipExtensions: ['js', 'css'] 3、nginx添加配置： 12345678server &#123; gzip on; #开启或关闭gzip on off gzip_static on; gzip_disable \"msie6\"; #不使用gzip IE6 gzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节） gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #压缩文件类型 ...&#125; CND加速 vue打包文件会默认把所有的第三方代码打包到一个vendor.js中，我们可以把部分超大的文件剥离出来，使用cnd资源。如图，我们将vue/vuex/vue-router/axios分离出来降低vendor.js的压力。 1、引入外部资源CDN 2、webpack处理（别名处理） key：要引入的资源名称；value：模块提供给外部引用的名称 3、去除引用，如果想避免全局污染，可如下定义","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"},{"name":"性能优化","slug":"性能优化","permalink":"https://yangyfeng.github.io/blogpost/tags/性能优化/"}]},{"title":"vue面试题（1）","slug":"面试/vue面试题（1）","date":"2020-12-10T16:00:00.000Z","updated":"2020-12-21T08:55:02.204Z","comments":true,"path":"/posts/bc152925.html","link":"","permalink":"https://yangyfeng.github.io/posts/bc152925.html","excerpt":"Vue双向绑定实现原理？vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 双花括弧），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 Observer 对所有数据的属性进行监听 Compile 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 Watcher 作为连接Observer 跟 Compile 之间的桥梁, 能够订阅接收到每个属性变动的通知,执行相应的回调函数 代码理解: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const Dep = function() &#123; this.subs = []&#125;;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(sub = &gt; &#123; sub.update() &#125;) &#125;,&#125;;const Watcher = function(vm, node, name) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null&#125;;Watcher.prototype = &#123; update: function() &#123; this.get(); this.node.nodeValue = this.value &#125;, get: function() &#123; this.value = this.vm[this.name] &#125;,&#125;;const compile = function(node, vm) &#123; if (node.nodeType === 1) &#123; let attr = node.attributes; for (let i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName === 'v-model') &#123; let name = attr[i].nodeValue; node.addEventListener('input', e = &gt; &#123; vm[name] = node.value &#125;); node.value = vm[name]; node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.nodeValue)) &#123; let name = RegExp.$1; name = name.trim(); node.nodeValue = vm[name]; new Watcher(vm, node, name) &#125; &#125;&#125;;const observe = data = &gt; &#123; if (!data || typeof data !== 'object') return 3344; Object.keys(data).forEach(key = &gt; defineReactive(data, key, data[key]))&#125;;const defineReactive = (data, key, value) = &gt; &#123; const dep = new Dep(); observe(value); Object.defineProperty(data, key, &#123; get: () = &gt; &#123; if (Dep.target) dep.addSub(Dep.target); return value &#125;, set: function(newValue) &#123; console.log(`数据已发生变化，新的值为$ &#123; newValue &#125;`); value = newValue; dep.notify() &#125;, &#125;)&#125;;function nodeToFragment(node, vm) &#123; let flag = document.createDocumentFragment(); let child; while ((child = node.firstChild)) &#123; compile(child, vm); flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; let data = this.data = options.data; observe(data, this); let id = options.el; let dom = nodeToFragment(document.getElementById(id), data); document.getElementById(id).appendChild(dom)&#125;let vm = new Vue(&#123; el: 'app', data: &#123; text: 'example text', &#125;,&#125;); 题目分析：双向绑定是vue的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。 思路分析：3w1h 给出双绑定义 双绑带来的好处 在哪使用双绑 使用方式 扩展：使用细节、原理实现描述 回答范例： vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。 使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好 通常在表单项上使用v-model 原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件 我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。 可能的追问： v-model和sync修饰符有什么区别 自定义组件使用v-model如果想要改变事件名或者属性名应该怎么做 观察输出的渲染函数： 123456789101112// &lt;input type=\"text\" v-model=\"foo\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (foo), expression: \"foo\" &#125;], attrs: &#123; \"type\": \"text\" &#125;, domProps: &#123; \"value\": (foo) &#125;, on: &#123; \"input\": function ($event) &#123; if ($event.target.composing) return; foo = $event.target.value &#125; &#125; &#125;) 123456789101112131415161718192021// &lt;input type=\"checkbox\" v-model=\"bar\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (bar), expression: \"bar\" &#125;], attrs: &#123; \"type\": \"checkbox\" &#125;, domProps: &#123; \"checked\": Array.isArray(bar) ? _i(bar, null) &gt; -1 : (bar) &#125;, on: &#123; \"change\": function ($event) &#123; var $$a = bar, $$el = $event.target, $$c = $$el.checked ? (true) : (false); if (Array.isArray($$a)) &#123; var $$v = null, $$i = _i($$a, $$v); if ($$el.checked) &#123; $$i &lt; 0 &amp;&amp; (bar = $$a.concat([$$v])) &#125; else &#123; $$i &gt; -1 &amp;&amp; (bar = $$a.slice(0, $$i).concat($$a.slice($$i + 1))) &#125; &#125; else &#123; bar = $$c &#125; &#125; &#125; &#125;) 123456789101112131415161718192021222324// &lt;select v-model=\"baz\"&gt;// &lt;option value=\"vue\"&gt;vue&lt;/option&gt;// &lt;option value=\"react\"&gt;react&lt;/option&gt;// &lt;/select&gt;_c('select', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (baz), expression: \"baz\" &#125;], on: &#123; \"change\": function ($event) &#123; var $$selectedVal = Array.prototype.filter.call( $event.target.options, function (o) &#123; return o.selected &#125; ).map( function (o) &#123; var val = \"_value\" in o ? o._value : o.value; return val &#125; ); baz = $event.target.multiple ? $$selectedVal : $$selectedVal[0] &#125; &#125; &#125;, [ _c('option', &#123; attrs: &#123; \"value\": \"vue\" &#125; &#125;, [_v(\"vue\")]), _v(\" \"), _c('option', &#123; attrs: &#123; \"value\": \"react\" &#125; &#125;, [_v(\"react\")])])","text":"Vue双向绑定实现原理？vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 双花括弧），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 Observer 对所有数据的属性进行监听 Compile 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 Watcher 作为连接Observer 跟 Compile 之间的桥梁, 能够订阅接收到每个属性变动的通知,执行相应的回调函数 代码理解: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const Dep = function() &#123; this.subs = []&#125;;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(sub = &gt; &#123; sub.update() &#125;) &#125;,&#125;;const Watcher = function(vm, node, name) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null&#125;;Watcher.prototype = &#123; update: function() &#123; this.get(); this.node.nodeValue = this.value &#125;, get: function() &#123; this.value = this.vm[this.name] &#125;,&#125;;const compile = function(node, vm) &#123; if (node.nodeType === 1) &#123; let attr = node.attributes; for (let i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName === 'v-model') &#123; let name = attr[i].nodeValue; node.addEventListener('input', e = &gt; &#123; vm[name] = node.value &#125;); node.value = vm[name]; node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.nodeValue)) &#123; let name = RegExp.$1; name = name.trim(); node.nodeValue = vm[name]; new Watcher(vm, node, name) &#125; &#125;&#125;;const observe = data = &gt; &#123; if (!data || typeof data !== 'object') return 3344; Object.keys(data).forEach(key = &gt; defineReactive(data, key, data[key]))&#125;;const defineReactive = (data, key, value) = &gt; &#123; const dep = new Dep(); observe(value); Object.defineProperty(data, key, &#123; get: () = &gt; &#123; if (Dep.target) dep.addSub(Dep.target); return value &#125;, set: function(newValue) &#123; console.log(`数据已发生变化，新的值为$ &#123; newValue &#125;`); value = newValue; dep.notify() &#125;, &#125;)&#125;;function nodeToFragment(node, vm) &#123; let flag = document.createDocumentFragment(); let child; while ((child = node.firstChild)) &#123; compile(child, vm); flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; let data = this.data = options.data; observe(data, this); let id = options.el; let dom = nodeToFragment(document.getElementById(id), data); document.getElementById(id).appendChild(dom)&#125;let vm = new Vue(&#123; el: 'app', data: &#123; text: 'example text', &#125;,&#125;); 题目分析：双向绑定是vue的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。 思路分析：3w1h 给出双绑定义 双绑带来的好处 在哪使用双绑 使用方式 扩展：使用细节、原理实现描述 回答范例： vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。 使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好 通常在表单项上使用v-model 原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件 我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。 可能的追问： v-model和sync修饰符有什么区别 自定义组件使用v-model如果想要改变事件名或者属性名应该怎么做 观察输出的渲染函数： 123456789101112// &lt;input type=\"text\" v-model=\"foo\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (foo), expression: \"foo\" &#125;], attrs: &#123; \"type\": \"text\" &#125;, domProps: &#123; \"value\": (foo) &#125;, on: &#123; \"input\": function ($event) &#123; if ($event.target.composing) return; foo = $event.target.value &#125; &#125; &#125;) 123456789101112131415161718192021// &lt;input type=\"checkbox\" v-model=\"bar\"&gt;_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (bar), expression: \"bar\" &#125;], attrs: &#123; \"type\": \"checkbox\" &#125;, domProps: &#123; \"checked\": Array.isArray(bar) ? _i(bar, null) &gt; -1 : (bar) &#125;, on: &#123; \"change\": function ($event) &#123; var $$a = bar, $$el = $event.target, $$c = $$el.checked ? (true) : (false); if (Array.isArray($$a)) &#123; var $$v = null, $$i = _i($$a, $$v); if ($$el.checked) &#123; $$i &lt; 0 &amp;&amp; (bar = $$a.concat([$$v])) &#125; else &#123; $$i &gt; -1 &amp;&amp; (bar = $$a.slice(0, $$i).concat($$a.slice($$i + 1))) &#125; &#125; else &#123; bar = $$c &#125; &#125; &#125; &#125;) 123456789101112131415161718192021222324// &lt;select v-model=\"baz\"&gt;// &lt;option value=\"vue\"&gt;vue&lt;/option&gt;// &lt;option value=\"react\"&gt;react&lt;/option&gt;// &lt;/select&gt;_c('select', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (baz), expression: \"baz\" &#125;], on: &#123; \"change\": function ($event) &#123; var $$selectedVal = Array.prototype.filter.call( $event.target.options, function (o) &#123; return o.selected &#125; ).map( function (o) &#123; var val = \"_value\" in o ? o._value : o.value; return val &#125; ); baz = $event.target.multiple ? $$selectedVal : $$selectedVal[0] &#125; &#125; &#125;, [ _c('option', &#123; attrs: &#123; \"value\": \"vue\" &#125; &#125;, [_v(\"vue\")]), _v(\" \"), _c('option', &#123; attrs: &#123; \"value\": \"react\" &#125; &#125;, [_v(\"react\")])]) Vue-router有几种模式？如何实现呢？ 在vue-router中有两种模式 historyhistory 为 HTML5 Api,提供了丰富的router 相关属性， 比如history.back() 就能轻松的做到页面回退 hashhash router 有一个明显的标志是url 中带有#， 我们可以通过监听url中的hash来进行路由跳转 如何实现 history 在代码实现前，我们先看看history几个api history.pushState 浏览器历史纪录添加记录 history.replaceState 修改浏览器历史纪录中当前纪录 history.popState 当history 发生变化时触发 在结合代码理解: 1234567891011121314151617181920212223242526272829class Routers &#123; contructor() &#123; this.routes = &#123;&#125;; this.listerPopState() &#125; init(path) &#123; history.replaceState(&#123; path: path &#125;, null, path); this.routes[path] &amp;&amp; this.routes[path]() &#125; route(path, callback) &#123; this.routes[path] = callback &#125; push(path) &#123; history.pushState(&#123; path: path &#125;, null, path); this.routes[path] &amp;&amp; this.routes[path]() &#125; listerPopState() &#123; window.addEventListener('popstate', e = &gt; &#123; const path = e.state &amp;&amp; e.state.path; this.routers[path] &amp;&amp; this.routers[path]() &#125;) &#125;&#125;window.VueRouter = new Routers();VueRouter.route('/', () = &gt; console.log('JS')) VueRouter.route('/detail', () = &gt; console.log('JS每日一题')) VueRouter.push('/detail') hash router 上面说过我们可以通过监听url中的hash来进行路由跳转 结合代码理解: 123456789101112131415161718class Routers &#123; constructor() &#123; this.routes = &#123;&#125;; this.currentUrl = ''; this.refresh = this.refresh.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false) &#125; route(path, callback) &#123; this.routes[path] = callback &#125; push() &#123; this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl] &amp;&amp; this.routes[this.currentUrl]() &#125;&#125;window.VueRouter = new Routers();VueRouter.route('/', () = &gt; console.log('JS')) VueRouter.route('/detail', () = &gt; console.log('JS每日一题')) VueRouter.push('/detail') 工作中不必太过纠结使用哪种模式，hash模式url中会带有#号，破坏url整体的美观性, history 需要服务端支持rewrite, 否则刷新会出现404现象 vue中keepalive怎么理解？ 说在前面: keep-alive是vue源码中实现的一个组件, 感兴趣的可以研究源码 https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js 什么是keepalive 我们平时开发中, 总有部分组件没有必要多次init, 我们需要将组件进行持久化，使组件状态维持不变，在下一次展示时， 也不会进行重新init keepalive音译过来就是保持活着, 所以在vue中我们可以使用keepalive来进行组件缓存 基本使用 12// 被keepalive包含的组件会被进行缓存&lt; keep - alive &gt; &lt; component / &gt; &lt; /keep-alive&gt; 上面提到被keepalive包含的组件不会被再次init，也就意味着不会重走生命周期函数, 但是平常工作中很多业务场景是希望我们缓存的组件在再次渲染的能做一些事情,vue为keepalive提供了两个额外的hook activated 当keepalive包含的组件再次渲染的时候触发 deactivated 当keepalive包含的组件销毁的时候触发 注: 2.1.0 版本后keepalive包含但被exclude排除的组件不会有以上两个hook 参数 keepalive可以接收3个属性做为参数进行匹配对应的组件进行缓存 include 包含的组件 exclude 排除的组件 max 缓存组件的最大值 其中include,exclude可以为字符，数组，以及正则表达式max 类型为字符或者数字 代码理解 12345678910111213141516// 只缓存组件name为a或者b的组件&lt;keep-alive include = \"a,b\" &gt; &lt;component: is = \"currentView\" /&gt; &lt;/keep-alive&gt;// 组件名为c的组件不缓存&lt;keep-alive exclude=\"c\"&gt; &lt;component:is=\"currentView\"/ &gt; &lt;/keep-alive&gt;// 如果同时使用include,exclude,那么exclude优先于include， 下面的例子也就是只缓存a组件&lt;keep-alive include=\"a,b\"exclude=\"b\"&gt; &lt;component:is=\"currentView\"/ &gt;&lt;/keep-alive&gt;// 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件&lt;keep-alive exclude=\"c\"max=\"5\"&gt; &lt;component:is=\"currentView\"/ &gt; &lt;/keep-alive&gt; 配合router使用 12345678910111213141516171819202122&lt;!-- template --&gt;// 意思就是$router.meta.keepAlive值为真是将组件进行缓存&lt;keep-alive&gt; &lt;router-view v-if=\"$router.meta.keepAlive\"&gt;&lt;/router-view&gt;&lt;router-view v-if=\"!$router.meta.keepAlive\"&gt;&lt;/router-view&gt;//router配置new Router(&#123; routes: [&#123; name: 'a', path: '/a', component: A, meta: &#123; keepAlive: true &#125; &#125;, &#123; name: 'b', path: '/b', component: B &#125;]&#125;) 总结 keepalive是一个抽象组件，缓存vnode，缓存的组件不会被mounted，为此提供activated 和 deactivated 钩子函数, 使用props max 可以控制缓存组件个数 Vue.use中都发生了什么？ 源码地址: https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js 定义 vue.use()往全局注入一个插件，供全局真接使用, 不需要单独引用 代码理解: 12345678import Router from 'vue-router'// 入口文件全局注入vue-router, 从而可以在全局使用this.$routeVue.use(Router)如果不使用vue.use那么需在组件中使用都得单独引入// a.vueimport Router from 'vue-router'// b.vueimport Router from 'vue-router' 理解了其基本使用及作用，我们来看一下vue.use中都发生了什么 源码很少，所以直接摘抄了 123456789101112131415161718192021222324Vue.use = function(plugin: Function | Object) &#123; // flow语法, 检测参数是否是函数或对象 // 拿到已安装插件列表 const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) // 如果已经安装，直接跳出方法 if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this &#125; // additional parameters // 取vue.use() 传入的参数 const args = toArray(arguments, 1) // 将vue对象填充到第一位, 最后的结构为[vue,arg1,arg2,...] args.unshift(this) // 判断插件是否有install方法，如果有执行install方法，如果没有直接把插件当install执行 if (typeof plugin.install === 'function') &#123; plugin.install.apply(plugin, args) &#125; else if (typeof plugin === 'function') &#123; plugin.apply(null, args) &#125; // 注册完成填充至已安装列表，保证每个插件只安装一次 installedPlugins.push(plugin) return this&#125; 结合代码理解 1234567891011121314151617181920212223// 代码摘抄自elementui入口文件实现上就是在install中执行了全局注册的操作// index.jsconst install = function(Vue, opts = &#123;&#125;) &#123; locale.use(opts.locale); locale.i18n(opts.i18n); components.forEach(component = &gt; &#123; Vue.component(component.name, component) &#125;);...&#125;exportdefault &#123; version: '2.5.4', locale: locale.use, i18n: locale.i18n, install, CollapseTransition, Loading, ...&#125;// main.jsimport demo from './idnex'vue.use(demo) 总结 vue.use()为注册全局插件所用，接收函数或者一个包含install属性的对象为参数，如果参数带有install就执行install, 如果没有就直接将参数当install执行, 第一个参数始终为vue对象, 注册过的插件不会重新注册 简述一下Vue.js的template编译过程？ 看一下整个流程 从上图中我们可以看到compile是从mount后开始进行中, 整体逻辑分为三个部分 解析器(parse) - 将 模板字符串 转换成 elementASTs 优化器(optimize) - 对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化 代码生成器(generate) - 使用 elementASTs 生成 render 函数代码字符串 开始前先解释一下AST AST(abstract syntax tree 抽象语法树), 是源代码的抽象语法结构的树状表现形式 从代码上简单理解一下 1234567891011121314151617181920212223&lt; div class = \"name\" &gt; JS每日一题 &lt; /div&gt;//转成AST后会得到如下格式[&#123; \"type\": \"tag\", \"name\": \"div\", \"attribs\": &#123; \"class\": \"name\" &#125;, \"children\": [&#123; \"data\": \"JS每日一题\", \"type\": \"text\", \"next\": null, \"startIndex\": 18, \"prev\": null, \"parent\": \"[Circular ~.0]\", \"endIndex\": 24 &#125;], \"next\": null, \"startIndex\": 0, \"prev\": null, \"parent\": null, \"endIndex\": 30&#125;] AST会经过generate得到render函数，render的返回值是VNode VNode的源码可以见 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/core/vdom/vnode.js 解析器(parse) 源码地址 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/parser/index.js parse 的目标是把 template 模板字符串转换成 AST 树，它是一种用 JavaScript 对象的形式来描述整个模板。那么整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的 优化器(optimize) 源码地址 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/optimizer.js 通过 optimize 把整个 AST 树中的每一个 AST 元素节点标记了 static 和 staticRoot, optimize 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变 代码生成器(generate) 源码地址 https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/codegen/index.js 把优化后的 AST 树转换成可执行的代码 总结 首先通过parse将template解析成AST,其次optimize对解析出来的AST进行标记，最后generate将优化后的AST转换成可执行的代码 Vue中的nextTick如何理解，它是干什么的？ 在vue中，数据发生变化之后DOM并不会立即变化，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新 代码理解 12345this.name = 'JS每日一题' // 如这个绑定在某一个DOM元素上console.log(this.$el.textContent) // 这时DOM还没有更新,所以不会得到文字JS每日一题this.$nextTick(() = &gt;console.log(this.$el.textContent)) // nextTick 是在DOM更新后执行，这里打印JS每日一题 nextTick什么情况下会触发 在同一事件循环中的数据变化后，DOM更新完成, 执行nextTick(callback)内的回调 对事件循环不理解的可以点这里 vue中nextTick的实现 源码地址 https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js 1234567891011121314151617181920212223242526272829303132333435363738function flushCallbacks() &#123; pending = false // 复制一份callbacks const copies = callbacks.slice(0) // 清空callbacks callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; // 顺序执行nexttick传入的回调 copies[i]() &#125;&#125;exportfunction nextTick(cb ? :Function, ctx ? :Object) &#123; let _resolve // 将回调压入callbacks callbacks.push(() = &gt;&#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch(e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true // timerFunc的源码较多，大致意思就是根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数 (见上面的flushCallbacks方法) timerFunc() &#125; // 如果nextTick不传cb,就为nextTick提供一个promise调用 如: nextTick().then(()=&gt; &#123;&#125;) if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve = &gt;&#123; _resolve = resolve &#125;) &#125;&#125; 总结 数据的变化到 DOM 的重新渲染是一个异步过程, 我们必须在 nextTick 后执行DOM相关的操作 这道题考查大家对vue异步更新队列的理解，有一定深度，如果能够很好回答此题，对面试效果有极大帮助 答题思路： nextTick是啥？下一个定义 为什么需要它呢？用异步更新队列实现原理解释 我再什么地方用它呢？抓抓头，想想你在平时开发中使用它的地方 下面介绍一下如何使用nextTick 最后能说出源码实现就会显得你格外优秀 先看看官方定义 Vue.nextTick( [callback, context] ) 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 1234567&gt;// 修改数据&gt;vm.msg = 'Hello'&gt;// DOM 还没有更新&gt;Vue.nextTick(function () &#123;&gt;// DOM 更新了&gt;&#125;)&gt; 回答范例： nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。 比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。 nextTick实现原理? 此题属于原理题目，能够体现面试者对vue理解深度，答好了会加分很多。 答题思路： 此题实际考查vue异步更新策略 说出vue是怎么通过异步、批量的方式更新以提高性能的 最后把源码中实现说一下 回答范例： vue有个批量、异步更新策略，数据变化时，vue开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。然后在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 官方文档在这里 源码中，修改一个数据，组件对应的watcher会尝试入队: 1queue.push(watcher) 并使用nextTick方法添加一个flushSchedulerQueue回调 1nextTick(flushSchedulerQueue) flushSchedulerQueue被加入callbacks数组 123456789callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) // cb就是加入的回调 &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; &#125;) 然后以异步方式启动 1234if (!pending) &#123; pending = true timerFunc()&#125; timerFunc的异步主要利用Promise等微任务方式实现 1234567891011let timerFuncif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() // timerFunc利用p.then向微任务队列添加一个flushCallbacks // 会异步调用flushCallbacks timerFunc = () =&gt; &#123; p.then(flushCallbacks) &#125; isUsingMicroTask = true&#125; flushCallbacks遍历callbacks，执行里面所有回调 12345678function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 其中就有前面加入的flushSchedulerQueue，它主要用于执行queue中所有watcher的run方法，从而使组件们更新 1234for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] watcher.run()&#125; 可能的追问 你平时什么时候会用到nextTick？","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"},{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"vue3的新特性","slug":"Vue/vue3的新特性","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-11T09:17:52.241Z","comments":true,"path":"/posts/86248f8a.html","link":"","permalink":"https://yangyfeng.github.io/posts/86248f8a.html","excerpt":"六大亮点 vue3官方文档 Performance：性能更比Vue 2.0强。 Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。 Composition API：组合API Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念” Better TypeScript support：更优秀的 Ts 支持 Custom Renderer API：暴露了自定义渲染API","text":"六大亮点 vue3官方文档 Performance：性能更比Vue 2.0强。 Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。 Composition API：组合API Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念” Better TypeScript support：更优秀的 Ts 支持 Custom Renderer API：暴露了自定义渲染API 1、Performance 重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。 编译模板的优化。 更高效的组件初始化。 update性能提高 1.3~2 倍。 SSR速度提高了 2~3 倍。 2、Tree shaking support 可以将无用模块“剪辑”，仅打包需要的（比如v-model,，用不到就不会打包）。 一个简单“HelloWorld”大小仅为：13.5kb，11.75kb，仅Composition API。 包含运行时完整功能：22.5kb，拥有更多的功能，却比Vue 2更迷你。 很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入 3、Composition API 与React Hooks 类似的东西，实现方式不同。 可与现有的 Options API一起使用 灵活的逻辑组合与复用 vue 3的响应式模块可以和其他框架搭配使用 混入(mixin) 将不再作为推荐使用， Composition API可以实现更灵活且无副作用的复用代码。 Composition API 文档地址 Composition API包含了六个主要API 4、Fragment Fragment翻译为：“碎片” 不再限于模板中的单个根节点 render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。 Just works &lt;Teleport&gt; &lt;Suspense&gt; Suspense翻译为：“悬念” 可在嵌套层级中等待嵌套的异步依赖项 支持async setup() 支持异步组件 虽然React 16引入了Suspense，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。 Vue 3 的&lt;Suspense&gt;更加轻量： 仅 5%应用能感知运行时的调度差异，综合考虑下，Vue3 的&lt;Suspense&gt; 没和 React 一样做运行调度处理 5、更好的TypeScript支持 Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示 JavaScript和TypeScript中的 API 是相同的。事实上，代码也基本相同 支持TSX class组件还会继续支持，但是需要引入vue-class-component@next，该模块目前还处在 alpha 阶段。 还有Vue 3 + TypeScript 插件正在开发，有类型检查，自动补全等功能 6、Custom Renderer API：自定义渲染器 API 正在进行NativeScript Vue集成 用户可以尝试WebGL自定义渲染器，与普通 Vue 应用程序一起使用（Vugel）。 意味着以后可以通过 vue， Dom 编程的方式来进行 webgl 编程 。 感兴趣可以看这里：Getting started vugel 剩余工作 全家桶插件组件过渡到vue3.+ 要点 新工具：vite（法语 “快”） 地址：https://github.com/vuejs/vite 一个简易的http服务器，无需webpack编译打包，根据请求的Vue文件，直接发回渲染，且支持热更新（非常快）","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"}]},{"title":"如何使用JavaScript实现纯前端读取和导出excel文件","slug":"其他插件/如何使用JavaScript实现纯前端读取和导出excel文件","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-11T09:17:50.214Z","comments":true,"path":"/posts/ce0a6a78.html","link":"","permalink":"https://yangyfeng.github.io/posts/ce0a6a78.html","excerpt":"1、js-xlsx 介绍由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。 官方github：https://github.com/SheetJS/js-xlsx 本文配套demo在线演示地址：http://demo.haoji.me/2017/02/08-js-xlsx/","text":"1、js-xlsx 介绍由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。 官方github：https://github.com/SheetJS/js-xlsx 本文配套demo在线演示地址：http://demo.haoji.me/2017/02/08-js-xlsx/ 1.1 兼容性 1.2. 如何使用dist目录下有很多个JS文件，一般情况下用xlsx.core.min.js就够了，xlsx.full.min.js则是包含了所有功能模块。 &lt;script type=&quot;text/javascript&quot; src=&quot;./js/xlsx.core.min.js&quot;&gt;&lt;/script&gt; 2、读取excel读取excel主要是通过XLSX.read(data, {type: type});方法来实现，返回一个叫WorkBook的对象，type主要取值如下： base64: 以base64方式读取； binary: BinaryString格式(byte n is data.charCodeAt(n)) string: UTF8编码的字符串； buffer: nodejs Buffer； array: Uint8Array，8位无符号数组； file: 文件的路径（仅nodejs下支持）； 2.1 获取workbook对象读取本地文件 12345678910// 读取本地excel文件function readWorkbookFromLocalFile(file, callback) &#123; var reader = new FileReader(); reader.onload = function(e) &#123; var data = e.target.result; var workbook = XLSX.read(data, &#123;type: 'binary'&#125;); if(callback) callback(workbook); &#125;; reader.readAsBinaryString(file);&#125; 读取网络文件 1234567891011121314// 从网络上读取某个excel文件，url必须同域，否则报错function readWorkbookFromRemoteFile(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = function(e) &#123; if(xhr.status == 200) &#123; var data = new Uint8Array(xhr.response) var workbook = XLSX.read(data, &#123;type: 'array'&#125;); if(callback) callback(workbook); &#125; &#125;; xhr.send();&#125; 读取workbook 1234567891011// 读取 excel文件function outputWorkbook(workbook) &#123; var sheetNames = workbook.SheetNames; // 工作表名称集合 sheetNames.forEach(name =&gt; &#123; var worksheet = workbook.Sheets[name]; // 只能通过工作表名称来获取指定工作表 for(var key in worksheet) &#123; // v是读取单元格的原始值 console.log(key, key[0] === '!' ? worksheet[key] : worksheet[key].v); &#125; &#125;);&#125; 根据!ref确定excel的范围，再根据!merges确定单元格合并（如果有），最后输出整个table，比较麻烦，幸运的是，插件自身已经写好工具类XLSX.utils给我们直接使用，无需我们自己遍历，工具类输出主要包括如下： 有些不常用，常用的主要是： XLSX.utils.sheet_to_csv：生成CSV格式 XLSX.utils.sheet_to_txt：生成纯文本格式 XLSX.utils.sheet_to_html：生成HTML格式 XLSX.utils.sheet_to_json：输出JSON格式 常用的主要是sheet_to_csv或者sheet_to_html，转csv的话会忽略格式、单元格合并等信息，所以复杂表格可能不适用。转html的话会保留单元格合并，但是生成的是代码，而不是，需要对表格进行一些定制时不太方便，所以具体还是要视情况来采用合适的工具类。 这里写一个采用转csv方式输出结果的简单示例，可点击这里查看在线DEMO： 1234567891011121314151617181920212223242526272829var csv = XLSX.utils.sheet_to_csv(worksheet); document.getElementById('result').innerHTML = csv2table(csv);&#125;// 将csv转换成简单的表格，会忽略单元格合并，在第一行和第一列追加类似excel的索引function csv2table(csv)&#123; var html = '&lt;table&gt;'; var rows = csv.split('\\n'); rows.pop(); // 最后一行没用的 rows.forEach(function(row, idx) &#123; var columns = row.split(','); columns.unshift(idx+1); // 添加行索引 if(idx == 0) &#123; // 添加列索引 html += '&lt;tr&gt;'; for(var i=0; i&lt;columns.length; i++) &#123; html += '&lt;th&gt;' + (i==0?'':String.fromCharCode(65+i-1)) + '&lt;/th&gt;'; &#125; html += '&lt;/tr&gt;'; &#125; html += '&lt;tr&gt;'; columns.forEach(function(column) &#123; html += '&lt;td&gt;'+column+'&lt;/td&gt;'; &#125;); html += '&lt;/tr&gt;'; &#125;); html += '&lt;/table&gt;'; return html;&#125; 导出excel导出分为2种，一种是基于现有excel修改，一种是全新生成，前者比较简单，我们这里着重讲后者。 自己手写代码生成 导出excel文件，主要是如何生成一个sheet，我们这里写一个最简单的csv转excel示例 123456789101112131415161718192021222324252627282930313233343536373839// csv转sheet对象function csv2sheet(csv) &#123; var sheet = &#123;&#125;; // 将要生成的sheet csv = csv.split('\\n'); csv.forEach(function(row, i) &#123; row = row.split(','); if(i == 0) sheet['!ref'] = 'A1:'+String.fromCharCode(65+row.length-1)+(csv.length-1); row.forEach(function(col, j) &#123; sheet[String.fromCharCode(65+j)+(i+1)] = &#123;v: col&#125;; &#125;); &#125;); return sheet;&#125;// 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载function sheet2blob(sheet, sheetName) &#123; sheetName = sheetName || 'sheet1'; var workbook = &#123; SheetNames: [sheetName], Sheets: &#123;&#125; &#125;; workbook.Sheets[sheetName] = sheet; // 生成excel的配置项 var wopts = &#123; bookType: 'xlsx', // 要生成的文件类型 bookSST: false, // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性 type: 'binary' &#125;; var wbout = XLSX.write(workbook, wopts); var blob = new Blob([s2ab(wbout)], &#123;type:\"application/octet-stream\"&#125;); // 字符串转ArrayBuffer function s2ab(s) &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF; return buf; &#125; return blob;&#125; 拿到上面的blob对象就可以直接下载了，参考我之前在JS弹出下载对话框里面封装好的openDownloadDialog方法： 1234567891011121314151617181920212223/** * 通用的打开下载对话框方法，没有测试过具体兼容性 * @param url 下载地址，也可以是一个blob对象，必选 * @param saveName 保存文件名，可选 */function openDownloadDialog(url, saveName)&#123; if(typeof url == 'object' &amp;&amp; url instanceof Blob) &#123; url = URL.createObjectURL(url); // 创建blob地址 &#125; var aLink = document.createElement('a'); aLink.href = url; aLink.download = saveName || ''; // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效 var event; if(window.MouseEvent) event = new MouseEvent('click'); else &#123; event = document.createEvent('MouseEvents'); event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); &#125; aLink.dispatchEvent(event);&#125; 所以，最终下载实现如下： 123456// 传入csv，执行后就会弹出下载框function exportExcel(csv) &#123; var sheet = csv2sheet(csv); var blob = sheet2blob(sheet); openDownloadDialog(blob, '导出.xlsx')；&#125; 处理单元格合并 一般来说，前端生成excel而不是csv最主要目的都是为了解决csv不能实现单元格合并的问题，要不然直接导出csv文件就好了，何必引入几百kb的插件 123456789101112var aoa = [ ['主要信息', null, null, '其它信息'], // 特别注意合并的地方后面预留2个null ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()]];var sheet = XLSX.utils.aoa_to_sheet(aoa);sheet['!merges'] = [ // 设置A1-C1的单元格合并 &#123;s: &#123;r: 0, c: 0&#125;, e: &#123;r: 0, c: 2&#125;&#125;];openDownloadDialog(sheet2blob(sheet), '单元格合并示例.xlsx'); 需要注意的地方就是被合并的单元格要用null预留出位置，否则后面的内容（本例中是第四列其它信息）会被覆盖。 | 原文地址：https://www.cnblogs.com/liuxianan/p/js-excel.html","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"excel","slug":"excel","permalink":"https://yangyfeng.github.io/blogpost/tags/excel/"},{"name":"插件","slug":"插件","permalink":"https://yangyfeng.github.io/blogpost/tags/插件/"}]},{"title":"手写简易版vue，minivue的实现","slug":"Vue/手写简易版vue，minivue的实现","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-11T09:17:53.446Z","comments":true,"path":"/posts/d3643a0f.html","link":"","permalink":"https://yangyfeng.github.io/posts/d3643a0f.html","excerpt":"基于vue2.* vue采取数据劫持，配合观察者模式，通过Object.defineProperty() 来劫持各个属性的setter和getter，在数据变动时，发布消息给依赖收集器dep，去通知观察者，做出对应的回调函数，去更新视图。（也就是在getter中收集依赖，在setter中通知依赖更新。 其实vue主要就是整合Observer，compile和watcher三者，通过Observer来监听 model数据变化表，通过compile来解析编译模板指令，最终利用Watcher搭起observer 和compile的通信桥梁，达到数据变化=&gt;视图变化，视图变化=&gt;数据变化的双向绑定效果。 下面来一张图↓ 这个流程图已经非常形象深刻的表达了vue的运行模式，当你理解了这个流程，再去看vue源码时就会容易很多了 声明一下，下面的代码只简单实现了vue里的 v-model（数据的双向绑定） v-bind/v-on v-text/v-html 没有实现虚拟dom，采用文档碎片（createDocumentFragment）代替 数据只劫持了Object，数组Array没有做处理 代码大致结构如下，初步定义了6个类","text":"基于vue2.* vue采取数据劫持，配合观察者模式，通过Object.defineProperty() 来劫持各个属性的setter和getter，在数据变动时，发布消息给依赖收集器dep，去通知观察者，做出对应的回调函数，去更新视图。（也就是在getter中收集依赖，在setter中通知依赖更新。 其实vue主要就是整合Observer，compile和watcher三者，通过Observer来监听 model数据变化表，通过compile来解析编译模板指令，最终利用Watcher搭起observer 和compile的通信桥梁，达到数据变化=&gt;视图变化，视图变化=&gt;数据变化的双向绑定效果。 下面来一张图↓ 这个流程图已经非常形象深刻的表达了vue的运行模式，当你理解了这个流程，再去看vue源码时就会容易很多了 声明一下，下面的代码只简单实现了vue里的 v-model（数据的双向绑定） v-bind/v-on v-text/v-html 没有实现虚拟dom，采用文档碎片（createDocumentFragment）代替 数据只劫持了Object，数组Array没有做处理 代码大致结构如下，初步定义了6个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300// 定义Vue类class Vue &#123; constructor(options) &#123; // 把数据对象挂载到实例上 this.$el = options.el; this.$data = options.data; this.$options = options; // 如果有需要编译的模板 if (this.$el) &#123; // 数据劫持 就是把对象的所有属性 改成get和set方法 new Observer(this.$data); // 用数据和元素进行编译 new Compiler(this.$el, this); // 3. 通过数据代理实现 主要给methods里的方法this直接访问data this.proxyData(this.$data); &#125; &#125; //用vm代理vm.$data proxyData(data)&#123; for(let key in data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return data[key]; &#125;, set(newVal)&#123; data[key] = newVal; &#125; &#125;) &#125; &#125;&#125; // 编译html模板class Compiler &#123; // vm就是vue对象 constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; if(this.el)&#123; // 如果该元素能获取到，我们开始编译 // 1.把真实的dom放到内存中fragment文档碎片 let fragment = this.node2fragment(this.el); // console.log(fragment); // 2.编译 =&gt; 提取想要的元素节点 v-model和文本节点&#123;&#123;&#125;&#125; this.compile(fragment); // 3.把编译好的fragment再放到页面里 this.el.appendChild(fragment); &#125; &#125; /* 一些辅助方法 */ isElementNode(node) &#123; return node.nodeType === 1; &#125; isDirective(name) &#123; // 判断是不是指令 return name.includes('v-'); &#125; isEventName(attrName)&#123; // 判断是否@开头 return attrName.startsWith('@'); &#125; isBindName(attrName)&#123; // 判断是否:开头 return attrName.startsWith(':'); &#125; /* 核心方法区 */ node2fragment(el)&#123; // 需要将el中的内容全部放到内存中 // 文档碎片 let fragment = document.createDocumentFragment(); let firstChild; while(firstChild = el.firstChild)&#123; fragment.appendChild(firstChild); &#125; return fragment; // 内存中的节点 &#125; compile(fragment)&#123; // 1.获取子节点 let childNodes = fragment.childNodes; // 2.递归循环编译 [...childNodes].forEach(node=&gt;&#123; if(this.isElementNode(node))&#123; this.compileElement(node); // 这里需要编译元素 this.compile(node); // 是元素节点，还需要继续深入的检查 &#125;else&#123; // 文本节点 // 这里需要编译文本 this.compileText(node); &#125; &#125;); &#125; compileElement(node)&#123; // 编译元素 // 带v-model v-html ... let attrs = node.attributes; // 取出当前节点的属性 // attrs是类数组，因此需要先转数组 [...attrs].forEach(attr=&gt;&#123; // console.log(attr); // type=\"text\" v-model=\"content\" v-on:click=\"handleclick\" @click=\"\"... let attrName = attr.name; // type v-model v-on:click @click if(this.isDirective(attrName))&#123; // 判断属性名字是不是包含v- // 取到对应的值放到节点中 let expr = attr.value; // content/变量 handleclick/方法名 // console.log(expr) let [, type] = attrName.split('-'); // model html on:click let [compileKey, detailStr] = type.split(':'); // 处理 on: bind: // node this.vm.$data expr CompileUtil[compileKey](node, this.vm, expr, detailStr); // 删除有指令的标签属性 v-text v-html等，普通的value等原生html标签不必删除 node.removeAttribute('v-' + type); &#125;else if(this.isEventName(attrName))&#123; // 如果是事件处理 @click='handleClick' let [, detailStr] = attrName.split('@'); CompileUtil['on'](node, this.vm, attr.value, detailStr); // 删除有指令的标签属性 node.removeAttribute('@' + detailStr); &#125;else if(this.isBindName(attrName))&#123; // 如果是:开头，动态绑定值 let [, detailStr] = attrName.split(':'); CompileUtil['bind'](node, this.vm, attr.value, detailStr); // 删除有指令的标签属性 node.removeAttribute(':' + detailStr); &#125; &#125;) &#125; compileText(node)&#123; // 编译文本 // 带&#123;&#123;&#125;&#125; let expr = node.textContent; // 取文本中的内容 let reg = /\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g; // &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; if(reg.test(expr))&#123; // node this.$data // console.log(expr); // &#123;&#123;content&#125;&#125; CompileUtil['text'](node, this.vm, expr); &#125; &#125;&#125; // 编译模版具体执行const CompileUtil = &#123; getVal(vm, expr)&#123; // 获取实例上对应的数据 expr = expr.split('.'); // [animal,dog]/[animal,cat] return expr.reduce((prev, next)=&gt;&#123; // vm.$data. return prev[next]; &#125;, vm.$data) &#125;, // 这里实现input输入值变化时 修改绑定的v-model对应的值 setVal(vm, expr, inputValue)&#123; // [animal,dog] let exprs = expr.split('.'), len = exprs.length; exprs.reduce((data,currentVal, idx)=&gt;&#123; if(idx===len-1)&#123; data[currentVal] = inputValue; &#125;else&#123; return data[currentVal] &#125; &#125;, vm.$data) &#125;, getTextVal(vm, expr)&#123; // 获取编译文本后的结果 return expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; // console.log(args); // [\"&#123;&#123;title&#125;&#125;\", \"title\", 0, \"&#123;&#123;title&#125;&#125;\"] // [\"&#123;&#123; animal.dog &#125;&#125;\", \" animal.dog \", 0, \"&#123;&#123; animal.dog &#125;&#125;-vs-&#123;&#123; animal.cat &#125;&#125;\"] return this.getVal(vm, args[1].trim()); &#125;); &#125;, text(node, vm, expr)&#123; // 文本处理 let updateFn = this.updater['textUpdater']; // &#123;&#123;content&#125;&#125; =&gt; \"welcome to animal world\" let value; if(expr.indexOf('&#123;&#123;')!==-1)&#123; // dom里直接写&#123;&#123;&#125;&#125;的时候 value = this.getTextVal(vm, expr); // &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; 对多个值进行监控 expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; new Watcher(vm, args[1].trim(), ()=&gt;&#123; // 如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容 updateFn &amp;&amp; updateFn(node, this.getTextVal(vm, expr)); &#125;) &#125;); &#125;else&#123; // v-text 的时候 value = this.getVal(vm, expr); new Watcher(vm, expr, (newVal)=&gt;&#123; // 当值变化后会调用cb 将新值传递过来 updateFn &amp;&amp; updateFn(node, newVal); &#125;); &#125; updateFn &amp;&amp; updateFn(node, value); &#125;, html(node, vm, expr) &#123; // let updateFn = this.updater['htmlUpdater']; updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)); &#125;, model(node, vm, expr)&#123; // 输入框处理 let updateFn = this.updater['modelUpdater']; // console.log(this.getVal(vm, expr)); // \"welcome to animal world\" // 这里应该加一个监控 数据变化了 应该调用这个watch的callback new Watcher(vm, expr, (newVal)=&gt;&#123; // 当值变化后会调用cb 将新值传递过来 updateFn &amp;&amp; updateFn(node, newVal); &#125;); // 视图 =&gt; 数据 =&gt; 视图 node.addEventListener('input', (e)=&gt;&#123; this.setVal(vm, expr, e.target.value); &#125;) updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)); &#125;, on(node, vm, expr, detailStr) &#123; let fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr]; node.addEventListener(detailStr, fn.bind(vm), false); &#125;, bind(node, vm, expr, detailStr)&#123; // v-bind:src='...' =&gt; href='...' node.setAttribute(detailStr, expr); &#125;, updater:&#123; // 文本更新 textUpdater(node, value)&#123; node.textContent = value; &#125;, // html更新 htmlUpdater(node, value)&#123; node.innerHTML = value; &#125;, // 输入框更新 modelUpdater(node, value)&#123; node.value = value; &#125; &#125;&#125; // 观察者class Observer&#123; constructor(data)&#123; this.observe(data); &#125; observe(data)&#123; // 要对data数据原有属性改成set和get的形式 if(!data || typeof data !== 'object')&#123; // 不是对象就不劫持了 return &#125; // 要劫持 先获取到data的key和value Object.keys(data).forEach(key=&gt;&#123; this.defineReactive(data, key, data[key]); // 劫持 this.observe(data[key]); // 深度递归劫持 &#125;) &#125; // 定义响应式 defineReactive(obj, key, value)&#123; let dep = new Dep(); // 在获取某个值的时候 Object.defineProperty(obj, key, &#123; enumerable: true, // 可枚举 configurable: true, // 可修改 get()&#123; // 当取值的时候 // 订阅数据变化时，往Dev中添加观察者 Dep.target &amp;&amp; dep.addSub(Dep.target); return value; &#125;, // 采用箭头函数在定义时绑定this的定义域 set: (newVal)=&gt;&#123; // 更改data里的属性值的时候 if(value === newVal) return; this.observe(newVal); // 如果设置新值是对象，劫持 value = newVal; // 通知watcher数据发生改变 dep.notify(); &#125; &#125;) &#125;&#125; // 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法class Watcher&#123; constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; // 先获取一下老的值 this.oldVal = this.getOldVal(); &#125; // 获取实例上对应的老值 getOldVal()&#123; // 在利用getValue获取数据调用getter()方法时先把当前观察者挂载 Dep.target = this; const oldVal = CompileUtil.getVal(this.vm, this.expr); // 挂载完毕需要注销，防止重复挂载 (数据一更新就会挂载) Dep.target = null; return oldVal; &#125; // 对外暴露的方法 通过回调函数更新数据 update()&#123; const newVal = CompileUtil.getVal(this.vm, this.expr); if(newVal !== this.oldVal)&#123; this.cb(newVal); // 对应watch的callback &#125; &#125;&#125; // Dep类存储watcher对象，并在数据变化时通知watcherclass Dep&#123; constructor(arg) &#123; // 订阅的数组 this.subs = [] &#125; addSub(watcher)&#123; this.subs.push(watcher); &#125; notify()&#123; // 数据变化时通知watcher更新 this.subs.forEach(w=&gt;w.update()); &#125;&#125; vue源码解析","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"}]},{"title":"vue响应式原理源码剖析","slug":"Vue/vue响应式原理源码剖析","date":"2020-11-26T02:37:00.000Z","updated":"2020-12-11T09:14:04.788Z","comments":true,"path":"/posts/b0d42301.html","link":"","permalink":"https://yangyfeng.github.io/posts/b0d42301.html","excerpt":"vue2更新到vue3对数据的响应式，做了重大的调整。 先回顾下vue2的响应式怎么做的vue2对象响应式原理：Object.defineProperty() vue2数组响应式原理：覆盖可以修改数组7个方法，从数组原型中获取这7个方法，并覆盖为可以发送更新通知的函数实现","text":"vue2更新到vue3对数据的响应式，做了重大的调整。 先回顾下vue2的响应式怎么做的vue2对象响应式原理：Object.defineProperty() vue2数组响应式原理：覆盖可以修改数组7个方法，从数组原型中获取这7个方法，并覆盖为可以发送更新通知的函数实现 对象的属性劫持1234567891011121314151617181920// 具体定义指定的key拦截器function defineReactive(obj, key, val) &#123; // 递归遍历 observe(val) // val实际上是一个闭包 Object.defineProperty(obj, key, &#123; get() &#123; return val &#125;, set(newVal) &#123; if (newVal !== val) &#123; // val可能是对象 observe(newVal) notifyUpdate() val = newVal &#125; &#125; &#125;)&#125; 数组属性的劫持1234567891011121314// 修改数组的7个api的原型const originalProto = Array.prototypeconst arrayProto = Object.create(originalProto);['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].forEach( method =&gt; &#123; arrayProto[method] = function() &#123; // 做之前的事情 originalProto[method].apply(this, arguments) // 通知更新 notifyUpdate() &#125; &#125;) 数据响应123456789101112131415161718// 思想：递归遍历传入obj，定义每个属性的拦截function observe(obj) &#123; if (typeof obj !== 'object' || obj == null) &#123; return obj &#125; // 判断类型：如果是数组则替换它的原型 if (Array.isArray(obj)) &#123; Object.setPrototypeOf(obj, arrayProto) &#125; else &#123; const keys = Object.keys(obj) for (let index = 0; index &lt; keys.length; index++) &#123; const key = keys[index] // 对obj每个key执行拦截 defineReactive(obj, key, obj[key]) &#125; &#125;&#125; 跟新处理123456789101112131415function notifyUpdate() &#123; console.log('页面更新！')&#125;const data = &#123; foo: 'foo', bar: &#123; a: 1 &#125;, tua: [1, 2, 3] &#125;observe(data)// 1.普通更新// data.foo = 'foooooooo'// 2.嵌套属性更新// data.bar.a = 10// data.dong = 'lalala' // no ok// 3.赋值是对象// data.bar = &#123;a:10&#125;// 4.数组// data.tua.push(4) 以上方式会出现什么问题呢？ 需要响应化的数据较大，递归遍历性能不好、消耗较大 新增或删除属性无法监听 数组响应化需要额外实现 修改语法有限制 所以在vue3跟新做了更加优化方案 vue3的响应式原理的实现vue3响应式原理：利用Proxy对象对数据拦截 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// WeakMap 弱引用的方式缓存代理数据和原始数据const toProxy = new WeakMap() // 形如 obj: observedconst toRaw = new WeakMap() // 形如 observed: objfunction isObject(obj) &#123; return typeof obj === 'object' || obj === null&#125;function hasOwn(obj, key) &#123; return obj.hasOwnProperty(key)&#125;// 响应对象数据function reactive(obj) &#123; if (!isObject(obj)) &#123; return obj &#125; // 查找缓存 if (toProxy.has(obj)) &#123; return toProxy.get(obj) &#125; // 传入obj就是代理对象,此时不用反复代理 if (toRaw.has(obj)) &#123; return obj &#125; const observed = new Proxy(obj, &#123; get(target, key, receiver) &#123; // 访问 const res = Reflect.get(target, key, receiver) console.log(`获取$&#123;key&#125;: $&#123;res&#125;`) // 依赖收集 track(target, key) return isObject(res) ? reactive(res) : res &#125;, set(target, key, value, receiver) &#123; // 新增和更新 const hadKey = hasOwn(target, key) // ADD 或 SET const oldVal = target[key] const res = Reflect.set(target, key, value, receiver) if (!hadKey) &#123; console.log(`新增$&#123;key&#125;:$&#123;value&#125;`) trigger(target, 'ADD', key) &#125; else if (oldVal !== value) &#123; console.log(`设置$&#123;key&#125;:$&#123;value&#125;`) trigger(target, 'SET', key) &#125; return res &#125;, deleteProperty(target, key) &#123; // 删除 const hadKey = hasOwn(target, key) const res = Reflect.deleteProperty(target, key) // key存在并且删除成功 if (res &amp;&amp; hadKey) &#123; console.log(`删除$&#123;key&#125;:$&#123;res&#125;`) trigger(target, 'DELETE', key) &#125; return res &#125; &#125;) // 缓存 toProxy.set(obj, observed) toRaw.set(observed, obj) return observed&#125;// 每一个属性的响应回调方法const activeReativeEffectStack = []// 依赖收集执行// 基本结构&#123;target:&#123;key:[eff1，eff2]&#125;&#125;let targetsMap = new WeakMap()function track(target, key) &#123; // 从栈中获取响应函数 const effect = activeReativeEffectStack[activeReativeEffectStack.length - 1] if (effect) &#123; let depsMap = targetsMap.get(target) if (!depsMap) &#123; // 首次访问target depsMap = new Map() targetsMap.set(target, depsMap) &#125; // 存放key let deps = depsMap.get(key) if (!deps) &#123; deps = new Set() depsMap.set(key, deps) &#125; if (!deps.has(effect)) &#123; deps.add(effect) &#125; &#125;&#125;// 数据变化响应回调function effect(fn) &#123; // 1.异常处理 // 2.执行函数 // 3.放置到activeReativeEffectStack const rxEffect = function(...args) &#123; try &#123; activeReativeEffectStack.push(rxEffect) return fn(...args) // 执行函数触发依赖收集 &#125; finally &#123; activeReativeEffectStack.pop() &#125; &#125; rxEffect() // 默认立即执行 return rxEffect&#125;// 触发target.key对应响应函数function trigger(target, type, key) &#123; // 获取依赖表 const depsMap = targetsMap.get(target) if (depsMap) &#123; // 获取响应函数集合 const deps = depsMap.get(key) const effects = new Set() if (deps) &#123; // 执行所有响应函数 deps.forEach(effect =&gt; &#123; // effect() effects.add(effect) &#125;) &#125; // 数组新增或删除 if (type === 'ADD' || type === 'DELETE') &#123; if (Array.isArray(target)) &#123; const deps = depsMap.get('length') if (deps) &#123; deps.forEach(effect =&gt; &#123; effects.add(effect) &#125;) &#125; &#125; &#125; // 获取已存在的Dep Set执行 effects.forEach(effect =&gt; effect()) &#125;&#125;const data = &#123; foo: 'foo', bar: &#123; a: 1 &#125; &#125;const react = reactive(data)// 1.获取// react.foo // ok// 2.设置已存在属性// react.foo = 'foooooooo'// 3.设置不存在属性// react.baz = 'bazzzzzz'// 4.嵌套对象// react.bar.a = 10// 避免重复代理// console.log(reactive(data) === react) // true// reactive(react)effect(() =&gt; &#123; console.log('count发生了变化：', react.foo) // dom&#125;)react.foo = 'fooooooo'","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"}]},{"title":"什么是PWA","slug":"前端工程化/什么是PWA","date":"2020-11-18T01:40:00.000Z","updated":"2020-12-11T09:15:27.422Z","comments":true,"path":"/posts/138dbef8.html","link":"","permalink":"https://yangyfeng.github.io/posts/138dbef8.html","excerpt":"一、背景大家都知道Native app体验确实很好，下载到手机上之后入口也方便。它也有一些缺点: 开发成本高(ios和安卓) 软件上线需要审核 版本更新需要将新版本上传到不同的应用商店 想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下 而web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比Native app还是差一些，还有一些明显的缺点 手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签 没网络就没响应，不具备离线能力 不像APP一样能进行消息推送 那么什么是PWA呢？ 二、What’s PWA?PWA全称Progressive Web App，即渐进式WEB应用。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 解决了哪些问题？ 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。","text":"一、背景大家都知道Native app体验确实很好，下载到手机上之后入口也方便。它也有一些缺点: 开发成本高(ios和安卓) 软件上线需要审核 版本更新需要将新版本上传到不同的应用商店 想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下 而web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比Native app还是差一些，还有一些明显的缺点 手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签 没网络就没响应，不具备离线能力 不像APP一样能进行消息推送 那么什么是PWA呢？ 二、What’s PWA?PWA全称Progressive Web App，即渐进式WEB应用。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 解决了哪些问题？ 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。 三、PWA的实现3.1 Manifest实现添加至主屏幕index.html 1234567&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no\" /&gt; &lt;link rel=\"manifest\" href=\"manifest.json\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt; &lt;link rel=\"icon\" href=\"/e.png\" type=\"image/png\" /&gt;&lt;/head&gt; manifest.json 1234567891011121314151617181920212223242526272829&#123; \"name\": \"Minimal PWA\", // 必填 显示的插件名称 \"short_name\": \"PWA Demo\", // 可选 在APP launcher和新的tab页显示，如果没有设置，则使用name \"description\": \"The app that helps you understand PWA\", //用于描述应用 \"display\": \"standalone\", // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的 \"start_url\": \"/\", // 应用启动时的url \"theme_color\": \"#313131\", // 桌面图标的背景色 \"background_color\": \"#313131\", // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。 \"icons\": [ // 桌面图标，是一个数组 &#123; \"src\": \"icon/lowres.webp\", \"sizes\": \"48x48\", // 以空格分隔的图片尺寸 \"type\": \"image/webp\" // 帮助userAgent快速排除不支持的类型 &#125;, &#123; \"src\": \"icon/lowres\", \"sizes\": \"48x48\" &#125;, &#123; \"src\": \"icon/hd_hi.ico\", \"sizes\": \"72x72 96x96 128x128 256x256\" &#125;, &#123; \"src\": \"icon/hd_hi.svg\", \"sizes\": \"72x72\" &#125; ]&#125;` Manifest参考文档可以打开网站查看添加至主屏幕的动图。 如果用的是安卓手机，可以下载chrome浏览器自己操作看看 3.2 service worker实现离线缓存3.2.1 什么是service workerService Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。 Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。 最主要的特点 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost) 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求 单独的作用域范围，单独的运行环境和执行线程 不能操作页面 DOM。但可以通过事件机制来处理 事件驱动型服务线程 为什么要求网站必须是HTTPS的，大概是因为service worker权限太大能拦截所有页面的请求吧，如果http的网站安装service worker很容易被攻击 浏览器支持情况 浏览器支持情况详见： https://caniuse.com/#feat=serviceworkers 生命周期 当用户首次导航至 URL 时，服务器会返回响应的网页。 第1步:当你调用 register() 函数时， Service Worker 开始下载。 第2步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。 第3步:一旦 Service Worker 成功执行了，install 事件就会激活 第4步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用了！ chrome://serviceworker-internals 来了解当前浏览器中所有已安装Service Worker的详细情况 3.2.2 HTTP缓存与service worker缓存 HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。 service worker缓存 Service Workers 的强大在于它们拦截 HTTP 请求的能力进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ 3.2.3 实现离线缓存index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello Caching World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Image --&gt; &lt;img src=\"/images/hello.png\" /&gt; &lt;!-- JavaScript --&gt; &lt;script async src=\"/js/script.js\"&gt;&lt;/script&gt; &lt;script&gt; // 注册 service worker if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/service-worker.js', &#123;scope: '/'&#125;).then(function (registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;).catch(function (err) &#123; // 注册失败 :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注：Service Worker 的注册路径决定了其 scope 默认作用页面的范围。如果 service-worker.js 是在 /sw/ 页面路径下，这使得该 Service Worker 默认只会收到 页面/sw/ 路径下的 fetch 事件。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。 service-worker.js 1234567891011121314151617181920212223242526272829303132333435363738394041var cacheName = 'helloWorld'; // 缓存的名称 // install 事件，它发生在浏览器安装并注册 Service Worker 时 self.addEventListener('install', event =&gt; &#123; /* event.waitUtil 用于在安装成功之前执行一些预装逻辑 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率 安装成功后 ServiceWorker 状态会从 installing 变为 installed */ event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll([ // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 '/js/script.js', '/images/hello.png' ])) );&#125;); /**为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。*/self.addEventListener('fetch', function (event) &#123; event.respondWith( caches.match(event.request) .then(function (response) &#123; if (response) &#123; return response; &#125; var requestToCache = event.request.clone(); // return fetch(requestToCache).then( function (response) &#123; if (!response || response.status !== 200) &#123; return response; &#125; var responseToCache = response.clone(); caches.open(cacheName) .then(function (cache) &#123; cache.put(requestToCache, responseToCache); &#125;); return response; &#125;) );&#125;); 注：为什么用request.clone()和response.clone()需要这么做是因为request和response是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求Clone the request—a request is a stream and can only be consumed once. 3.2.4 调试相关chrome浏览器打开https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service worker离线缓存功能的网站，打开调试工具 介绍一个图中的1.和2. 勾选可以模拟网站离线情况，勾选后network会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示 当前service worker的scope。它能够拦截https://googlechrome.github.i…，同样也能够拦截https://googlechrome.github.i…/.html下的请求 调试面板具体代表的什么参看https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分 3.3 serice worker实现消息推送 步骤一、提示用户并获得他们的订阅详细信息 步骤二、将这些详细信息保存在服务器上 步骤三、在需要时发送任何消息 不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。 步骤一和步骤二 index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Progressive Times&lt;/title&gt; &lt;link rel=\"manifest\" href=\"/manifest.json\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var endpoint; var key; var authSecret; var vapidPublicKey = 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY'; // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用 function urlBase64ToUint8Array(base64String) &#123; const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/\\-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i &lt; rawData.length; ++i) &#123; outputArray[i] = rawData.charCodeAt(i); &#125; return outputArray; &#125; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('sw.js').then(function (registration) &#123; return registration.pushManager.getSubscription() .then(function (subscription) &#123; if (subscription) &#123; return; &#125; return registration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) &#125;) .then(function (subscription) &#123; var rawKey = subscription.getKey ? subscription.getKey('p256dh') : ''; key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : ''; var rawAuthSecret = subscription.getKey ? subscription.getKey('auth') : ''; authSecret = rawAuthSecret ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : ''; endpoint = subscription.endpoint; return fetch('./register', &#123; method: 'post', headers: new Headers(&#123; 'content-type': 'application/json' &#125;), body: JSON.stringify(&#123; endpoint: subscription.endpoint, key: key, authSecret: authSecret, &#125;), &#125;); &#125;); &#125;); &#125;).catch(function (err) &#123; // 注册失败 :( console.log('ServiceWorker registration failed: ', err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 步骤三 服务器发送消息给service worker app.js 123456789101112131415161718192021222324252627282930313233343536const webpush = require('web-push'); const express = require('express');var bodyParser = require('body-parser');const app = express();webpush.setVapidDetails( 'mailto:contact@deanhume.com', 'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY', 'p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0');app.post('/register', function (req, res) &#123; var endpoint = req.body.endpoint; saveRegistrationDetails(endpoint, key, authSecret); const pushSubscription = &#123; endpoint: req.body.endpoint, keys: &#123; auth: req.body.authSecret, p256dh: req.body.key &#125; &#125;; var body = 'Thank you for registering'; var iconUrl = 'https://example.com/images/homescreen.png'; // 发送 Web 推送消息 webpush.sendNotification(pushSubscription, JSON.stringify(&#123; msg: body, url: 'http://localhost:3111/', icon: iconUrl &#125;)) .then(result =&gt; res.sendStatus(201)) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;);app.listen(3111, function () &#123; console.log('Web push app listening on port 3111!')&#125;); service worker监听push事件，将通知详情推送给用户 service-worker.js 12345678910111213self.addEventListener('push', function (event) &#123; // 检查服务端是否发来了任何有效载荷数据 var payload = event.data ? JSON.parse(event.data.text()) : 'no payload'; var title = 'Progressive Times'; event.waitUntil( // 使用提供的信息来显示 Web 推送通知 self.registration.showNotification(title, &#123; body: payload.msg, url: payload.url, icon: payload.icon &#125;) );&#125;); 扩展知识：service worker的更新 总结PWA的优势 可以将app的快捷方式放置到桌面上，全屏运行，与原生app无异 能够在各种网络环境下使用，包括网络差和断网条件下，不会显示undefind 推送消息的能力 其本质是一个网页，没有原生app的各种启动条件，快速响应用户指令 PWA存在的问题 支持率不高:现在ios手机端不支持pwa，IE也暂时不支持 Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低 各大厂商还未明确支持pwa 依赖的GCM服务在国内无法使用 微信小程序的竞争 尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。 service worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。 service worker实现消息推送，使用浏览器推送功能，吸引用户 渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。 参考文档 第一本 PWA 中文书 PWA 英文书 网站渐进式增强体验(PWA)改造：Service Worker 应用详解 Basic Service Worker Sample 【翻译】Service Worker 入门 Web App Manifest Service Workers: an Introduction The Offline Cookbook 微信小程序和PWA对比分析 Service Worker最佳实践 原文地址","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"}]},{"title":"⼤⼚⾯试章法","slug":"面试/⼤⼚⾯试章法","date":"2020-11-16T01:22:00.000Z","updated":"2020-12-21T08:54:47.340Z","comments":true,"path":"/posts/fe27deba.html","link":"","permalink":"https://yangyfeng.github.io/posts/fe27deba.html","excerpt":"简历2⻚以内，简历有点类似相亲的介绍，⼩时候拿过三好学 ⽣就别说了，就像别写你会html+css，别写你⽤vue做 过todolist⼀样 突出⾃⼰的技术亮点 别瞎写精通 markdown就好，别⽤word 突出亮点！ ⽬标公司天眼查，脉脉，知乎 如何描述做过的项⽬ 做过的明星项⽬ 项⽬技术栈和细节 源码深度 优化，性能，体验，极客 填坑 成⻓ ⾯试技巧合计 认识⾃⼰（市场） 阐述优势 谈判得来的 都是纯利润 hr细节(考勤，补贴，996，五险⼀⾦，补贴 ⼀个⾯试题的精讲 精讲面试题之前端⽂件上传1、原理概述 考察全栈思维，http协议 ，node⽂件处理 我⽤vue+element+nodejs来演示 基本答案 （10K）","text":"简历2⻚以内，简历有点类似相亲的介绍，⼩时候拿过三好学 ⽣就别说了，就像别写你会html+css，别写你⽤vue做 过todolist⼀样 突出⾃⼰的技术亮点 别瞎写精通 markdown就好，别⽤word 突出亮点！ ⽬标公司天眼查，脉脉，知乎 如何描述做过的项⽬ 做过的明星项⽬ 项⽬技术栈和细节 源码深度 优化，性能，体验，极客 填坑 成⻓ ⾯试技巧合计 认识⾃⼰（市场） 阐述优势 谈判得来的 都是纯利润 hr细节(考勤，补贴，996，五险⼀⾦，补贴 ⼀个⾯试题的精讲 精讲面试题之前端⽂件上传1、原理概述 考察全栈思维，http协议 ，node⽂件处理 我⽤vue+element+nodejs来演示 基本答案 （10K） 123formData&lt;input type=\"file\" @change=\"handleFileChange\" /&gt;&lt;el-button type=\"primary\" @click=\"handleUpload\"&gt;上传&lt;/el-button&gt; 12345678jshandleFileChange(e) &#123; const [file] = e.target.files; if (!file) return; form.append(\"filename\", this.container.file.name); form.append(\"file\", this.container.file); request(&#123;url: '/upload', 9 data: form&#125;) &#125;, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152nodeconst http = require(\"http\")const path = require('path')const Controller = require('./controller')const schedule = require('./schedule')const server = http.createServer()const UPLOAD_DIR = path.resolve(__dirname, \"..\", \"target\"); // ⼤⽂件存储⽬录// schedule.start(UPLOAD_DIR) const ctrl = new Controller(UPLOAD_DIR) server.on(\"request\", async (req, res) =&gt; &#123; res.setHeader(\"Access-Control-Allow\u0002Origin\", \"*\") res.setHeader(\"Access-Control-Allow\u0002Headers\", \"*\") if (req.method === \"OPTIONS\") &#123; res.status = 200 res.end() return &#125; if (req.method === \"POST\") &#123; if (req.url == '/upload') &#123; await ctrl.handleUpload(req, res) return &#125; &#125; &#125;) server.listen(3000, () =&gt; console.log(\"正在监听 3000 端⼝\")) Controller.js async handleUpload(req, res) &#123; const multipart = new multiparty.Form() multipart.parse(req, async (err, field, file) =&gt; &#123; if (err) &#123; console.log(err) return &#125; const [chunk] = file.file const [filename] = field.filename const filePath = path.resolve(this.UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;extractExt(filename)&#125;`) const chunkDir = path.resolve(this.UPLOAD_DIR, fileHash) // ⽂件存在直接返回 if (fse.existsSync(filePath)) &#123; res.end(\"file exist\") return &#125; if (!fse.existsSync(chunkDir)) &#123; await fse.mkdirs(chunkDir) &#125; await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`) res.end(\"received file chunk\") &#125;) &#125; 总结： forData httpserver fs⽂件处理 multiparty解析post数据 加分项-拖拽，粘贴 考点: 拖拽事件drop，clipboardData 123456789101112131415161718&lt;div class=\"drop-box\" id=\"drop-box\"&gt;// 拖拽box.addEventListener(\"drop\", function (e) &#123; e.preventDefault(); //取消浏览器默认拖拽效果 var fileList = e.dataTransfer.files; //获取拖拽中的⽂件对象 var len = fileList.length; //⽤来获取⽂件的⻓度（其实是获得⽂件数量） const [file] = e.target.files; if (!file) return; // ...上传 &#125;, false)// 粘贴 box.addEventListener('paste', function (event) &#123; var data = (event.clipboardData) // .... &#125;); ⼤⽂件上传(20K) blob.slice分⽚ 思想+语法 123456789101112const chunks = this.createFileChunk(this.container.file);createFileChunk(file, size = SIZE) &#123; // ⽣成⽂件块 const chunks = []; let cur = 0; while (cur &lt; file.size) &#123; chunks.push(&#123; file: file.slice(cur, cur + size) &#125;); cur += size; &#125; return chunks; &#125; 所有切⽚挨个发请求，然后merge 12345678910111213141516async handleMerge(req, res) &#123; const data = await resolvePost(req) const &#123; fileHash, filename, size &#125; = data const ext = extractExt(filename) const filePath = path.resolve(this.UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`) await this.mergeFileChunk(filePath, fileHash, size) res.end(JSON.stringify(&#123; code: 0, message: \"file merged success\" &#125;)) &#125; 断点续传+秒传 md5计算，缓存思想 ⽂件⽤md5计算⼀个指纹，上传之前，先问后端，这个⽂件的hash在不在，在的话就不⽤传了，就是所谓的断点续传，如果整个⽂件都存在了 就是秒传 123456789101112131415161718192021222324async handleVerify(req, res) &#123; const data = await resolvePost(req) const &#123; filename, hash &#125; = data const ext = extractExt(filename) const filePath = path.resolve(this.UPLOAD_DIR, `$&#123;hash&#125;$&#123;ext&#125;`) // ⽂件是否存在 let uploaded = false let uploadedList = [] if (fse.existsSync(filePath)) &#123; uploaded = true &#125; else &#123; // ⽂件没有完全上传完毕，但是可能存在部分切⽚上传完毕了 uploadedList = await getUploadedList(path.resolve(this.UPLOAD_DIR, hash)) &#125; res.end( JSON.stringify(&#123; uploaded, uploadedList // 过滤诡异的隐藏⽂件 &#125;) ) &#125; 计算hash优化(25+) 1、web-worker ⼤⽂件的md5太慢了,启⽤webworker计算 123456789101112131415161718192021222324252627282930313233343536373839// web-worker self.importScripts('spark-md5.min.js') self.onmessage = e =&gt; &#123; // 接受主线程的通知 const &#123; chunks &#125; = e.data const spark = new self.SparkMD5.ArrayBuffer() let progress = 0 let count = 0 const loadNext = index =&gt; &#123; const reader = new FileReader() reader.readAsArrayBuffer(chunks[index].file) reader.onload = e =&gt; &#123; // 累加器 不能依赖index， count++ // 增量计算md5 spark.append(e.target.result) if (count === chunks.length) &#123; // 通知主线程，计算结束 self.postMessage(&#123; progress: 100, hash: spark.end() &#125;) &#125; else &#123; // 每个区块计算结束，通知进度即可 progress += 100 / chunks.length self.postMessage(&#123; progress &#125;) // 计算下⼀个 loadNext(count) &#125; &#125; &#125; // 启动 loadNext(0) &#125; 1、time-slice(30+) react fifiber架构学习，利⽤浏览器空闲时间 requestIdleCallback 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960requestIdelCallback(myNonEssentialWork); function myNonEssentialWork(deadline) &#123; // deadline.timeRemaining()可以获取到当前帧剩余时间 // 当前帧还有时间 并且任务队列不为空 while (deadline.timeRemaining() &gt; 0 &amp;&amp; tasks.length &gt; 0) &#123; doWorkIfNeeded(); &#125; if (tasks.length &gt; 0) &#123; requestIdleCallback(myNonEssentialWork); &#125; &#125; async calculateHashIdle(chunks) &#123; return new Promise(resolve =&gt; &#123; const spark = new SparkMD5.ArrayBuffer(); let count = 0; // 根据⽂件内容追加计算 const appendToSpark = async file =&gt; &#123; return new Promise(resolve =&gt; &#123; const reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onload = e =&gt; &#123; spark.append(e.target.result); resolve(); &#125;; &#125;); &#125;; const workLoop = async deadline =&gt; &#123; // 有任务，并且当前帧还没结束 while (count &lt; chunks.length &amp;&amp; deadline.timeRemaining() &gt; 1) &#123; await appendToSpark(chunks[count].file); count++; // 没有了 计算完毕 if (count &lt; chunks.length) &#123; // 计算中 this.hashProgress = Number( ((100 * count) / chunks.length).toFixed(2) ); console.log(this.hashProgress) &#125; else &#123; // 计算完毕 this.hashProgress = 100; resolve(spark.end()); &#125; &#125; window.requestIdleCallback(workLoop); &#125;; &#125;) &#125; 3、算法优化 精讲面试题之请求并发数控制和重试 1、基本实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576async sendRequest(forms, max = 4) &#123; return new Promise(resolve =&gt; &#123; const len = forms.length; let idx = 0; let counter = 0; const start = async () =&gt; &#123; // 有请求，有通道 while (idx &lt; len &amp;&amp; max &gt; 0) &#123; max--; // 占⽤通道 console.log(idx, \"start\"); const form = forms[idx].form; const index = forms[idx].index; + idx++ request(&#123; url: '/upload', data: form, onProgress: this.createProgresshandler(this.chunks[ index]), requestList: this.requestList &#125;).then(() =&gt; &#123; max++; // 释放通道 counter++; if (counter === len) &#123; resolve(); &#125; else &#123; start(); &#125; &#125;); &#125; &#125; start(); &#125;); &#125; async uploadChunks(uploadedList = []) &#123; // 这⾥⼀起上传，碰⻅⼤⽂件就是灾难 // 没被hash计算打到，被⼀次性的tcp链接把浏览器稿挂了 // 异步并发控制策略，我记得这个也是头条⼀个⾯试题 // ⽐如并发量控制成4 const list = this.chunks.filter(chunk =&gt; uploadedList.indexOf(chunk.hash) == -1) .map((&#123; chunk, hash, index &#125;, i) =&gt; &#123; const form = new FormData(); form.append(\"chunk\", chunk); form.append(\"hash\", hash); form.append(\"filename\", this.container.file.name); form.append(\"fileHash\", this.container.hash); return &#123; form, index &#125;; &#125;).map((&#123; form, index &#125;) =&gt; request(&#123; url: \"/upload\", data: form, onProgress: this.createProgresshandler(this.chunks[index]), requestList: this.requestList &#125;) ); // 直接全量并发 await Promise.all(list); // 控制并发 const ret = await this.sendRequest(list, 4) if (uploadedList.length + list.length === this.chunks.length) &#123; // 上传和已经存在之和 等于全部的再合并 await this.mergeRequest(); &#125; &#125; 2、慢启动策略 TCP拥塞控制的问题 其实就是根据当前⽹络情况，动态 调整切⽚的⼤⼩ chunk中带上size值，不过进度条数量不确定了，修改createFileChunk， 请求加上时间统计) ⽐如我们理想是30秒传递⼀个 初始⼤⼩定为1M，如果上传花了10秒，那下⼀个区块⼤⼩变成3M 如果上传花了60秒，那下⼀个区块⼤⼩变成500KB以此类推 并发+慢启动的逻辑有些复杂，我⾃⼰还没绕明⽩，囧所以先⼀次只传⼀个切⽚，来演示这个逻辑，新建⼀个handleUpload1函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950async handleUpload1() &#123; // @todo数据缩放的⽐率 可以更平缓 // @todo 并发+慢启动 // 慢启动上传逻辑 const file = this.container.file if (!file) return; this.status = Status.uploading; const fileSize = file.size let offset = 1024 * 1024 let cur = 0 let count = 0 this.container.hash = await this.calculateHashSample(); while (cur &lt; fileSize) &#123; // 切割offfset⼤⼩ const chunk = file.slice(cur, cur + offset) cur += offset const chunkName = this.container.hash + \"-\" + count; const form = new FormData(); form.append(\"chunk\", chunk); form.append(\"hash\", chunkName); form.append(\"filename\", file.name); form.append(\"fileHash\", this.container.hash); form.append(\"size\", chunk.size); let start = new Date().getTime() await request(&#123; url: '/upload', data: form &#125;) const now = new Date().getTime() const time = ((now - start) / 1000).toFixed(4) let rate = time / 30 // 速率有最⼤2和最⼩0.5 if (rate &lt; 0.5) rate = 0.5 if (rate &gt; 2) rate = 2 // 新的切⽚⼤⼩等⽐变化 console.log(`切⽚$&#123;count&#125;⼤⼩是$&#123;this.format(offset)&#125;,耗时$&#123;time&#125;秒，是30秒的$&#123;rate&#125;倍，修正⼤⼩为$&#123;this.format(offset/rate)&#125;`) // 动态调整offset offset = parseInt(offset / rate) // if(time) count++ &#125; &#125; //切⽚0⼤⼩是1024.00KB,耗时13.2770秒，是30秒的0.5倍，修正⼤⼩为2.00MB//切⽚1⼤⼩是2.00MB,耗时25.4130秒，是30秒的0.8471倍，修正⼤⼩为2.36MB//切⽚2⼤⼩是2.36MB,耗时14.1260秒，是30秒的0.5倍，修正⼤⼩为4.72MB 3、碎⽚清理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 为了⽅便测试，我改成每5秒扫⼀次， 过期1钟的删除做演示 const fse = require('fs-extra') const path = require('path') const schedule = require('node\u0002schedule') // 空⽬录删除 function remove(file, stats) &#123; const now = new Date().getTime() const offset = now - stats.ctimeMs if (offset &gt; 1000 * 60) &#123; // ⼤于60秒的碎⽚ console.log(file, '过期了，浪费空间的玩意，删除') fse.unlinkSync(file) &#125; &#125; async function scan(dir, callback) &#123; const files = fse.readdirSync(dir) files.forEach(filename =&gt; &#123; const fileDir = path.resolve(dir, filename) const stats = fse.statSync(fileDir) if (stats.isDirectory()) &#123; return scan(fileDir, remove) &#125; if (callback) &#123; callback(fileDir, stats) &#125; &#125;) &#125; let start = function (UPLOAD_DIR) &#123; // 每5秒 schedule.scheduleJob(\"*/5 * * * * *\", function () &#123; console.log('开始扫描') scan(UPLOAD_DIR) &#125;) &#125; exports.start = start 开始扫描/upload/target/625c.../625c...-0 过期了，删除/upload/target/625c.../625c...-1 过期了，删除/upload/target/625c.../625c...-10 过期了，删除/upload/target/625c.../625c...-11 过期了，删除/upload/target/625c.../625c...-12 过期了，删除 面试题之后续问题 requestIdleCallback兼容性，如何⾃⼰实现⼀个react也是⾃⼰写的调度逻辑,React⾃⼰实现的requestIdleCallback(https://www.dazhuanlan.com/2019/10/20/5dabc56a750fd/) 并发+慢启动配合 抽样hash+全量哈希+时间切⽚配合 ⼤⽂件切⽚下载 websocket推送进度 ⽂件碎⽚分机器存储以及⽂件碎⽚备份","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"NodeJs中数据库的使用","slug":"Node/NodeJs中数据库的使用","date":"2020-09-09T10:29:00.000Z","updated":"2020-12-11T09:11:38.878Z","comments":true,"path":"/posts/e4aa7462.html","link":"","permalink":"https://yangyfeng.github.io/posts/e4aa7462.html","excerpt":"1.Node.js 连接 MySQLcnpm install mysql 连接mysql: 123456789101112131415var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : '123456', database : 'test'&#125;);connection.connect(); connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;); 数据库连接参数说明 1234567891011121314151617181920212223242526272829303132333435363738参数 描述host 主机地址 （默认：localhost）user 用户名password 密码port 端口号 （默认：3306）database 数据库名charset 连接字符集（默认：'UTF8_GENERAL_CI'，注意字符集的字母都要大写）localAddress 此IP用于TCP连接（可选）socketPath 连接到unix域路径，当使用 host 和 port 时会被忽略timezone 时区（默认：'local'）connectTimeout 连接超时（默认：不限制；单位：毫秒）stringifyObjects 是否序列化对象typeCast 是否将列值转化为本地JavaScript类型值 （默认：true）queryFormat 自定义query语句格式化方法supportBigNumbers 数据库支持bigint或decimal类型列时，需要设此option为true （默认：false）bigNumberStrings supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false）dateStrings 强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false）debug 开启调试（默认：false）multipleStatements 是否许一个query中有多个MySQL语句 （默认：false）flags 用于修改连接标志ssl 使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件","text":"1.Node.js 连接 MySQLcnpm install mysql 连接mysql: 123456789101112131415var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : '123456', database : 'test'&#125;);connection.connect(); connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;); 数据库连接参数说明 1234567891011121314151617181920212223242526272829303132333435363738参数 描述host 主机地址 （默认：localhost）user 用户名password 密码port 端口号 （默认：3306）database 数据库名charset 连接字符集（默认：'UTF8_GENERAL_CI'，注意字符集的字母都要大写）localAddress 此IP用于TCP连接（可选）socketPath 连接到unix域路径，当使用 host 和 port 时会被忽略timezone 时区（默认：'local'）connectTimeout 连接超时（默认：不限制；单位：毫秒）stringifyObjects 是否序列化对象typeCast 是否将列值转化为本地JavaScript类型值 （默认：true）queryFormat 自定义query语句格式化方法supportBigNumbers 数据库支持bigint或decimal类型列时，需要设此option为true （默认：false）bigNumberStrings supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false）dateStrings 强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false）debug 开启调试（默认：false）multipleStatements 是否许一个query中有多个MySQL语句 （默认：false）flags 用于修改连接标志ssl 使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件 2.Node.js 连接 MongoDB： MongoDB是一种文档导向数据库管理系统，由C++撰写而成。MongoDB 教程。 安装驱动 1$ cnpm install mongodb 增删改查 要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。如果数据库不存在，MongoDB 将创建数据库并建立连接。 创建连接 12345678var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/mydb\"; MongoClient.connect(url, function(err, db) &#123; if (err) throw err; console.log(\"数据库已创建!\"); db.close();&#125;); 创建集合 我们可以使用 createCollection() 方法来创建集合： 创建集合 123456789101112var MongoClient = require('mongodb').MongoClient;var url = 'mongodb://localhost:27017/mydb';MongoClient.connect(url, function (err, db) &#123; if (err) throw err; console.log('数据库已创建'); var dbase = db.db(\"mydb\"); dbase.createCollection('runoob', function (err, res) &#123; if (err) throw err; console.log(\"创建集合!\"); db.close(); &#125;);&#125;); 数据库操作( CURD ) 与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 插入数据 以下实例我们连接数据库 runoob 的 site 表，并插入两条数据： 插入数据 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; # 数据库为 runoob var insertData = function(db, callback) &#123; //连接到表 site var collection = db.collection('site'); //插入数据 var data = [&#123;\"name\":\"菜鸟教程\",\"url\":\"www.runoob.com\"&#125;,&#123;\"name\":\"菜鸟工具\",\"url\":\"c.runoob.com\"&#125;]; collection.insert(data, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); insertData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行以下命令输出就结果为： 12345678910111213$ node test.js //连接成功！&#123; result: &#123; ok: 1, n: 2 &#125;, ops: [ &#123; name: '菜鸟教程', url: 'www.runoob.com', _id: 58c25e13a08de70d3b9d4116 &#125;, &#123; name: '菜鸟工具', url: 'c.runoob.com', _id: 58c25e13a08de70d3b9d4117 &#125; ], insertedCount: 2, insertedIds: [58c25e13a08de70d3b9d4116, 58c25e13a08de70d3b9d4117]&#125; 从输出结果来看，数据已插入成功。 我们也可以打开 MongoDB 的客户端查看数据，如： 123456789101112show dbsadmin 0.000GBlocal 0.000GBrunoob 0.000GB # 自动创建了 runoob 数据库show tablessite # 自动创建了 site 集合（数据表）db.site.find() # 查看集合中的数据&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c8\"), \"name\" : \"菜鸟教程\", \"url\" : \"www.runoob.com\" &#125;&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c9\"), \"name\" : \"菜鸟工具\", \"url\" : \"c.runoob.com\" &#125; 查询数据 以下实例检索 name 为 “菜鸟教程” 的实例： 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; var selectData = function(db, callback) &#123; //连接到表 var collection = db.collection('site'); //查询数据 var whereStr = &#123;\"name\":'菜鸟教程'&#125;; collection.find(whereStr).toArray(function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); selectData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行以下命令输出就结果为： 连接成功！ 123[ &#123; _id: 58c25f300cd56e0d7ddfc0c8, name: '菜鸟教程', url: 'www.runoob.com' &#125; ] 更新数据 我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 https://www.runoob.com： 1234567891011121314151617181920212223242526var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; var updateData = function(db, callback) &#123; //连接到表 var collection = db.collection('site'); //更新数据 var whereStr = &#123;\"name\":'菜鸟教程'&#125;; var updateStr = &#123;$set: &#123; \"url\" : \"https://www.runoob.com\" &#125;&#125;; collection.update(whereStr,updateStr, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); updateData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行成功后，进入 mongo 管理工具查看数据已修改： 123db.site.find()&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c8\"), \"name\" : \"菜鸟教程\", \"url\" : \"https://www.runoob.com\" &#125;&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c9\"), \"name\" : \"菜鸟工具\", \"url\" : \"c.runoob.com\" &#125; 删除数据 以下实例将 name 为 “菜鸟工具” 的数据删除 : 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; var delData = function(db, callback) &#123; //连接到表 var collection = db.collection('site'); //删除数据 var whereStr = &#123;\"name\":'菜鸟工具'&#125;; collection.remove(whereStr, function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); delData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 执行成功后，进入 mongo 管理工具查看数据已删除： 12db.site.find()&#123; \"_id\" : ObjectId(\"58c25f300cd56e0d7ddfc0c8\"), \"name\" : \"菜鸟教程\", \"url\" : \"https://www.runoob.com\" &#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://yangyfeng.github.io/blogpost/categories/Node/"}],"tags":[]},{"title":"http协议","slug":"Http/http协议","date":"2020-09-09T10:20:00.000Z","updated":"2020-12-11T09:10:53.881Z","comments":true,"path":"/posts/6a5e2f06.html","link":"","permalink":"https://yangyfeng.github.io/posts/6a5e2f06.html","excerpt":"","text":"HTTP 简介： HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写 HTTP是因特网上应用最为广泛的一种网络传输协议，是一个无状态的请求/响应协议 HTTP是基于客户端/服务端（C/S）的架构模型 HTTP是一个基于TCP/IP通信协议来传递数据 HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS默认HTTP的端口号为80，HTTPS的端口号为443 HTTP的请求响应模型： HTTP协议永远都是客户端发起请求，服务器回送响应 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系 HTTP 工作原理： HTTP协议工作于客户端-服务端架构上。浏览器作为Http客户端通过地址栏 Url将请求发送到Http服务端即Web服务器上。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 工作流程： 一次完整的Http事务：http://blog.csdn.net/yipiankongbai/article/details/25029183 一次HTTP操作称为一个事务，其工作过程可分为六步： 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 域名解析 -&gt; 三次握手 -&gt; 建立连接 -&gt; 发送请求 -&gt; 响应请求 -&gt; 接收响应 任何一步发生错误，都会将错误信息返回到客户端 1）域名解析 ：将网站名称转变成IP地址：localhost–&gt;127.0.0.1 2）发起TCP的3次握手 ： 客户端发出一个SYN消息 -》 服务器使用SYN+ACK应答表示接收到了这个消息 -》 客户机再以ACK消息响应 -》 建立起可靠的TCP连接，数据传递 3）客户端与服务端建立连接 4）客户端发送请求给服务端，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 5）服务端接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 6）客户端接收服务端所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 HTTP请求方法： HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP 响应头信息： HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 HTTP状态码： 下面是常见的HTTP状态码： 200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP content-type：http://www.runoob.com/http/http-content-type.html","categories":[{"name":"Http","slug":"Http","permalink":"https://yangyfeng.github.io/blogpost/categories/Http/"}],"tags":[]},{"title":"TCP3次握手","slug":"Http/TCP3次握手","date":"2020-09-09T10:17:00.000Z","updated":"2020-12-11T09:11:21.708Z","comments":true,"path":"/posts/6a5e2f06.html","link":"","permalink":"https://yangyfeng.github.io/posts/6a5e2f06.html","excerpt":"","text":"什么是http?为了提供可靠的传送，TCP在发送新的数据之前，以特定的顺序将数据包的序号，并需要这些包传送给目标机之后的确认消息。TCP总是用来发送大批量的数据。当应用程序在收到数据后要做出确认时也要用到TCP。 过程 第一次 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。","categories":[{"name":"Http","slug":"Http","permalink":"https://yangyfeng.github.io/blogpost/categories/Http/"}],"tags":[]},{"title":"create-react-app(注意事项)","slug":"React/create-react-app(注意事项)","date":"2020-09-09T10:01:00.000Z","updated":"2020-12-11T09:11:46.131Z","comments":true,"path":"/posts/6a5e2f06.html","link":"","permalink":"https://yangyfeng.github.io/posts/6a5e2f06.html","excerpt":"React.createClass is not a function在React16以上，已经摒弃React.createClass()这个方法 取而代之的是1class Welcome extends React.Component&#123;&#125; 配置webpack 前置条件(precondition) Creating a New Application 安装yarn 1npm install yarn -g 安装依赖 1yarn install 显示webpack配置 1npm run eject 添加alias 可以根据项目自行配置 12345678alias: &#123; 'react-native': 'react-native-web', 'src':path.join(__dirname, '..', 'src'), 'language':path.join(__dirname, '..', 'src/language'), 'router':path.join(__dirname, '..', 'src/router'), 'Modebase':path.join(__dirname, '..', 'src/Modebase'), 'containers':path.join(__dirname, '..', 'src/containers') &#125; 添加cssnext(postcs)一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。","text":"React.createClass is not a function在React16以上，已经摒弃React.createClass()这个方法 取而代之的是1class Welcome extends React.Component&#123;&#125; 配置webpack 前置条件(precondition) Creating a New Application 安装yarn 1npm install yarn -g 安装依赖 1yarn install 显示webpack配置 1npm run eject 添加alias 可以根据项目自行配置 12345678alias: &#123; 'react-native': 'react-native-web', 'src':path.join(__dirname, '..', 'src'), 'language':path.join(__dirname, '..', 'src/language'), 'router':path.join(__dirname, '..', 'src/router'), 'Modebase':path.join(__dirname, '..', 'src/Modebase'), 'containers':path.join(__dirname, '..', 'src/containers') &#125; 添加cssnext(postcs)一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。 修改webpack.config.dev.js添加postcss插件 1234567891011&#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), require('postcss-cssnext', &#123; browsers: ['last 2 version'] &#125; ], &#125; &#125; webPack按需加载 添加react-router4 使用react-router-dom，参考初探 React Router 4.0 1yarn add react-router-dom 在react-router4中进行代码拆分 react-router升级到4后，便没有了getComponent这个参数。所以我们得换种方式，react-router4官方示例也提供了code splitting的方法，利用webpack结合bundle-loader，它是在require.ensure基础上封装的，更友好的实现异步加载过程。 添加Bundle.js组件 1234567891011121314151617export default class Bundle extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; mod: null &#125;; &#125; load = props =&gt; &#123; this.setState(&#123; mod: null &#125;); props.load(mod =&gt; &#123; this.setState(&#123; mod: mod ? mod : null &#125;); &#125;); &#125; componentWillMount() &#123; this.load(this.props); &#125; render() &#123; return this.state.mod ? this.props.children(this.state.mod) : null &#125; &#125; 使用require.ensure()来进行模块的异步加载 1&lt;Bundle load=&#123;(cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(require('containers/Buttons/containers').default); &#125;,'Buttons'); &#125;&#125;&gt; &#123;(Buttons) =&gt; &lt;Buttons &#123;...props&#125;/&gt;&#125; &lt;/Bundle&gt; webPack提取公共模块 首先把入口处改写为下面这样，把公共的方法提取出来 123456789entry: &#123; app:[ require.resolve('./polyfills'), paths.appIndexJs, require.resolve('react-error-overlay'), require.resolve('react-dev-utils/webpackHotDevClient') ], vendor: ['react', 'react-dom', 'react-router','react-router-dom', 'mobx', 'mobx-react'] &#125; 提取公共模块 1new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor.[hash:8].js' &#125;) Webpack DLL 用法 Dll使用方法其实挺简单的。网上也有很多例子。 我遇到一些坑这里和大家说明一下 首先在主目录下面新建 webpack.dll.dev.js 1234567891011121314const webpack = require('webpack'); const path = require('path'); module.exports = &#123; entry: &#123; vendor: [path.join(__dirname, 'src', 'vendor.js')], &#125;, output: &#123; path: path.join(__dirname, 'dll'), filename: '[name].js', library: '[name]', &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, 'dll', '[name]-manifest.json'), filename: '[name].js', name: '[name]', &#125;), ] &#125;; 这个Webpack文件主要的功能是在根目录生成dll文件夹。里面包含有vendor.js（index.html需要添加的js）和vendor-manifest.json （DllPlugin生成的json文件） 在主webpack文件里面通过DllReferencePlugin插件引用 然后再package.json里面添加 webpack –config webpack.dll.dev.js 然后在主webpack文件添加如下代码 1const manifest = require('../dll/vendor-manifest.json'); plugins: [ new webpack.DllReferencePlugin(&#123; manifest &#125;) ] 下面就是dll比较坑的地方，如何在index.html中引入verdor.js呢。 首先我们思考直接在public底下的index.html中直接引用，这个dllplugin的包并不会被打进内存里，需要指定一个static目录 解决办法使用AddAssetHtmlPlugin 在htmlwebpack后插入一个AddAssetHtmlPlugin插件，用于将vendor插入打包后的页面 1new AddAssetHtmlPlugin(&#123; filepath: require.resolve('../dll/vendor.js'), includeSourcemap: false &#125;) 节省了近30S!!! 使用UglifyJsPlugin压缩代码 1new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125; &#125;) 添加ANTD全局组件和css 修改webpack","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"create-react-app","slug":"create-react-app","permalink":"https://yangyfeng.github.io/blogpost/tags/create-react-app/"},{"name":"react","slug":"react","permalink":"https://yangyfeng.github.io/blogpost/tags/react/"}]},{"title":"React 脚手架工具（create-react-app）","slug":"React/React 脚手架工具（crate-react-app）","date":"2020-09-09T09:55:00.000Z","updated":"2020-12-11T09:11:51.791Z","comments":true,"path":"/posts/a2043eea.html","link":"","permalink":"https://yangyfeng.github.io/posts/a2043eea.html","excerpt":"介绍在开发react应用时，应该没有人用传统的方法引入react的源文件(js)，然后在html编辑吧。 大家都是用webpack + es6来结合react开发前端应用。 这个时候，我们可以手动使用npm来安装各种插件，来从头到尾自己搭建环境。 比如： 12345npm install react react-dom --savenpm install babel babel-loader babel-core babel-preset-es2015 babel-preset-react --savenpm install babel webpack webpack-dev-server -g","text":"介绍在开发react应用时，应该没有人用传统的方法引入react的源文件(js)，然后在html编辑吧。 大家都是用webpack + es6来结合react开发前端应用。 这个时候，我们可以手动使用npm来安装各种插件，来从头到尾自己搭建环境。 比如： 12345npm install react react-dom --savenpm install babel babel-loader babel-core babel-preset-es2015 babel-preset-react --savenpm install babel webpack webpack-dev-server -g 类似这样的脚手架，我扫了网络上比较多人用和关注的，一共发现了三个，它们分别是： 123react-boilerplatereact-redux-starter-kitcreate-react-app(facebook官方开发) 特点安装和使用(默认监听3000端口) 1234567npm install -g create-react-appcreate-react-app my-appcd my-app/npm start 源码结构简单清晰 如果你使用过webpack-dev-server或webpack搭建过开发环境，你就会发现，create-react-app的开发环境也有类似webpack-dev-server的–inline –hot自动刷新的功能。 翻看了一下源码，没有找到webpack.config.js文件，如果有使用webpack就应该有这个文件，好奇怪。 看了一下node_modules目录，也没找到webpack相关的东西。 package.json package.json中也没有webpack相关的东西,但是在react-scripts中依赖了webpack 线上编译命令 编译出来的文件很小，且文件名还带hash值，方便我们做cache，而且它还提供一个服务器，让我们在本地也能看到线上生产环境类似的效果 1npm run build 运行下面两条命令，可以查看线上生产环境的运行效果 123npm install -g pushstate-serverpushstate-server build api开发 CORS问题:毕竟端口不同，而线上环境却没有这个问题，因为你都控制线上环境的react应用和api应用，跑在同一个端口上。 按照以往思路，解决的方法可能是用环境变量，比如 const apiBaseUrl = process.env.NODE_ENV === ‘development’ ? ‘localhost:3001’ : ‘/‘ 但是这样搞起来，还是有些复杂，然而，create-react-app提供了一个超级简单的方法，只需要在package.json文件中，加一个配置项就可以了。 “proxy”: “http://localhost:3001/&quot;, 执行npm run eject 暴露配置文件等 报错解决方案： 1先执行git add . 和 git commit -m \"init\" 在执行 npm run eject","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"create-react-app","slug":"create-react-app","permalink":"https://yangyfeng.github.io/blogpost/tags/create-react-app/"},{"name":"react","slug":"react","permalink":"https://yangyfeng.github.io/blogpost/tags/react/"}]},{"title":"devops是什么","slug":"开发工具/devops是什么","date":"2020-09-09T09:33:00.000Z","updated":"2020-09-09T09:39:24.783Z","comments":true,"path":"/posts/cfdabafc.html","link":"","permalink":"https://yangyfeng.github.io/posts/cfdabafc.html","excerpt":"DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。","text":"DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 传统的软件组织将开发、IT 运营和质量保障设为各自分离的部门，在这种环境下如何采用新的开发方法（例如敏捷软件开发），是一个重要的课题。按照从前的工作方式，开发和部署，不需要 IT 支持或者 QA 深入的跨部门的支持；而现在却需要极其紧密的多部门协作。而 DevOps 考虑的还不止是软件部署，它是一套针对这几个部门间沟通与协作问题的流程和方法。 需要频繁交付的企业可能更需要对 DevOps 有一个大致的了解。Flickr 发展了自己的 DevOps 能力，使之能够支撑业务部门“每天部署 10 次”的要求，如果一个组织要生产面向多种用户、具备多样功能的应用程序，其部署周期必然会很短。这种能力也被称为持续部署，并且经常与精益创业方法联系起来。从 2009 年起，相关的工作组、专业组织和博客快速涌现。 DevOps 的引入能对产品交付、测试、功能开发和维护（包括──曾经罕见但如今已屡见不鲜的──“热补丁”）起到意义深远的影响。在缺乏 DevOps 能力的组织中，开发与运营之间存在着信息“鸿沟”──例如运营人员要求更好的可靠性和安全性，开发人员则希望基础设施响应更快，而业务用户的需求则是更快地将更多的特性发布给最终用户使用。这种信息鸿沟就是最常出问题的地方。 以下几方面因素可能促使一个组织引入 DevOps： 使用敏捷或其他软件开发过程与方法 业务负责人要求加快产品交付的速率 虚拟化和云计算基础设施（可能来自内部或外部供应商）日益普遍 数据中心自动化技术和配置管理工具的普及 有一种观点认为，当前占主导地位的“传统”美国式管理风格（“斯隆模型 vs 丰田模型”）会导致“烟囱式自动化”，从而造成开发与运营之间的鸿沟，因此需要 DevOps 能力来克服由此引发的问题。 DevOps 经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/tags/开发工具/"},{"name":"devops","slug":"devops","permalink":"https://yangyfeng.github.io/blogpost/tags/devops/"}]},{"title":"面试题集锦（1）","slug":"面试/面试题集锦（1）","date":"2020-09-08T16:00:00.000Z","updated":"2020-12-21T08:54:51.237Z","comments":true,"path":"/posts/fe27deba.html","link":"","permalink":"https://yangyfeng.github.io/posts/fe27deba.html","excerpt":"什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：网络协议不同，如http协议访问https协议。端口不同，如80端口访问8080端口。域名不同，如qianduanblog.com访问baidu.com。子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。域名和域名对应ip,如www.a.com访问20.205.28.90.2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。实现方法：通过nginx代理；注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。(2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：123456res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\", \"Access-Control-Allow-Origin\":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。实例如下：1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = \"text/javascript\"; _script.src = \"http://localhost:8888/jsonp?callback=testjsonp\"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。","text":"什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：网络协议不同，如http协议访问https协议。端口不同，如80端口访问8080端口。域名不同，如qianduanblog.com访问baidu.com。子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。域名和域名对应ip,如www.a.com访问20.205.28.90.2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。实现方法：通过nginx代理；注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。(2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：123456res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\", \"Access-Control-Allow-Origin\":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。实例如下：1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = \"text/javascript\"; _script.src = \"http://localhost:8888/jsonp?callback=testjsonp\"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。 介绍一下 JS 的基本数据类型。1Undefined、Null、Boolean、Number、String 如何利用JavaScript实现一个自定义事件，存在on，off，emit三个方法？这个题目的意义在哪里？我想，应该是对于一些特定的业务逻辑，比如在注册一个“通知”的事件，在与Native交互之后，假设这个交互是在入口级别的页面里，那么如何发送给具体某个业务呢？事件应该是最简单的一种方式，在某个具体的业务中注册一个事件，然后在与Native交互完，拿到某些数据后，然后触发这个事件。 我们来一步一步实现一个最简单的事件类Event，不考虑任何其他复杂的情况。假设在这个Event类的内部有一个this._events = [] 数组来维系整个事件系统，我们分别实现on，off，emit三个方法即可。 on（注册一个事件）：1234567Event.prototype.on = function(type,fun)&#123; let cbs = this._events[type]; cbs ? cbs.push(fun) : this._events[type] = []; if (!cbs) &#123; this._events[type].push(fun) &#125; &#125; 这里为什么要将this._events设计为二维数组？因为事件可以是多个，但是事件名可能相同。这个逻辑意图非常的明显，根据type参数从this._events中获取是否存在。如果不存在，创建一个type为key的数组，并将事件句柄程序push到数组中。 off（注销一个事件）：123456789101112131415161718192021222324252627Event.prototype.off = function (type, fun) &#123; let cbs = this._events[type]; //事件列队中无事件 if (!cbs) &#123; return this; &#125; //删除所有的事件 if (!event &amp;&amp; !fun) &#123; this._events = &#123;&#125;; return this; &#125; //只有事件名称时 if (event &amp;&amp; !fun) &#123; this._events[type] = null; return this; &#125; //删除某个事件队列中的某个事件 let cb; let i = cbs.length; while (i--) &#123; cb = cbs[i]; if (cb === fun || cb.fun === fun) &#123; cbs.splice(i, 1); break; &#125; &#125; &#125; 虽然注销事件方法的逻辑可能相比之下稍许多了些，但它的实现也非常简单，只要只存在事件组key名的情况，或者删除某个事件队列中的某个事件句柄程序即可。 emit（触发一个事件）：123456789101112Event.prototype.emit = function(type)&#123; let cbs = this._events[type]; let args = tools.toArray(arguments,1); if (cbs) &#123; let i = 0; let j = cbs.length; for(;i&lt;j;i++)&#123; let cb = cbs[i]; cb.apply(this,args); &#125; &#125;&#125; 逻辑依然非常简单，通过事件名从this._events获取相应的事件句柄程序数组，然后将arguments转成数组，（这里考虑的是可能会传入参数）如果事件句柄程序数组存在，进行循环，再讲args参数apply给每一个取出来的事件句柄程序。 ##请描述一个网页从开始请求道最终显示的完整过程？12345678一个网页从请求到最终显示的完整过程一般可以分为如下7个步骤：（1）在浏览器中输入网址；（2）发送至DNS服务器并获得域名对应的WEB服务器IP地址；（3）与WEB服务器建立TCP连接；（4）浏览器向WEB服务器的IP地址发送相应的HTTP请求；（5）WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址；（6）浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面；（7）分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部数据显示。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？12345678Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。（1）与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概5M左右。（2）LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。（3）使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。 说说js中的event loop机制？首先javascript是单线程机制，就是指当我们在执行一个任务的时候，其它的事情都得等待他执行完毕 在js中所有任务分为两种, 同步任务及异步任务 执行栈执行主线程任务，当有操作dom，ajax交互，使用定时器异步操作的时候，这些任务会被移入到 callback queue 任务队列中当主线程任务执行完毕为空时，会读取callback queue队列中的函数，进入主线程执行上述过程会不断重复，也就是常说的Event Loop(事件循环) 在一个事件循环中,异步任务返回结果后会被扔进一个任务列队中，根据异步事件上的类型，这个事件会被放到对应的宏任务或者微任务列队中去， 当执行栈为空的时候，主线程会先查看微任务中的事件列队，如果微任务不是空先依次执行微任务，如果是空的再去宏任务列队中取出一个事件并把对应的回调加入到当前执行栈，如此反复，进入循环 下面用一道题来加深印象 1234567891011setTimeout(function () &#123; console.log(1);&#125;);new Promise( (resolve,reject) =&gt; &#123; console.log(2)&#125;).then( (val) =&gt; &#123; console.log(val);&#125;)输出的结果是2,1 解释： 定时器是宏任务，Promise是异步的是微任务。所以先执行微任务 console.log(2),在执行宏任务console.log(1) 怎么理解js中的内存泄漏?内存泄漏的定义为当程序不再需要的内存，由于某种原因其不会返回到操作系统或可用内存池，内存泄漏会导致一系列问题，比如: 运行缓阳，崩溃，高延迟等 js中常见的内存泄露: 1、意外的全局变量 2、遗忘的计时器或回调函数 3、脱离文档的DOM引用 4、闭包 怎么理解js中是原型链? 如何实现继承? 每个构造函数都有一个原型对象 每个原型对象都包含一个指向构造函数的指针 每个实例都包含一个指向原型对象的指针 查找方式是一层层向上查找直至顶层Object.prototype 实现继承的方式常用的有: 原型链继承 借用构造函数(call,apply) 组合继承(原型链＋构造函数) 原型式继承 寄生式组合式继承 new 运算符具体干了什么?1、创建一个空的对象 2、将空的对象的proto成员指向构造函数的prototype成员对象 3、调用构造函数将this指向前面创建的对象","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://yangyfeng.github.io/blogpost/tags/面试题/"}]},{"title":"文章置顶","slug":"博客文档/文章置顶","date":"2020-09-08T09:57:47.506Z","updated":"2020-12-11T09:15:44.090Z","comments":true,"path":"/posts/7a527409.html","link":"","permalink":"https://yangyfeng.github.io/posts/7a527409.html","excerpt":"文章的Front-matter填写top: true就置顶了。1top: true 这是一个示例博客。源码目录：https://github.com/xaoxuu/blog-example","text":"文章的Front-matter填写top: true就置顶了。1top: true 这是一个示例博客。源码目录：https://github.com/xaoxuu/blog-example 没有更多了哦。","categories":[{"name":"博客文档","slug":"博客文档","permalink":"https://yangyfeng.github.io/blogpost/categories/博客文档/"}],"tags":[]},{"title":"less在vue中的使用","slug":"CSS预处理/less在vue中的使用","date":"2020-09-07T16:00:00.000Z","updated":"2020-12-11T09:10:12.389Z","comments":true,"path":"/posts/8136685c.html","link":"","permalink":"https://yangyfeng.github.io/posts/8136685c.html","excerpt":"","text":"less在vue中的使用首先vue环境搭建成功 第一步：安装 less 和less-loader 1安装less依赖：npm install less less-loader --save 第二步：修改webpack.base.config.js文件，配置loader加载依赖，让其支持外部的less,在原来的代码上添加 1234567// 此种方法在控制台中标签样式显示的是style标签样式&#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\",&#125;, 1234567// 可以在控制台中看到当前标签样式来自于哪个less文件&#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\", options: &#123; sourceMap: true &#125;&#125; 第三步：在vue文件中的style标签中添加lang=”less”即可在标签中使用less，或者外部引入less","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"less","slug":"less","permalink":"https://yangyfeng.github.io/blogpost/tags/less/"},{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"}]},{"title":"go语言的安装","slug":"Golang/go语言的安装","date":"2020-09-07T16:00:00.000Z","updated":"2020-12-11T09:10:43.930Z","comments":true,"path":"/posts/7b1282c0.html","link":"","permalink":"https://yangyfeng.github.io/posts/7b1282c0.html","excerpt":"","text":"go语言的安装","categories":[{"name":"GoLang","slug":"GoLang","permalink":"https://yangyfeng.github.io/blogpost/categories/GoLang/"}],"tags":[]},{"title":"microsoft vs code换主题","slug":"开发工具/microsoft vs code换主题","date":"2020-09-07T11:47:00.000Z","updated":"2020-12-11T09:16:27.516Z","comments":true,"path":"/posts/e8b3e153.html","link":"","permalink":"https://yangyfeng.github.io/posts/e8b3e153.html","excerpt":"01、菜单选择 -&gt; 参考下图 02、对话框说明 -&gt; 参考下图","text":"01、菜单选择 -&gt; 参考下图 02、对话框说明 -&gt; 参考下图 01、菜单选择 -&gt; 参考下图 02、对话框说明 -&gt; 参考下图","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://yangyfeng.github.io/blogpost/tags/vscode/"}]},{"title":"microsoft vs code常用主题收集","slug":"开发工具/microsoft vs code常用主题收集","date":"2020-09-07T10:55:00.000Z","updated":"2020-12-11T09:16:00.808Z","comments":true,"path":"/posts/230490ec.html","link":"","permalink":"https://yangyfeng.github.io/posts/230490ec.html","excerpt":"页面太白不喜欢，黑色又太压抑怎么办？","text":"页面太白不喜欢，黑色又太压抑怎么办？ Slack Theme（本人很喜欢） cozygreen（近视眼必备&lt;(▰˘◡˘▰)&gt;）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/tags/开发工具/"}]},{"title":"vscode汉化教程","slug":"开发工具/vscode汉化教程","date":"2020-09-07T10:55:00.000Z","updated":"2020-12-11T09:16:40.535Z","comments":true,"path":"/posts/e8b3e153.html","link":"","permalink":"https://yangyfeng.github.io/posts/e8b3e153.html","excerpt":"VSCODE默认情况下是英文的。 相关推荐：《vscode使用教程》","text":"VSCODE默认情况下是英文的。 相关推荐：《vscode使用教程》 点击左侧菜单栏最底下的四方形按钮打开扩展程序界面，在输入框内输入Chinese并找到【Chinese (Simplified) Language Pack for Visual Studio Code】这个插件。在这个插件的详细界面点击【Install】按钮进行安装。 安装完成后按快捷键【CTRL+SHILF+P】打开命令面板并输入【config】后找到【Configure Display Language】选项并点击。 在接下来的二级菜单选择【zh-cn】，此时编辑器会弹出个访问窗口是否要重启编辑器生效语言的修改，点击【restart】按钮重新启动编辑器。 重启编辑器后就汉化成中文成功了 以上就是vscode如何汉化的详细内容","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://yangyfeng.github.io/blogpost/categories/开发工具/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://yangyfeng.github.io/blogpost/tags/vscode/"}]},{"title":"什么是前端工程化","slug":"前端工程化/什么是前端工程化","date":"2020-09-04T08:20:00.000Z","updated":"2020-12-11T09:15:08.368Z","comments":true,"path":"/posts/b4383892.html","link":"","permalink":"https://yangyfeng.github.io/posts/b4383892.html","excerpt":"前端工程化是现代前端的必备技能快狗打车前端团队为例。 前端的开发框架以 Vue 为主，使用 Webpack 解决接口 mock、代码检查、代码编译、构建、压缩、添加版本号、部署等全流程的工作。涉及到的技术点有 Vue、Vuex、ESlint、stylelint、mock、Webpack、Sass、PostCSS 等。对前端的要求相比几年前已经从单纯的 JS、CSS 问题变成了更多工程化为主的问题。 前端工程化是一个很大的话题，甚至到现在都没有一个准确的定义。笔者对前端工程化的理解是：一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化。","text":"前端工程化是现代前端的必备技能快狗打车前端团队为例。 前端的开发框架以 Vue 为主，使用 Webpack 解决接口 mock、代码检查、代码编译、构建、压缩、添加版本号、部署等全流程的工作。涉及到的技术点有 Vue、Vuex、ESlint、stylelint、mock、Webpack、Sass、PostCSS 等。对前端的要求相比几年前已经从单纯的 JS、CSS 问题变成了更多工程化为主的问题。 前端工程化是一个很大的话题，甚至到现在都没有一个准确的定义。笔者对前端工程化的理解是：一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化。 实现前端工程化的好处在前端领域越来越繁荣，越来越复杂的今天，学习前端工程化又能给我们带来哪些好处呢？ 1. 极大提升开发效率 前端工程化的演进可以极大地提升开发效率。前端发展到现在，社区涌现出大量的优秀框架和工具，得以将前端工程师从繁重的工作中解脱出来。 举个例子，同样地给一个 dom 元素绑定一个 click 事件，使用纯 JS 可能这样做： 123document.getElementById('myDom').addEventListener('click', function(e)&#123; // do some thing&#125;) 我们引入 jQuery 的情况下，就简单了许多： 123$('#myDom').click(function()&#123; // do some thing&#125;) 如果在 Vue 中，既简单又清晰： 123456789&lt;div @click=\"doSomething\"&gt;&lt;/div&gt;// ...methods: &#123; doSomething: function () &#123; // do some thing &#125;&#125; 如果有大量的事件绑定，没有开发工具的支撑，将有大量重复的代码需要写，想想就头疼。效率之低下可见一斑。 为了减少请求数，前端开发者通常会把大量尺寸较小、细碎的小图片合并成一张大的透明的雪碧图，在 CSS 中通过设置元素的 background-position 来使用图片。如果是完全手动去拼图、测距，将耗费大量的时间。但在雪碧图插件 webpack-spriteSmith 的帮助下，小图可以自动拼成雪碧图，并生成对应的 CSS 样式，插件能帮助我们处理这种毫无技术含量的体力活，效率加倍。 再举一个例子，没有前端脚手架的情况下，如果从零开发一个项目，需要花费大量的时间去初始化项目，比如安装各种 npm 包、配置各种 Webpack 的 loader、配置热加载。如果碰到环境搭建不顺利的情况，还需要花费很长时间去排查问题，单单一个项目初始化的动作就足以耗费一两天的时间。有脚手架工具的情况下，只需要简单的一个初始化命令，2 分钟的时间就可以完成项目的初始化。前端只需要聚焦到业务开发本身，效率大幅提升。 2. 降低大型项目的开发难度 首先前端工程化中提倡模块化、组件化。模块化的思想将大型项目的功能进行分解，分拆成一个个独立的模块。每个模块的开发难度直线下降。同时基于版本控制工具 Git，多个开发者可以并行开发，提升开发效率。项目在后期迭代的时候，由于每个模块相对独立，耦合性极低，一个功能的调整往往只需要修改其中的一个模块就可以，风险可控。不至于出现改动一处代码，引发全局问题的情况。 其次，前端工程化提倡用完善的流程规范和代码规范来保证大型应用的质量和可维护性。比如通过 ESlint、stylelint 对代码进行自动校验，通过评审、详细设计、开发、联调、测试、上线等每个环节的控制，确保项目的高质量和按时交付。向主分支合并代码必须经过 code review。流程规范确保了大型项目质量和可维护性的同时能够如期交付。 更易获得面试官青睐 依稀记得六七年前去面试，遇到面试题大概是这种风格：“如何实现水平垂直居中”，“js 事件委托的原理是什么”，“常见的 css hack 方式有什么？”，“$(function(){})与 window.onload 有什么区别？” 今天面试遇到的面试题大概是这种风格：“能讲下 Vue 实现双向数据绑定的原理吗？”，“Webpack 中如何配置 Babel？”，“promise 和 await/async 的区别是什么？” 如果想进入大公司工作，前端工程化更是需要具备的基本素质。大公司的业务往往非常复杂，而且对稳定性的要求极高。与之相对应的前端工程化程度很高，各种配套的基础建设很成熟。比如美团点评体系化的工程化方案、移动组件库 Vix、自动化测试工具 Freekite、Hybrid 功能体验的解决方案 Titans 等。想得到这些公司的青睐，候选人需要在前端工程化领域有较深的积累。 前端的岗位技能已经发生深刻的变化。有人甚至戏言成前端工程师为前端配置工程师。 fouber（张云龙）曾经在自己的博文中说： 1\"前端是一种技术问题较少、工程问题较多的软件开发领域。” 所以前端工程化是每个现代前端人应该必备的技能。 谁需要前端工程化？3. 初中级前端工程师 对于初级中级前端工程师来说，由于工作经验较少，技术的宽度和广度都不足，对前端工程化的认知其实也是不够的，一上来整体掌握前端工程化肯定是有困难的。对于这部分同学来讲，首要的事情要学会去”用”，循序渐进地去了解其中的原理。例如在开发之余，自己学一学如何实现一个简单的脚手架工具，了解一下日常开发必备的脚手架是如何实现的，以点带面地学习里面用到的技术点。 期望晋升的前端工程师 前端工程化能力也是一个资深前端的必备技能。工作好多年了，如果连前端工程化都知之甚少，甚至连一个基本的脚手架都不能自己搭建，这是不及格的。如果将来带团队，怎么能指导团队同学，怎么能带领团队进步呢？如果去参加公司的晋升，也是没有说服力的。因为想要晋升高 T，必然需要在效率和性能优化等方面有深厚的积累和贡献。 所以，无论你是处在什么阶段，深入了解一下前端工程化都是极有必要的。 前端应用越来越复杂，对前端工程化的要求越来越高。脚手架作为目前前端工程化的一个重要的组成部分，在开发过程中扮演了至关重要的角色。现在几乎所有主流前端几框架都有自己配套的脚手架，无疑给开发者带来了极大的便利。但正如上文所述，很多开发者由于本身入行较短，或者很多工作多年的开发者由于公司业务的原因，没有机会接触到前端工程化领域。 学习目录开篇词：到底什么是前端工程化 第一部分：模板设计 第01课：模板功能设计第02课：Webpack 基本介绍第03课：搭建项目模板框架第04课：前端模块化解决方案第05课：搭建本地开发环境第06课：搭建本地 Mock 服务第07课：引入代码检查工具第08课：自动生成雪碧图第09课：根据浏览器构建第10课：根据环境构建第11课：集成移动端调试工具第12课：引入单元测试第13课：引入 e2e 测试第14课：Webpack 构建性能优化第15课：添加部署功能第16课：聚合项目配置并模板化 第二部分：命令行设计 第17课：cli 功能设计（上）第18课：cli 功能设计（下） 结语：开放的心态才是更高阶的工程化 学完后至少有以下几点收获： 对前端工程化有一个系统认知； 能独立设计一套前端工程化解决方案； 知识广度上有大幅提升； 进入更好的平台，获得更好的薪酬。","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yangyfeng.github.io/blogpost/tags/前端工程化/"}]},{"title":"vue项目中webpack使用HtmlWebpackPlugin进行cdn配置","slug":"Vue/webpack使用HtmlWebpackPlugin进行cdn配置","date":"2019-07-16T05:27:58.000Z","updated":"2020-12-11T09:14:19.442Z","comments":true,"path":"/posts/f8a3109a.html","link":"","permalink":"https://yangyfeng.github.io/posts/f8a3109a.html","excerpt":"CDN服务商的选择要使用cdn功能，就需要cdn服务商，我们可以自己搭建，也可以使用一些比较知名的服务商，庆幸的是市面上有不少的免费cdn服务商，如： BootCDN unpkg 其中BootCDN 是 Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务，项目资源同步于 cdnjs 仓库。界面相对比较好看，且支持搜索功能，可以在线测试cdn是否正常，所以下面以Bootcdn为例说明。 webpack的作用在前段项目开发中，我们经常使用webpack进行项目搭建， 主要作用有两个，分别是 1.启动服务器环境，用于调试代码 2.构建项目，生成静态资源 在webpack中使用cdn是在打包生成静态资源的时候做处理，主要原理是使用html-webpack-plugin动态插入cdn链接。 关于webpack的使用这里不做过多的介绍，将以vue–cli 2.x生成的默认项目为例做介绍","text":"CDN服务商的选择要使用cdn功能，就需要cdn服务商，我们可以自己搭建，也可以使用一些比较知名的服务商，庆幸的是市面上有不少的免费cdn服务商，如： BootCDN unpkg 其中BootCDN 是 Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务，项目资源同步于 cdnjs 仓库。界面相对比较好看，且支持搜索功能，可以在线测试cdn是否正常，所以下面以Bootcdn为例说明。 webpack的作用在前段项目开发中，我们经常使用webpack进行项目搭建， 主要作用有两个，分别是 1.启动服务器环境，用于调试代码 2.构建项目，生成静态资源 在webpack中使用cdn是在打包生成静态资源的时候做处理，主要原理是使用html-webpack-plugin动态插入cdn链接。 关于webpack的使用这里不做过多的介绍，将以vue–cli 2.x生成的默认项目为例做介绍 html-webpack-plugin的使用html-webpack-plugin是webpack的一个插件，可以动态的创建和编辑html内容，在html中使用esj语法可以读取到配置中的参数，简化了html文件的构建。 我们这次主要是使用它来动态插入cdn链接，如link标签和script标签。 创建Vue项目vue-cli 2.x1vue init webpack webpack-cdn-demo 创建名为webpack-cdn-demo，类型为webpack的vue项目，如果安装的vue-cli是3.x版本，命令不太一样，详细可看vue-cli 3。 安装依赖12$ cd webpack-cdn-demo$ npm install 启动项目1$ npm run dev 目录结构 1234567891011+-- build| +-- utils.js js 工具类| +-- webpack.base.conf.js webpack基础配置| +-- webpack.dev.conf.js webpack开发配置| +-- webpack.prod.conf.js webpack构建配置+-- config+-- src| +-- App.vue vue文件组件| +-- main.js 入口文件+-- index.html 页面+-- package.json 项目文件 其中build文件夹中的webpack.prod.conf.js是我们主要注意的文件,我们在该文件中动态设置不需要被打包的模块并构建出合适的链接。 确定需要使用CDN的模块在webpack项目中，所引入的第三方资源会被统一打包进vender文件中，我们通过webpack的externals属性可以设置打包时排除该模块，详情说明见外部扩展(externals)。 在前面的步骤中，我们创建的项目包括vue、vue-router，在正式开发在还会有ui库，如element-ui，为了方便演示，我们再安装element-ui和axios两个模块，并实现在构建是把这是个模块以cdn的形式引入。 所需模块 vue vue-router element-ui axios 1npm install element-ui axios -S 注意安装时记得 -S，它的作用是安装完后在package.json项目文件中插入记录，后续操作需要读取已安装模块 确定CDN资源URI对于cdn，我们可以自己搭建，也可以使用专业的cdn服务商，这里使用免费的cdn bootcdn。选用免费cdn有很多好处，但毕竟有隐患，那就是服务有可能会奔溃。 bootcdn https://www.bootcdn.cn 依次搜索出前面模块，结果如下: 模块 版本 js css vue 2.5.2 https://cdn.bootcss.com/vue/2.5.2/vue.min.js - vue-router 3.0.1 https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js - element-ui 2.6.3 https://cdn.bootcss.com/element-ui/2.6.1/index.js https://cdn.bootcss.com/element-ui/2.6.1/theme-chalk/index.css axios 0.18.0 https://cdn.bootcss.com/axios/0.18.0/axios.min.js - 按照规律，得出cdn资源路径规则为 1https://cdn.bootcss.com + 模块名 + 版本号 + 具体路径 其他cdn服务商同理 打包前的处理build/utils.js添加读取事件使用cdn其实也就是在webpack热启动和打包项目的时候动态插入script和style链接，为了方便维护，我们通过在build/utils.js文件上添加几个方法，将来在webpack.dev.conf.js和webpack.prod.conf.js上可以使用。 如果没有build/utils.js，可以在其他文件上添加，只要在后续步骤中能操作到就行 添加cdn根地址 12// build/utils.js 国内免费cdn镜像源exports.cdnBaseHttp = 'https://cdn.bootcss.com'; 添加cdn模块 按照需要删改 1234567// build/utils.js external配置exports.externalConfig = [ &#123; name: 'vue', scope: 'Vue', js: 'vue.min.js' &#125;, &#123; name: 'vue-router', scope: 'VueRouter', js: 'vue-router.min.js' &#125;, &#123; name: 'axios', scope: 'axios', js: 'axios.min.js' &#125;, &#123; name: 'element-ui', scope: 'ELEMENT', js: 'index.js', css: 'theme-chalk/index.css' &#125;,]; name 模块名称，与package.json同名 scope 模块作用域命名 js js地址 css css地址 这里特别注意scope，它是webpack配置的external参数下的信息，比如vue的作用域命名是Vue，vue-router的作用域命名是VueRouter，element-ui的作用域命名是ELEMENT，同理，jq的作用域命名是JQuery，具体做法是先引入该资源，然后在控制台依次输入近似的值，一个个匹配(目前没找到更好的做法)。 添加获取版本号方法 123456789101112// build/utils.js 获取模块版本号exports.getModulesVersion = () =&gt; &#123; let mvs = &#123;&#125;; let regexp = /^npm_package_.&#123;0,3&#125;dependencies_/gi; for (let m in process.env) &#123; // 从node内置参数中读取，也可直接import 项目文件进来 if (regexp.test(m)) &#123; // 匹配模块 // 获取到模块版本号 mvs[m.replace(regexp, '').replace(/_/g, '-')] = process.env[m].replace(/(~|\\^)/g, ''); &#125; &#125; return mvs;&#125;; 导出不需要被打包的cdn模块配置重点 123456789101112131415161718// build/utils.jsexports.getExternalModules = config =&gt; &#123; let externals = &#123;&#125;; // 结果 let dependencieModules = this.getModulesVersion(); // 获取全部的模块和版本号 config = config || this.externalConfig; // 默认使用utils下的配置 config.forEach(item =&gt; &#123; // 遍历配置 if (item.name in dependencieModules) &#123; let version = dependencieModules[item.name]; // 拼接css 和 js 完整链接 item.css = item.css &amp;&amp; [this.cdnBaseHttp, item.name, version, item.css].join('/'); item.js = item.js &amp;&amp; [this.cdnBaseHttp, item.name, version, item.js].join('/'); externals[item.name] = item.scope; // 为打包时准备 &#125; else &#123; throw new Error('相关依赖未安装，请先执行npm install ' + item.name); &#125; &#125;); return externals;&#125;; webpack.dev.conf.js添加cdn配置在webpack热启动本地调试的时候，我们可以使用cdn。 获取cdn配置 12345// build/webpack.dev.conf.js 大概在15行const externalConfig = JSON.parse(JSON.stringify(utils.externalConfig)); // 读取配置utils.getExternalModules(externalConfig); // 获取到合适的路径（引用类型，自动改变）// const devWebpackConfig = merge ....... 在build/webpack.dev.conf.js中，默认已经引入了utils.js，所以可以直接调用相关方法，如果是自定义的文件，记得引入。 HtmlWebpackPlugin插件中导出cdn 紧接着我们在该文件下找到devWebpackConfig下的plugins下的HtmlWebpackPlugin插件，它的作用是动态构建html页面，原始配置如下： 123456new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true&#125;),// 代表处理根目录下的index.html文件 我们可以往里面添加点自定义属性，方便在index.html中调用。，修改如下： 1234567new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, cdnConfig: externalConfig, // cdn配置 onlyCss: true, //dev下只加载css&#125;), 其中cdnConfig和onlyCss自定义属性，在html上通过htmlWebpackPlugin.options可以读取到。 更多html-webpack-plugin配置情况官网，这里暂时不需要更多。 webpack.prod.conf.js添加cdn配置和忽略模块在打包的时候，我们使用cdn，配置和前面dev的差不多，只不过需要做多一步。 获取cdn配置 12345// build/webpack.prod.conf.js 大概在15行const externalConfig = JSON.parse(JSON.stringify(utils.externalConfig)); // 读取配置const externalModules = utils.getExternalModules(externalConfig); // 获取到合适路径和忽略模块// const webpackConfig = merge(baseWebpackConfig.... 注意此处的externalModules，后面用到，也就是比dev多的步骤。 webpck配置加多个属性externals externals代表构建时不需要被处理的模块，也就是前面说的scope需要注意的地方。 123456// build/webpack.prod.conf.jsconst webpackConfig = merge(baseWebpackConfig, &#123; externals: externalModules, // 构建时忽略的资源 // 其他属性&#125; HtmlWebpackPlugin插件中导出cdn 和dev一样，我们修改webpackConfig下的plugins下的HtmlWebpackPlugin插件配置 (这里的默认配置比dev的多，主要是css压缩和js压缩相关) 12345new HtmlWebpackPlugin(&#123; // 其他默认配置 cdnConfig: externalConfig, // cdn配置 onlyCss: false, //加载css&#125;), 加入和dev一样的两个配置，不过需要把onlyCss改为true，因为我们希望打包时不单单使用css。 index.html插入相关链接webpack配置已经完成，在html-webpack-plugin中已经添加了相关参数，我们再在页面上可以直接使用，使用语法是ejs，和asp.net，jsp，php类似。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- 其他标签 --&gt; &lt;% htmlWebpackPlugin.options.cdnConfig.forEach(function(item)&#123; if(item.css)&#123; %&gt; &lt;link href=\"&lt;%= item.css %&gt;\" rel=\"stylesheet\" /&gt; &lt;% &#125;&#125;) %&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 其他标签 --&gt; &lt;% htmlWebpackPlugin.options.cdnConfig.forEach(function(item)&#123; if(item.js &amp;&amp; !htmlWebpackPlugin.options.onlyCss)&#123; %&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= item.js %&gt;\"&gt;&lt;/script&gt; &lt;% &#125;&#125;) %&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 通过&lt;% %&gt; 和 htmlWebpackPlugin.options 用js遍历插入link标签和script标签。 ps: 修改了webpack配置，需要重启项目才会生效 愉快的开发此时启动项目，查看控制台或者查看源代码，可以清楚的相关资源来源 有一个更好的插件webpack-cdn-plugin 原文链接","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://yangyfeng.github.io/blogpost/tags/webpack/"}]},{"title":"git子目录创建分支","slug":"Git/git子目录创建分支","date":"2019-07-13T06:01:41.000Z","updated":"2020-12-11T09:18:16.097Z","comments":true,"path":"/posts/2bdc4097.html","link":"","permalink":"https://yangyfeng.github.io/posts/2bdc4097.html","excerpt":"使用场景 例如，在项目Game中有一个子目录AI。Game和AI分别是一个独立的git项目，可以分开维护。为了避免直接复制粘贴代码，我们希望Game中的AI子目录与AI的git项目关联，有3层意思： 1.AI子目录使用AI的git项目来填充，内容保持一致。 2.当AI的git项目代码有更新，可以拉取更新到Game项目的AI子目录来。 3.反过来，当Game项目的AI子目录有变更，还可以推送这些变更到AI的git项目。 用git subtree可以轻松满足上面的需求。","text":"使用场景 例如，在项目Game中有一个子目录AI。Game和AI分别是一个独立的git项目，可以分开维护。为了避免直接复制粘贴代码，我们希望Game中的AI子目录与AI的git项目关联，有3层意思： 1.AI子目录使用AI的git项目来填充，内容保持一致。 2.当AI的git项目代码有更新，可以拉取更新到Game项目的AI子目录来。 3.反过来，当Game项目的AI子目录有变更，还可以推送这些变更到AI的git项目。 用git subtree可以轻松满足上面的需求。 git subtree用法1. 第一次添加子目录，建立与git项目的关联建立关联总共有2条命令。 1234567语法：git remote add -f &lt;子仓库名&gt; &lt;子仓库地址&gt; 解释：其中-f意思是在添加远程仓库之后，立即执行fetch。语法：git subtree add --prefix=&lt;子目录名&gt; &lt;子仓库名&gt; &lt;分支&gt; --squash 解释：–squash意思是把subtree的改动合并成一次commit，这样就不用拉取子项目完整的历史记录。–prefix之后的=等号也可以用空格。 示例12git remote add -f ai https://github.com/aoxu/ai.git git subtree add --prefix=ai ai master --squash 2. 从远程仓库更新子目录更新子目录有2条命令。12语法：git fetch &lt;远程仓库名&gt; &lt;分支&gt; 语法：git subtree pull --prefix=&lt;子目录名&gt; &lt;远程分支&gt; &lt;分支&gt; --squash 示例12git fetch ai master git subtree pull --prefix=ai ai --squash 3. 从子目录push到远程仓库（确认你有写权限）推送子目录的变更有1条命令。1语法：git subtree push --prefix=&lt;子目录名&gt; &lt;远程分支名&gt; 分支 示例1git subtree push --prefix=ai ai master 原文地址：http://cssor.com/git-subtree-usage.html","categories":[{"name":"Git","slug":"Git","permalink":"https://yangyfeng.github.io/blogpost/categories/Git/"}],"tags":[]},{"title":"git常用命令","slug":"Git/git常用命令","date":"2019-07-13T05:48:01.000Z","updated":"2020-12-11T09:11:03.146Z","comments":true,"path":"/posts/423abe9e.html","link":"","permalink":"https://yangyfeng.github.io/posts/423abe9e.html","excerpt":"推送到远程仓库：http://blog.csdn.net/u011043843/article/details/33336625 github设置添加SSH：https://blog.csdn.net/binyao02123202/article/details/20130891","text":"推送到远程仓库：http://blog.csdn.net/u011043843/article/details/33336625 github设置添加SSH：https://blog.csdn.net/binyao02123202/article/details/20130891 一.设置git的全局变量(用户名和邮箱)121. git config --global user.name”用户名(建议是英文)” 创建用户名2. git config --global user.email”邮箱地址” 创建邮箱 二.创建一个新的仓库12341. git clone &lt;url&gt; 从远程服务器克隆一个完全一样的版本库到本地 ：2. git add . 暂存文件3. git commit -a &lt;注释&gt; 提交4. git push -u origin master 推送（推送到主分支） 三.本地已经创建该目录123451. git init .初始化2. git remote add origin ssh://git.com/lsy/demo.git 增加一个远程服务端 3. git add 文件名/工程名 .（所有文件） 暂存文件4. git commit -m “Initial commit” 提交5. git push -u origin master 推送（推送到主分支） 四.存在git仓库12341. cd demo 进入该仓库2. git remote add origin ssh://git.com/lsy/hhh.git（git pull 同步代码到本地）增加一个远程服务端3. git push -u origin --all（上传代码到远程库） 推送4. git push -u origin --tags 推送标签到主机 五.常用命令：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. git branch 查看本地所有分支2. git branch -a 查看远程所有的分支3. git branch -r 查看远程所有分支(不包括当前分支)4. git push origin --delete &lt;name&gt; 可以删除远程分支5. git branch -d &lt;name&gt; 可以删除本地分支（在主分支中）6. git status 查看当前状态 7. git commit -am \"init\" 提交并且加注释 8. git subtree push --prefix= [目录地址(dist)] origin [分支名称(gh-pages)] 单个目录托管命令9. git remote add origin git@192.168.1.119:ndshow10. git push origin master 将文件给推到服务器上 11. git remote show origin 显示远程库origin里的资源 12. git push origin master:develop 提交本地master分支作为远程的develop分支13. git checkout --track origin/dev 切换到远程dev分支14. git checkout -b dev 建立一个新的本地分支dev15. git merge origin/dev 将分支dev与当前分支进行合并16. git checkout dev 切换到本地dev分支17. git remote show 查看远程库18. git remote remove &lt;name&gt; 删除remote19. git add . 暂存文件全部20. git rm 文件名(包括路径) 从git中删除指定文件21. git clone git:// 下载22. github.com/schacon/grit.git 从服务器上将代码给拉下来23. git config --list 看所有用户24. git ls-files 看已经被提交的25. git rm [file name] 删除一个文件26. git commit -a 提交当前repos的所有的改变27. git add [file name] 添加一个文件到git index28. git commit -v 当你用－v参数的时候可以看commit的差异29. git commit -m \"This is the message describing the commit\" 添加commit信息30. git commit -a -a是代表add，把所有的change加到git index里然后再commit31. git commit -a -v 一般提交命令32. git log 看你commit的日志33. git diff 查看尚未暂存的更新34. git rm a.a 移除文件(从暂存区和工作区中删除)35. git rm --cached a.a 移除文件(只从暂存区中删除)36. git commit -m \"remove\" 移除文件(从Git中删除)37. git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)38. git diff --cached 或 $ git diff --staged 查看尚未提交的更新39. git stash push 将文件给push到一个临时空间中40. git stash pop 将文件从临时空间pop下来41. git remote add origin git@github.com:username/Hello-World.git42. git push origin master 将本地项目给提交到服务器中43. git pull 本地与服务器端同步44. git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。45. git push origin serverfix:awesomebranch46. git fetch 相当于是从远程获取最新版本到本地，不会自动merge47. git commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：48. git branch branch_0.1 master 从主分支master创建branch_0.1分支49. git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.050. git checkout branch_1.0/master 切换到branch_1.0/master分支51. git branch 删除远程branch52. git push origin :branch_remote_name53. git branch -r -d branch_remote_name54. git reset --hard commit_id 版本回退55. git log可以查看提交历史56. git reflog查看命令历史","categories":[{"name":"Git","slug":"Git","permalink":"https://yangyfeng.github.io/blogpost/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yangyfeng.github.io/blogpost/tags/git/"}]},{"title":"vue.config.js配置","slug":"Vue/vue.config.js配置","date":"2019-07-13T05:41:06.000Z","updated":"2020-12-11T09:13:20.459Z","comments":true,"path":"/posts/4de2b0c3.html","link":"","permalink":"https://yangyfeng.github.io/posts/4de2b0c3.html","excerpt":"在项目根目录下创建vue.config.js文件：详细代码如下：","text":"在项目根目录下创建vue.config.js文件：详细代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177const webpack = require('webpack')const path = require('path'); function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; /* vue-cli3 项目配置文件 */ /* 基本路径 默认情况下，我们假设您的应用程序将部署在域的根上 例如：https://www.my-app.com/ 如果应用程序部署在子路径上，则需要指定 这里的子路径，例如，如果应用程序部署在 https://www.foobar.com/my-app/ 然后把这个变成 '/my-app/' 例如：https://www.example.com/project/v1.1/index.html baseUrl 为 /project/v1.1/ baseUrl: process.env.NODE_ENV === 'production' ? '/online/' : '/' */ baseUrl: '/', // 输出文件目录 // 在npm run build时 生成文件的目录 type:string, default:'dist' outputDir: 'dist', /* 构建多页时使用 index: &#123; // 入口 entry: 'src/index/main.js', // 模板 template: 'public/index.html', // output as dist/index.html filename: 'index.html' &#125; */ pages: &#123; type: Object, Default: undefined &#125;, // 用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下 // 网络请求的静态目录为 public 不参与打包 请求地址 ./ 直接指向 public 目录 assetsDir: 'assets', // 指定生成的 index.html 的输出路径 (打包之后，改变系统默认的index.html的文件名) indexPath: 'index.html', /* 如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置 lintOnSave: process.env.NODE_ENV !== 'production eslint-loader eslint检查,是否在保存的时候检查 lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint */ lintOnSave: true, // 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变) filenameHashing: false, /* 使用编译器生成全在浏览器 是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false) https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only */ runtimeCompiler: false, /* babel-loader在默认情况下跳过`node_modules`模块 显式地使用此选项来转换依赖项 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来 */ transpileDependencies: [ /* string or regex */ ], // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, /* 调整内部webpack配置 see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。 chainWebpack: config =&gt; &#123; config.module .rule('images') .use('url-loader') .loader('url-loader') .tap(options =&gt; &#123; // 修改它的选项... return options &#125;), config.entry.app = [\"babel-polyfill\", resolve('src/main.js')], // 别名 config.resolve.alias .set('@', resolve('src')) .set('./@assets', resolve('src/assets')) .set('@components', resolve('src/components')) .set('@font', resolve('src/font')); &#125;, */ /* configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125; */ // 插件配置 configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; jQuery: 'jquery', $: 'jquery' &#125;) ] &#125;, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125;, // 启用 CSS modules for all css / pre-processor files. modules: false &#125;, // 在生产中使用Babel＆TS thread-loader // 默认情况下，如果机器有超过1个内核 parallel: require('os').cpus().length &gt; 1, // PWA（渐进式WEB应用） 插件相关配置 https://segmentfault.com/a/1190000012353473 // see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: &#123;&#125;, // 它支持webPack-dev-server的所有选项 // See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#configuring-proxy devServer: &#123; // 主机名 host: process.env.HOST || 'localhost', // 端口号 port: process.env.PORT || 8080, // 是否支持https安全访问 https: false, // 配置自动启动浏览器 process.platform === 'darwin' open: true, // 热更新（webpack已实现了，这里false即可） hotOnly: false, compress: true, /* 配置跨域处理,只有一个代理 proxy: 'http://localhost:4000' 配置多个代理 &#123; '/api': &#123; target: '&lt;url&gt;', ws: true, changeOrigin: true &#125;, '/foo': &#123; target: '&lt;other_url&gt;' &#125; &#125; */ proxy: null, // 请求之前 before: app =&gt; &#123;&#125; &#125;, // 第三方插件配置 css loader pluginOptions: &#123; 'style-resources-loader': &#123; preProcessor: 'less', patterns: [] &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"}]},{"title":"vue轮子工厂","slug":"Vue/vue轮子工厂","date":"2019-07-13T05:26:53.000Z","updated":"2020-12-11T09:13:50.501Z","comments":true,"path":"/posts/da177769.html","link":"","permalink":"https://yangyfeng.github.io/posts/da177769.html","excerpt":"Vue轮子工厂","text":"Vue轮子工厂 组件名字 组件描述 组件git创库地址 element element - 饿了么出品的Vue2的web UI工具套件 https://github.com/ElemeFE/element Vux Vux - 基于Vue和WeUI的组件库 https://github.com/airyland/vux mint-ui mint-ui - Vue 2的移动UI元素 https://github.com/ElemeFE/mint-ui iview iview - 基于 Vuejs 的开源 UI 组件库 https://github.com/iview/iview Keen-UI Keen-UI - 轻量级的基本UI组件合集 https://github.com/JosephusPaye/Keen-UI vue-material vue-material - 通过Vue Material和Vue 2建立精美的app应用 https://github.com/marcosmoura/vue-material muse-ui muse-ui - 三端样式一致的响应式 UI 库 https://github.com/museui/muse-ui vuetify vuetify - 为移动而生的Vue JS 2组件框架 https://github.com/vuetifyjs/vuetify vonic vonic - 快速构建移动端单页应用 https://github.com/wangdahoo/vonic eme eme - 优雅的Markdown编辑器 https://github.com/egoist/eme vue-multiselect vue-multiselect - Vue.js选择框解决方案 https://github.com/monterail/vue-multiselect vue-table vue-table - 简化数据表格 https://github.com/ratiw/vue-table VueCircleMenu VueCircleMenu - 漂亮的vue圆环菜单 https://github.com/OYsun/VueCircleMenu vue-chat vue-chat - vuejs和vuex及webpack的聊天示例 https://github.com/Coffcer/vue-chat radon-ui radon-ui - 快速开发产品的Vue组件库 https://github.com/luojilab/radon-ui vue-waterfall vue-waterfall - Vue.js的瀑布布局组件 https://github.com/MopTym/vue-waterfall vue-carbon vue-carbon - 基于 vue 开发MD风格的移动端 https://github.com/myronliu347/vue-carbon vue-beauty vue-beauty - 由vue和ant design创建的优美UI组件 https://github.com/FE-Driver/vue-beauty vue-blu vue-blu - 帮助你轻松创建web应用 https://github.com/chenz24/vue-blu vueAdmin vueAdmin - 基于vuejs2和element的简单的管理员模板 https://github.com/taylorchen709/vueAdmin vue-syntax-highlight vue-syntax-highlight - Sublime Text语法高亮 https://github.com/vuejs/vue-syntax-highlight vue-infinite-scroll vue-infinite-scroll - VueJS的无限滚动指令 https://github.com/ElemeFE/vue-infinite-scroll Vue.Draggable Vue.Draggable - 实现拖放和视图模型数组同步 https://github.com/David-Desmaisons/Vue.Draggable vue-awesome-swiper vue-awesome-swiper - vue.js触摸滑动组件 https://github.com/surmon-china/vue-awesome-swiper vue-calendar vue-calendar - 日期选择插件 https://github.com/jinzhe/vue-calendar bootstrap-vue bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件 https://github.com/pi0/bootstrap-vue vue-swipe vue-swipe - VueJS触摸滑块 https://github.com/ElemeFE/vue-swipe vue-amap vue-amap - 基于Vue 2和高德地图的地图组件 https://github.com/ElemeFE/vue-amap vue-chartjs vue-chartjs - vue中的Chartjs的封装 https://github.com/apertureless/vue-chartjs vue-datepicker vue-datepicker - 日历和日期选择组件 https://github.com/hilongjw/vue-datepicker markcook markcook - 好看的markdown编辑器 https://github.com/jrainlau/markcook vue-google-maps vue-google-maps - 带有双向数据绑定Google地图组件 https://github.com/GuillaumeLeclerc/vue-google-maps vue-progressbar vue-progressbar - vue轻量级进度条 https://github.com/hilongjw/vue-progressbar vue-picture-input vue-picture-input - 移动友好的图片文件输入组件 https://github.com/alessiomaffeis/vue-picture-input vue-infinite-loading vue-infinite-loading - VueJS的无限滚动插件 https://github.com/PeachScript/vue-infinite-loading vue-upload-component vue-upload-component - Vuejs文件上传组件 https://github.com/lian-yue/vue-upload-component vue-datetime-picker vue-datetime-picker - 日期时间选择控件 https://github.com/Haixing-Hu/vue-datetime-picker vue-scroller vue-scroller - Vonic UI的功能性组件 https://github.com/wangdahoo/vue-scroller vue2-calendar vue2-calendar - 支持lunar和日期事件的日期选择器 https://github.com/icai/vue2-calendar vue-video-player vue-video-player - VueJS视频及直播播放器 https://github.com/surmon-china/vue-video-player vue-fullcalendar vue-fullcalendar - 基于vue.js的全日历组件 https://github.com/Wanderxx/vue-fullcalendar rubik rubik - 基于Vuejs2的开源 UI 组件库 https://github.com/ccforward/rubik VueStar VueStar - 带星星动画的vue点赞按钮 https://github.com/OYsun/VueStar vue-mugen-scroll vue-mugen-scroll - 无限滚动组件 https://github.com/egoist/vue-mugen-scroll mint-loadmore mint-loadmore - VueJS的双向下拉刷新组件 https://github.com/mint-ui/mint-loadmore vue-tables-2 vue-tables-2 - 显示数据的bootstrap样式网格 https://github.com/matfish2/vue-tables-2 vue-virtual-scroller vue-virtual-scroller - 带任意数目数据的顺畅的滚动 https://github.com/Akryum/vue-virtual-scroller DataVisualization DataVisualization - 数据可视化 https://github.com/SimonZhangITer/DataVisualization vue-quill-editor vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器 https://github.com/surmon-china/vue-quill-editor Vueditor Vueditor - 所见即所得的编辑器 https://github.com/hifarer/Vueditor vue-html5-editor vue-html5-editor - html5所见即所得编辑器 https://github.com/PeakTai/vue-html5-editor vue-msgbox vue-msgbox - vuejs的消息框 https://github.com/ElemeFE/vue-msgbox vue-slider vue-slider - vue 滑动组件 https://github.com/warpcgd/vue-slider vue-core-image-upload vue-core-image-upload - 轻量级的vue上传插件 https://github.com/Vanthink-UED/vue-core-image-upload vue-slide vue-slide - vue轻量级滑动组件 https://github.com/hilongjw/vue-slide vue-lazyload-img vue-lazyload-img - 移动优化的vue图片懒加载插件 https://github.com/JALBAA/vue-lazyload-img vue-drag-and-drop-list vue-drag-and-drop-list - 创建排序列表的Vue指令 https://github.com/Alex-fun/vue-drag-and-drop-list vue-progressive-image vue-progressive-image - Vue的渐进图像加载插件 https://github.com/MatteoGabriele/vue-progressive-image vuwe vuwe - 基于微信WeUI所开发的专用于Vue2的组件库 https://github.com/vuwe/vuwe vue-dropzone vue-dropzone - 用于文件上传的Vue组件 https://github.com/rowanwins/vue-dropzone vue-charts vue-charts - 轻松渲染一个图表 https://github.com/hchstera/vue-charts vue-swiper vue-swiper - 易于使用的滑块组件 https://github.com/weilao/vue-swiper vue-images vue-images - 显示一组图片的lightbox组件 https://github.com/littlewin-wang/vue-images vue-carousel-3d vue-carousel-3d - VueJS的3D轮播组件 https://github.com/Wlada/vue-carousel-3d vue-region-picker vue-region-picker - 选择中国的省份市和地区 https://github.com/QingWei-Li/vue-region-picker vue-typer vue-typer - 模拟用户输入选择和删除文本的Vue组件 https://github.com/cngu/vue-typer vue-impression vue-impression - 移动Vuejs2 UI元素 https://github.com/NewDadaFE/vue-impression vue-datatable vue-datatable - 使用Vuejs创建的DataTableView https://github.com/galenyuan/vue-datatable vue-instant vue-instant - 轻松创建自动提示的自定义搜索控件 https://github.com/santiblanko/vue-instant vue-dragging vue-dragging - 使元素可以拖拽 https://github.com/hilongjw/vue-dragging vue-slider-component vue-slider-component - 在vue1和vue2中使用滑块 https://github.com/NightCatSama/vue-slider-component vue2-loading-bar vue2-loading-bar - 最简单的仿Youtube加载条视图 https://github.com/BosNaufal/vue2-loading-bar vue-datepicker vue-datepicker - 漂亮的Vue日期选择器组件 https://github.com/weifeiyue/vue-datepicker vue-video vue-video - Vue.js的HTML5视频播放器 https://github.com/hilongjw/vue-video vue-toast-mobile vue-toast-mobile - VueJS的toast插件 https://github.com/ElemeFE/vue-toast-mobile vue-image-crop-upload vue-image-crop-upload - vue图片剪裁上传组件 https://github.com/dai-siki/vue-image-crop-upload vue-tooltip vue-tooltip - 带绑定信息提示的提示工具 https://github.com/Akryum/vue-tooltip vue-highcharts vue-highcharts - HighCharts组件 https://github.com/weizhenye/vue-highcharts vue-touch-ripple vue-touch-ripple - vuejs的触摸ripple组件 https://github.com/surmon-china/vue-touch-ripple coffeebreak coffeebreak - 实时编辑CSS组件工具 https://github.com/Kocisov/coffeebreak vue-datasource vue-datasource - 创建VueJS动态表格 https://github.com/coderdiaz/vue-datasource vue2-timepicker vue2-timepicker - 下拉时间选择器 https://github.com/phoenixwong/vue2-timepicker vue-date-picker vue-date-picker - VueJS日期选择器组件 https://github.com/Bubblings/vue-date-picker vue-scrollbar vue-scrollbar - 最简单的滚动区域组件 https://github.com/BosNaufal/vue-scrollbar vue-quill vue-quill - vue组件构建quill编辑器 https://github.com/CroudSupport/vue-quill vue-google-signin-button vue-google-signin-button - 导入谷歌登录按钮 https://github.com/phanan/vue-google-signin-button vue-svgicon vue-svgicon - 创建svg图标组件的工具 https://github.com/MMF-FE/vue-svgicon vue-float-label vue-float-label - VueJS浮动标签模式 https://github.com/bkzl/vue-float-label vue-baidu-map vue-baidu-map - 基于 Vue 2的百度地图组件库 https://github.com/Dafrok/vue-baidu-map vue-social-sharing vue-social-sharing - 社交分享组件 https://github.com/nicolasbeauvais/vue-social-sharing vue2-editor vue2-editor - HTML编辑器 https://github.com/davidroyer/vue2-editor vue-tagsinput vue-tagsinput - 基于VueJS的标签组件 https://github.com/Ginhing/vue-tagsinput vue-easy-slider vue-easy-slider - Vue 2.x的滑块组件 https://github.com/shhdgit/vue-easy-slider datepicker datepicker - 基于flatpickr的时间选择组件 https://github.com/vue-bulma/datepicker vue-chart vue-chart - 强大的高速的vue图表解析 https://github.com/miaolz123/vue-chart vue-music-master vue-music-master - vue手机端网页音乐播放器 https://github.com/yunyi1895/vue-music-master handsontable handsontable - 网页表格组件 https://github.com/vue-bulma/handsontable vue-simplemde vue-simplemde - VueJS的Markdown编辑器组件 https://github.com/F-loat/vue-simplemde vue-popup-mixin vue-popup-mixin - 用于管理弹出框的遮盖层 https://github.com/myronliu347/vue-popup-mixin cubeex cubeex - 包含一套完整的移动UI https://github.com/fangyongbao/cubeex vue-fullcalendar vue-fullcalendar - vue FullCalendar封装 https://github.com/CroudSupport/vue-fullcalendar vue-material-design vue-material-design - Vue MD风格组件 https://github.com/loujiayu/vue-material-design vue-morris vue-morris - Vuejs组件封装Morrisjs库 https://github.com/bbonnin/vue-morris we-vue we-vue - Vue2及weui1开发的组件 https://github.com/tianyong90/we-vue vue-image-clip vue-image-clip - 基于vue的图像剪辑组件 https://github.com/legeneek/vue-image-clip vue-bootstrap-table vue-bootstrap-table - 可排序可检索的表格 https://github.com/jbaysolutions/vue-bootstrap-table vue-radial-progress vue-radial-progress - Vue.js放射性进度条组件 https://github.com/wyzant-dev/vue-radial-progress vue-slick vue-slick - 实现流畅轮播框的vue组件 https://github.com/staskjs/vue-slick vue-pull-to-refresh vue-pull-to-refresh - Vue2的上拉下拉 https://github.com/bajian/vue-pull-to-refresh vue-form-2 vue-form-2 - 全面的HTML表单管理的解决方案 https://github.com/matfish2/vue-form-2 vue-side-nav vue-side-nav - 响应式的侧边导航 https://github.com/vue-comps/vue-side-nav mint-indicator mint-indicator - VueJS移动加载指示器插件 https://github.com/mint-ui/mint-indicator chartjs chartjs - Vue Bulma的chartjs组件 https://github.com/vue-bulma/chartjs vue-scroll vue-scroll - vue滚动 https://github.com/suguangwen/vue-scroll vue-ripple vue-ripple - 制作谷歌MD风格涟漪效果的Vue组件 https://github.com/BosNaufal/vue-ripple vue-touch-keyboard vue-touch-keyboard - VueJS虚拟键盘组件 https://github.com/icebob/vue-touch-keyboard vue-chartkick vue-chartkick - VueJS一行代码实现优美图表 https://github.com/ankane/vue-chartkick vue-ztree vue-ztree - 用 vue 写的树层级组件 https://github.com/lisiyizu/vue-ztree vue-m-carousel vue-m-carousel - vue 移动端轮播组件 https://github.com/shiye515/vue-m-carousel vue-datepicker-simple vue-datepicker-simple - 基于vue的日期选择器 https://github.com/dai-siki/vue-datepicker-simple vue-tabs vue-tabs - 多tab页轻型框架 https://github.com/alexqdjay/vue-tabs vue-verify-pop vue-verify-pop - 带气泡提示的vue校验插件 https://github.com/aweiu/vue-verify-pop vue-parallax vue-parallax - 整洁的视觉效果 https://github.com/vue-comps/vue-parallax vue-img-loader vue-img-loader - 图片加载UI组件 https://github.com/JackGit/vue-img-loader vue-typewriter vue-typewriter - vue组件类型 https://github.com/eduardostuart/vue-typewriter vue-smoothscroll vue-smoothscroll - smoothscroll的VueJS版本 https://github.com/Teddy-Zhu/vue-smoothscroll vue-city vue-city - 城市选择器 https://github.com/xinxingyu/vue-city vue-tree vue-tree - vue树视图组件 https://github.com/weibangtuo/vue-tree vue-ios-alertview vue-ios-alertview - iOS7+ 风格的alertview服务 https://github.com/Treri/vue-ios-alertview dd-vue-component dd-vue-component - 订单来了的公共组件库 https://github.com/ibufu/dd-vue-component paco-ui-vue paco-ui-vue - PACOUI的vue组件 https://github.com/yeseason/paco-ui-vue vue-cmap vue-cmap - Vue China map可视化组件 https://github.com/doodlewind/vue-cmap vue-button vue-button - Vue按钮组件 https://github.com/steven5538/vue-button vue.js vue.js - 流行的轻量高效的前端组件化方案 https://github.com/vuejs/vue vue-admin vue-admin - Vue管理面板框架 https://github.com/fundon/vue-admin electron-vue electron-vue - Electron及VueJS快速启动样板 https://github.com/SimulatedGREG/electron-vue vue-2.0-boilerplate vue-2.0-boilerplate - Vue2单页应用样板 https://github.com/petervmeijgaard/vue-2.0-boilerplate vue-spa-template vue-spa-template - 前后端分离后的单页应用开发 https://github.com/hanan198501/vue-spa-template Framework7-Vue Framework7-Vue - VueJS与Framework7结合 https://github.com/nolimits4web/Framework7-Vue vue-bulma vue-bulma - 轻量级高性能MVVM Admin UI框架 https://github.com/wangxg2016/vue-bulma vue-webgulp vue-webgulp - 仿VueJS Vue loader示例 https://github.com/rodzzlessa24/vue-webgulp vue-element-starter vue-element-starter - vue启动页 https://github.com/Metnew/vue-element-starter vuex vuex - 专为 Vue.js 应用程序开发的状态管理模式 https://github.com/vuejs/vuex vuelidate vuelidate - 简单轻量级的基于模块的Vue.js验证 https://github.com/monterail/vuelidate qingcheng qingcheng - qingcheng主题 https://github.com/zerqu/qingcheng vue-desktop vue-desktop - 创建管理面板网站的UI库 https://github.com/ElemeFE/vue-desktop vue-meta vue-meta - 管理app的meta信息 https://github.com/declandewet/vue-meta vue-axios vue-axios - 将axios整合到VueJS的封装 https://github.com/imcvampire/vue-axios vue-svg-icon vue-svg-icon - vue2的可变彩色svg图标方案 https://github.com/cenkai88/vue-svg-icon avoriaz avoriaz - VueJS测试实用工具库 https://github.com/eddyerburgh/avoriaz vue-framework7 vue-framework7 - 结合VueJS使用的Framework7组件 https://github.com/lmk123/vue-framework7 vue-bootstrap-modal vue-bootstrap-modal - vue的Bootstrap样式组件 https://github.com/Coffcer/vue-bootstrap-modal vuep vuep - 用实时编辑和预览来渲染Vue组件 https://github.com/QingWei-Li/vuep vue-online vue-online - reactive的在线和离线组件 https://github.com/Sopamo/vue-online vue-lazy-render vue-lazy-render - 用于Vue组件的延迟渲染 https://github.com/yeyuqiudeng/vue-lazy-render vue-password-strength-meter vue-password-strength-meter - 交互式密码强度计 https://github.com/apertureless/vue-password-strength-meter element-admin element-admin - 支持 vuecli 的 Element UI 的后台模板 https://github.com/lynzz/element-admin vue-electron vue-electron - 将选择的API封装到Vue对象中的插件 https://github.com/SimulatedGREG/vue-electron cleave cleave - 基于cleave.js的Cleave组件 https://github.com/vue-bulma/cleave vue-events vue-events - 简化事件的VueJS插件 https://github.com/cklmercer/vue-events vue-shortkey vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件 https://github.com/iFgR/vue-shortkey vue-cordova vue-cordova - Cordova的VueJS插件 https://github.com/kartsims/vue-cordova vue-router-transition vue-router-transition - 页面过渡插件 https://github.com/weinot/vue-router-transition vue-gesture vue-gesture - VueJS的手势事件插件 https://github.com/mlyknown/vue-gesture http-vue-loader http-vue-loader - 从html及js环境加载vue文件 https://github.com/FranckFreiburger/http-vue-loader vue-qart vue-qart - 用于qartjs的Vue2指令 https://github.com/superman66/vue-qart vuemit vuemit - 处理VueJS事件 https://github.com/gocanto/vuemit vue-websocket vue-websocket - VueJS的Websocket插件 https://github.com/icebob/vue-websocket vue-local-storage vue-local-storage - 具有类型支持的Vuejs本地储存插件 https://github.com/pinguinjkeke/vue-local-storage lazy-vue lazy-vue - 懒加载图片 https://github.com/gocanto/lazy-vue vue-bus vue-bus - VueJS的事件总线 https://github.com/yangmingshan/vue-bus vue-reactive-storage vue-reactive-storage - vue插件的Reactive层 https://github.com/ropbla9/vue-reactive-storage vue-notifications vue-notifications - 非阻塞通知库 https://github.com/se-panfilov/vue-notifications vue-lazy-component vue-lazy-component - 懒加载组件或者元素的Vue指令 https://github.com/Coffcer/vue-lazy-component v-media-query v-media-query - vue中添加用于配合媒体查询的方法 https://github.com/AStaroverov/v-media-query vue-observe-visibility vue-observe-visibility - 当元素在页面上可见或隐藏时检测 https://github.com/Akryum/vue-observe-visibility vue-ts-loader vue-ts-loader - 在Vue装载机检查脚本 https://github.com/HerringtonDarkholme/vue-ts-loader vue-pagination-2 vue-pagination-2 - 简单通用的分页组件 https://github.com/matfish2/vue-pagination-2 vuex-i18n vuex-i18n - 定位插件 https://github.com/dkfbasel/vuex-i18n Vue.resize Vue.resize - 检测HTML调整大小事件的vue指令 https://github.com/David-Desmaisons/Vue.resize vuex-shared-mutations vuex-shared-mutations - 分享某种Vuex mutations https://github.com/xanf/vuex-shared-mutations vue-file-base64 vue-file-base64 - 将文件转换为Base64的vue组件 https://github.com/BosNaufal/vue-file-base64 modal modal - Vue Bulma的modal组件 https://github.com/vue-bulma/modal Famous-Vue Famous-Vue - Famous库的vue组件 https://github.com/irwansyahwii/Famous-Vue leo-vue-validator leo-vue-validator - 异步的表单验证组件 https://github.com/LeoHuiyi/leo-vue-validator Vue-Easy-Validator Vue-Easy-Validator - 简单的表单验证 https://github.com/MetinSeylan/Vue-Easy-Validator vue-truncate-filter vue-truncate-filter - 截断字符串的VueJS过滤器 https://github.com/imcvampire/vue-truncate-filter vue-zoombox vue-zoombox - 一个高级zoombox https://github.com/vue-comps/vue-zoombox vue-input-autosize vue-input-autosize - 基于内容自动调整文本输入的大小 https://github.com/syropian/vue-input-autosize vue-lazyloadImg vue-lazyloadImg - 图片懒加载插件 https://github.com/yodfz/vue-lazyloadImg nuxt.js nuxt.js - 用于服务器渲染Vue app的最小化框架 https://github.com/nuxt/nuxt.js express-vue express-vue - 简单的使用服务器端渲染vue.js https://github.com/danmademe/express-vue vue-ssr vue-ssr - 非常简单的VueJS服务器端渲染模板 https://github.com/ccforward/vue-ssr vue-ssr vue-ssr - 结合Express使用Vue2服务端渲染 https://github.com/hilongjw/vue-ssr vue-easy-renderer vue-easy-renderer - Nodejs服务端渲染 https://github.com/leaves4j/vue-easy-renderer DejaVue DejaVue - Vuejs可视化及压力测试 https://github.com/MiCottOn/DejaVue vue-play vue-play - 展示Vue组件的最小化框架 https://github.com/vue-play/vue-play vscode-VueHelper vscode-VueHelper - 目前vscode最好的vue代码提示插件 https://github.com/OYsun/vscode-VueHelper vue-generate-component vue-generate-component - 轻松生成Vue js组件的CLI工具 https://github.com/NetanelBasal/vue-generate-component vue-multipage-cli vue-multipage-cli - 简单的多页CLI https://github.com/xwpongithub/vue-multipage-cli VuejsStarterKit VuejsStarterKit - vuejs starter套件 https://github.com/MetinSeylan/VuejsStarterKit koel koel - 基于网络的个人音频流媒体服务 https://github.com/phanan/koel pagekit pagekit - 轻量级的CMS建站系统 https://github.com/pagekit/pagekit vuedo vuedo - 博客平台 https://github.com/Vuedo/vuedo jackblog-vue jackblog-vue - 个人博客系统 https://github.com/jackhutu/jackblog-vue vue-cnode vue-cnode - 重写vue版cnode社区 https://github.com/lzxb/vue-cnode CMS-of-Blog CMS-of-Blog - 博客内容管理器 https://github.com/ycwalker/CMS-of-Blog rss-reader rss-reader - 简单的rss阅读器 https://github.com/mrgodhani/rss-reader vue-ghpages-blog vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客 https://github.com/viko16/vue-ghpages-blog swoole-vue-webim swoole-vue-webim - Web版的聊天应用 https://github.com/wh469012917/swoole-vue-webim vue-dashing-js vue-dashing-js - nuvo-dashing-js的fork https://github.com/thelinuxlich/vue-dashing-js fewords fewords - 功能极其简单的笔记本 https://github.com/sapjax/fewords vue-blog vue-blog - 使用Vue2.0 和Vuex的vue-blog https://github.com/surmon-china/vue-blog Vue-cnodejs Vue-cnodejs - 基于vue重写Cnodejs.org的webapp https://github.com/shinygang/Vue-cnodejs NeteaseCloudWebApp NeteaseCloudWebApp - 高仿网易云音乐的webapp https://github.com/javaSwing/NeteaseCloudWebApp vue-zhihu-daily vue-zhihu-daily - 知乎日报 with Vuejs https://github.com/hilongjw/vue-zhihu-daily vue-wechat vue-wechat - vue.js开发微信app界面 https://github.com/useryangtao/vue-wechat vue2-demo vue2-demo - 从零构建vue2 + vue-router + vuex 开发环境 https://github.com/lzxb/vue2-demo eleme eleme - 高仿饿了么app商家详情 https://github.com/liangxiaojuan/eleme vue-demo vue-demo - vue简易留言板 https://github.com/kenberkeley/vue-demo maizuo maizuo - vue/vuex/redux仿卖座网 https://github.com/zhengguorong/maizuo spa-starter-kit spa-starter-kit - 单页应用启动套件 https://github.com/codecasts/spa-starter-kit vue-music vue-music - Vue 音乐搜索播放 https://github.com/Sioxas/vue-music douban douban - 模仿豆瓣前端 https://github.com/jiakeqi/douban vue-Meizi vue-Meizi - vue最新实战项目 https://github.com/liangxiaojuan/vue-Meizi zhihudaily-vue zhihudaily-vue - 知乎日报web版 https://github.com/yatessss/zhihudaily-vue vue-demo-kugou vue-demo-kugou - vuejs仿写酷狗音乐webapp https://github.com/lavyun/vue-demo-kugou VueDemo_Sell_Eleme VueDemo_Sell_Eleme - Vue2高仿饿了么外卖平台 https://github.com/SimonZhangITer/VueDemo_Sell_Eleme vue2.0-taopiaopiao vue2.0-taopiaopiao - vue2.0与express构建淘票票页面 https://github.com/canfoo/vue2.0-taopiaopiao vue-leancloud-blog vue-leancloud-blog - 一个前后端完全分离的单页应用 https://github.com/jiangjiu/vue-leancloud-blog node-vue-server-webpack node-vue-server-webpack - Node.js+Vue.js+webpack快速开发框架 https://github.com/yjj5855/node-vue-server-webpack mi-by-vue mi-by-vue - VueJS仿小米官网 https://github.com/wendaosanshou/mi-by-vue vue-fis3 vue-fis3 - 流行开源工具集成demo https://github.com/okoala/vue-fis3 vue2.x-douban vue2.x-douban - Vue2实现简易豆瓣电影webApp https://github.com/superman66/vue2.x-douban vue-demo-maizuo vue-demo-maizuo - 使用Vue2全家桶仿制卖座电影 https://github.com/ChuckCZC/vue-demo-maizuo vue-zhihudaily vue-zhihudaily - 知乎日报 Web 版本 https://github.com/iHaPBoy/vue-zhihudaily vue-adminLte-vue-router vue-adminLte-vue-router - vue和adminLte整合应用 https://github.com/liujians/vue-adminLte-vue-router vue-axios-github vue-axios-github - 登录拦截登出功能 https://github.com/superman66/vue-axios-github Zhihu-Daily-Vue.js Zhihu-Daily-Vue.js - Vuejs单页网页应用 https://github.com/pomelo-chuan/Zhihu-Daily-Vue.js hello-vue-django hello-vue-django - 使用带有Django的vuejs的样板项目 https://github.com/rokups/hello-vue-django vue-cnode vue-cnode - vue单页应用demo https://github.com/wszgxa/vue-cnode x-blog x-blog - 开源的个人blog项目 https://github.com/CommanderXL/x-blog vue-express-mongodb vue-express-mongodb - 简单的前后端分离案例 https://github.com/xrr2016/vue-express-mongodb websocket_chat websocket_chat - 基于vue和websocket的多人在线聊天室 https://github.com/secreter/websocket_chat photoShare photoShare - 基于图片分享的社交平台 https://github.com/beidan/photoShare vue-zhihudaily-2.0 vue-zhihudaily-2.0 - 使用Vue2.0+vue-router+vuex创建的zhihudaily https://github.com/cs1707/vue-zhihudaily-2.0 notepad notepad - 本地存储的记事本 https://github.com/lin-xin/notepad vueBlog vueBlog - 前后端分离博客 https://github.com/elva2596/vueBlog vue-ruby-china vue-ruby-china - VueJS框架搭建的rubychina平台 https://github.com/hql123/vue-ruby-china Zhihu_Daily Zhihu_Daily - 基于Vue和Nodejs的Web单页应用 https://github.com/littlewin-wang/Zhihu_Daily vue-koa-demo vue-koa-demo - 使用Vue2和Koa1的全栈demo https://github.com/Molunerfinn/vue-koa-demo vue2.x-Cnode vue2.x-Cnode - 基于vue全家桶的Cnode社区 https://github.com/vincentSea/vue2.x-Cnode life-app-vue life-app-vue - 使用vue2完成多功能集合到小webapp https://github.com/shaqihe/life-app-vue github-explorer github-explorer - 寻找最有趣的GitHub库 https://github.com/SidKwok/github-explorer vue-trip vue-trip - vue2做的出行webapp https://github.com/wenye123/vue-trip vue-ssr-boilerplate vue-ssr-boilerplate - 精简版的ofvue-hackernews-2 https://github.com/albertchan/vue-ssr-boilerplate vue-bushishiren vue-bushishiren - 不是诗人应用 https://github.com/nswbmw/vue-bushishiren houtai houtai - 基于vue和Element的后台管理系统 https://github.com/peng1992/houtai ios7-vue ios7-vue - 使用vue2.0 vue-router vuex模拟ios7 https://github.com/QRL909109/ios7-vue Framework7-VueJS Framework7-VueJS - 使用移动框架的示例 https://github.com/tyllo/Framework7-VueJS cnode-vue cnode-vue - 基于vue和vue-router构建的cnodejs web网站SPA https://github.com/BubblyPoker/cnode-vue vue-cli-multipage-bootstrap vue-cli-multipage-bootstrap - 将vue官方在线示例整合到组件中 https://github.com/zhoou/vue-cli-multipage-bootstrap vue-cnode vue-cnode - 用 Vue 做的 CNode 官网 https://github.com/jiananle/vue-cnode HyaReader HyaReader - 移动友好的阅读器 https://github.com/GitaiQAQ/HyaReader zhihu-daily zhihu-daily - 轻松查看知乎日报内容 https://github.com/xrr2016/zhihu-daily seeMusic seeMusic - 跨平台云音乐播放器 https://github.com/Alex-xd/seeMusic vue-cnode vue-cnode - 使用cNode社区提供的接口 https://github.com/Damonlw/vue-cnode zhihu-daily-vue zhihu-daily-vue - 知乎日报 https://github.com/moonou/zhihu-daily-vue sls-vuex2-demo sls-vuex2-demo - vuex2商城购物车demo https://github.com/sailengsi/sls-vuex2-demo vue-dropload vue-dropload - 用以测试下拉加载与简单路由 https://github.com/ITCNZ/vue-dropload vue-cnode-mobile vue-cnode-mobile - 搭建cnode社区 https://github.com/soulcm/vue-cnode-mobile Vuejs-SalePlatform Vuejs-SalePlatform - vuejs搭建的售卖平台demo https://github.com/fishenal/Vuejs-SalePlatform v-notes v-notes - 简单美观的记事本 https://github.com/Halfeld/v-notes vue-starter vue-starter - VueJs项目的简单启动页 https://github.com/BosNaufal/vue-starter vue-memo vue-memo - 用 vue写的记事本应用 https://github.com/youknowznm/vue-memo","categories":[{"name":"前端","slug":"前端","permalink":"https://yangyfeng.github.io/blogpost/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yangyfeng.github.io/blogpost/tags/vue/"}]},{"title":"给文章加bgm","slug":"博客文档/给文章加bgm","date":"2018-12-29T16:00:00.000Z","updated":"2020-12-11T09:15:38.098Z","comments":true,"path":"/posts/3090f597.html","link":"","permalink":"https://yangyfeng.github.io/posts/3090f597.html","excerpt":"","text":"1234567---title: 给文章加bgmdate: 2018-12-30music: type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID---","categories":[{"name":"博客文档","slug":"博客文档","permalink":"https://yangyfeng.github.io/blogpost/categories/博客文档/"}],"tags":[]}]}