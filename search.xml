<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大数据可视化系统</title>
      <link href="//posts/5f998618.html"/>
      <url>//posts/5f998618.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年前端重修课</title>
      <link href="//posts/cf2c43d.html"/>
      <url>//posts/cf2c43d.html</url>
      
        <content type="html"><![CDATA[<h2 id="2021年前端重修课"><a href="#2021年前端重修课" class="headerlink" title="2021年前端重修课"></a>2021年前端重修课</h2><p><a href="https://imgchr.com/i/ymtXrR" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2021/02/02/ymtXrR.png" alt="ymtXrR.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Babel转码器</title>
      <link href="//posts/390a51fc.html"/>
      <url>//posts/390a51fc.html</url>
      
        <content type="html"><![CDATA[<p> <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 是一个广泛使用的 ES6 转码器(下一代的JavaScript编译器)，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p><p>下面的命令在项目目录中，安装 Babel。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure><h2 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h2><p>Babel 的配置文件是<code>.babelrc</code>，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p><p>该文件用来设置转码规则和插件，基本格式如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [],</span><br><span class="line">  <span class="string">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新转码规则</span></span><br><span class="line">$ npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line"><span class="comment"># react 转码规则</span></span><br><span class="line">$ npm install --save-dev @babel/preset-react</span><br></pre></td></tr></table></figure><p> 然后，将这些规则加入<code>.babelrc</code>。 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"presets"</span>: [</span><br><span class="line">     <span class="string">"@babel/env"</span>,</span><br><span class="line">     <span class="string">"@babel/preset-react"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"plugins"</span>: []</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意，以下所有 Babel 工具和模块的使用，都必须先写好<code>.babelrc</code>。</p><h2 id="命令行转码"><a href="#命令行转码" class="headerlink" title="命令行转码"></a>命令行转码</h2><p> Babel 提供命令行工具<code>@babel/cli</code>，用于命令行转码。 </p><p> 它的安装命令如下。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev @babel/cli</span><br></pre></td></tr></table></figure><p> 基本用法如下。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ npx babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码结果写入一个文件</span></span><br><span class="line"><span class="comment"># --out-file 或 -o 参数指定输出文件</span></span><br><span class="line">$ npx babel example.js --out-file compiled.js</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ npx babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个目录转码</span></span><br><span class="line"><span class="comment"># --out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">$ npx babel src --out-dir lib</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ npx babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 参数生成source map文件</span></span><br><span class="line">$ npx babel src -d lib -s</span><br></pre></td></tr></table></figure><h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如<code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Map</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code>等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p><p>举例来说，ES6 在<code>Array</code>对象上新增了<code>Array.from</code>方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用<code>core-js</code>和<code>regenerator-runtime</code>(后者提供generator函数的转码)，为当前环境提供一个垫片。</p><p> 安装命令如下。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev core-js regenerator-runtime</span><br></pre></td></tr></table></figure><p> 然后，在脚本头部，加入如下两行代码。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'regenerator-runtime/runtime'</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'regenerator-runtime/runtime);</span></span><br></pre></td></tr></table></figure><p> Babel 默认不转码的 API 非常多，详细清单可以查看<code>babel-plugin-transform-runtime</code>模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/runtime-corejs3-definitions.js" target="_blank" rel="noopener">definitions.js</a>文件。 </p>]]></content>
      
      
      <categories>
          
          <category> Es6 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>globalThis对象</title>
      <link href="//posts/180dd8a3.html"/>
      <url>//posts/180dd8a3.html</url>
      
        <content type="html"><![CDATA[<p> JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 </p><ul><li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li><li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li><li><p>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</p><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。 </p></li><li><p>全局环境中，<code>this</code>会返回顶层对象。但是，Node.js 模块中<code>this</code>返回的是当前模块，ES6 模块中<code>this</code>返回的是<code>undefined</code>。</p></li><li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li><li><p>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</p><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-global" target="_blank" rel="noopener">ES2020</a> 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p><p>垫片库<a href="https://github.com/ungap/global-this" target="_blank" rel="noopener"><code>global-this</code></a>模拟了这个提案，可以在所有环境拿到<code>globalThis</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Es6 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js 优化for循环-Duff装置</title>
      <link href="//posts/ef7302f6.html"/>
      <url>//posts/ef7302f6.html</url>
      
        <content type="html"><![CDATA[<p>循环是编程中常见的结构，在javaScript程序中同样随处可见。当我们要处理的数据集很大时，for循环的优化就显得格外重要了。 </p><p> 如下是一个常见的for循环： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(values[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这段代码中每循环一次都要计算一次values的长度，所以我们可以将循环由i递增改为i递减，在这个过程中，将终止条件values.l ength的O(n)调用简化成了O(1)调用，初次优化的代码如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = values.length <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们还可以将循环改为后测试循环，如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = values.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values[i]);</span><br><span class="line">  &#125;<span class="keyword">while</span>(--i &gt;= <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上的代码主要是将终止条件和自减操作符组合成了单个语句，不过使用后测试循环必须要保证要处理的值必须有一个。空数组会导致多余的一次循环。 </p><p> 以上的优化都是基于终止条件和自减操作，循环的次数依然没有变化，如果我们能减少循环的次数，代码运行速度是不是会更快呢。接下来我们介绍下一种叫Duff装置的技术。Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句。请看以下代码： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterations = <span class="built_in">Math</span>.ceil(values.length / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> startAt = values.length % <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(startAt)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  &#125;</span><br><span class="line">  startAt = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(--iterations &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> 我们假设循环次数是10次，在普通的for循环中，会进入循环体10次，每一次打印对应的值。而在以上的代码中，我们计算出iterations是2，startAt是2，第一次进入switch语句的时候，会执行两次console语句，startAt重置为0，iterations自减为1，第二次进入switch语句时，就,会执行8次console语句， 然后退出循环。以上只执行了两次循环，打印的次数依然是10次，我们减少了循环的次数和处理终止条件的额外开销，在数据量很大的时候，可以使代码运行的更快。<br>基于以上代码，Andrew B.King提出了一个更快的Duff装置技术，将do-while循环分成两个单独的循环。代码如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterations = <span class="built_in">Math</span>.floor(values.length / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> leftover = values.length % <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(leftover &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  &#125;<span class="keyword">while</span>(--leftover &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">  <span class="built_in">console</span>.log(values[i++]);</span><br><span class="line">&#125;<span class="keyword">while</span>(--iterations &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> 以上的代码没有switch语句，每次进入第二个do-while循环时，执行8次console即可，这个方法比几乎比原始的Duff装置实现快上40%。针对大数据集使用Duff装置技术可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。<br>我们可以将duff装置技术封装成一个类似于forEach的方法，代码如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.duffForEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(len / <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">var</span> leftover = len % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--leftover &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.length &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">    fn(<span class="keyword">this</span>[i], i++);</span><br><span class="line">  &#125; <span class="keyword">while</span> (--num &gt; <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 我们可以测试一下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.duffForEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 可以看到，结果不出意料是正常的 </p><p><strong><a href="https://segmentfault.com/a/1190000023524594" target="_blank" rel="noopener">原文地址</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> for循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V8引擎是如何运行JS</title>
      <link href="//posts/cf2c43d.html"/>
      <url>//posts/cf2c43d.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是V8引擎"><a href="#什么是V8引擎" class="headerlink" title="什么是V8引擎"></a>什么是V8引擎</h2><p>一个接受JavaScript代码，编译代码然后执行的C++ 程序，编译后的代码可以在多种操作系统多种处理器上运行。</p><p><strong>介绍</strong></p><p>哪些程序用到V8</p><ul><li>Chrome浏览器的JS引擎是V8</li><li>Nodejs的运行时环境是V8</li><li>electron的底层引擎是V8 跨平台桌面应用开发工具</li></ul><p>blink是渲染引擎，V8是JS引擎</p><p>访问Dom的接口是由Blink提供的</p><p><strong>功能</strong></p><p>接收JavaScript代码，编译代码后执行C++程序，编译后的代码可以在多种操作系统多种处理器上运行。编译和执行JS代码、处理调用栈、内存分配、垃圾回收。</p><ol><li>编译和执行JS代码</li><li>处理调用栈</li><li>内存分配</li><li>垃圾回收</li></ol><p><strong>V8的js编译和执行</strong></p><ul><li>解析器  parser  js –&gt; 解析成功抽象语法树AST</li><li>解释器  interpreter   AST –&gt; 字节码bytecode，也有直接执行字节码的能力</li><li>编译器  compiler  bytecode –&gt; 更高效的机器码</li></ul><p>V8版本5.9之前没有解释器，但是有两个编译器</p><p><strong>5.9版本的V8</strong></p><ol><li>parser  解释器生成抽象语法树AST</li><li>compiler  编译器Full-codegen  基准编译器  直接生成机器码</li><li>运行一段时间后，由分析器线程优化js代码</li><li>compiler  编译器CrankShaft   优化编译器   重新生成AST提升运行效率</li></ol><p>这样设计的缺点</p><ol><li>机器码会占用大量的内存</li><li>缺少中间层机器码，无法实现一些优化策略</li><li>无法很好的支持和优化JS的新语特性，无法拥抱未来</li></ol><h2 id="新版本的V8"><a href="#新版本的V8" class="headerlink" title="新版本的V8"></a>新版本的V8</h2><p><a href="https://imgchr.com/i/rrlwNT" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rrlwNT.md.png" alt="rrlwNT.md.png"></a></p><ol><li>parser  解析器  生成AST抽象语法树</li><li>interpreter   解释器   Ignition   生成byteCode字节码  并直接执行</li><li>清除AST 释放内存空间</li><li>得到25% - 50%的等效机器代码大小</li><li>compiler  运行过程中，解释器收集优化信息发送给编译器TurboFan</li><li>重新生成机器码</li><li>有些热点函数变更会由优化后的机器码还原成字节码 也就是deoptimization  回退字节码操作执行</li></ol><p>优化点：</p><ol><li>值声明未调用，不会被解析生成AST</li><li>函数只被调用一次，bytcode直接被解释执行，不会进入到编译优化阶段</li><li>函数被调用多次，Igniton会收集函数类型信息，可能会被标记为热点函数，可能被编译成优化后的机器代码</li></ol><p>好处：</p><ol><li>由于一开始不需要直接编译成机器码，生成了中间层的字节码，从而节约了时间</li><li>优化编译阶段，不需要从源码重新解析,直接通过字节码进行优化，也可以deoptimization回退操作</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x + y&#125;;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">sum(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">sum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">sum(<span class="string">"7"</span>,<span class="string">"8"</span>);<span class="comment">//会回退字节码操作执行</span></span><br></pre></td></tr></table></figure><p><strong><a href="https://www.bilibili.com/video/BV1zV411z7RX" target="_blank" rel="noopener">原文地址</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> JS运行原理 </tag>
            
            <tag> V8引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的事件循环是什么</title>
      <link href="//posts/62b88241.html"/>
      <url>//posts/62b88241.html</url>
      
        <content type="html"><![CDATA[<h2 id="事件循环的机制"><a href="#事件循环的机制" class="headerlink" title="事件循环的机制"></a>事件循环的机制</h2><p><strong>概念</strong></p><p>宏任务：script(整个代码)、setTimeout、setInterval、setImmediate、I/O、UI rendering</p><p>微任务：promise、Object.observe、MutationObserve</p><p>任务的优先级：process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate</p><p><a href="https://mp.weixin.qq.com/s/7k4skVdCIhTsTdEFmXyYLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7k4skVdCIhTsTdEFmXyYLg</a></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> event loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网是如何运作的</title>
      <link href="//posts/c35109d5.html"/>
      <url>//posts/c35109d5.html</url>
      
        <content type="html"><![CDATA[<p>互联网所有的传输都通过RCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p><h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>协议是一组<strong>规则</strong>，用于指定计算机应该如何通过网络来交互通信</p><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p><strong>有四层</strong></p><ul><li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li><li>网络控制层： 发送数据包到计算机上使用特定的端口号的应用程序</li><li>网络层： 使用IP地址将数据包发送到特定的计算</li><li>链路层：  将二进制数据包与网络信号相互之间转换</li></ul><p><strong>TCP的可靠</strong></p><p>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p><p><strong>IP的传输</strong></p><p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p><p><a href="https://imgchr.com/i/rDwiod" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rDwiod.png" alt="rDwiod.png"></a></p><p><strong>TCP传输的质量和顺序</strong></p><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p><p><strong>IP和IP地址的区别</strong></p><p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p><p>IP地址是一串数字192.0.0.1</p><p><a href="https://imgchr.com/i/rDaLgf" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rDaLgf.png" alt="rDaLgf.png"></a></p><p><a href="https://imgchr.com/i/rDajKS" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rDajKS.png" alt="rDajKS.png"></a></p><a id="more"></a><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><ol><li>个人电脑</li><li>猫</li><li>local ISP   互联网服务提供商</li><li>regional ISP   经过多个主干网络</li><li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li><li>NAP   每个NSP连接到至少三个网络访问点</li><li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li></ol><p><strong>个人客户端访问哔哩哔哩服务器的过程</strong></p><p><a href="https://imgchr.com/i/rDwRmD" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rDwRmD.png" alt="rDwRmD.png"></a></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器服务检查路由表上是否有目的地的IP地址，</p><p>如果有直接发送到对应的网络，否则向上发送数据，在更高的层级寻找对一个拥有该IP的路由器</p><p>直到找到对应的网络的IP地址</p><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p><p><strong><a href="https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.0" target="_blank" rel="noopener">原文地址</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是JS调用栈</title>
      <link href="//posts/9926a09c.html"/>
      <url>//posts/9926a09c.html</url>
      
        <content type="html"><![CDATA[<p><strong>概念</strong></p><p>栈：先进后出，进栈，出栈，与堆栈不同</p><p>队列：先进先出</p><p>调用栈是JS引擎追踪函数执行流程的一种机制，当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体又调用了哪个函数</p><p><strong>例子</strong></p><p>调用栈，调用函数执行才回入栈</p><ol><li><p>push  average()</p></li><li><p>push  sum()</p></li><li><p>shift  sum()</p></li><li><p>shift  average()</p></li><li><p>push  console.log()</p></li><li><p>shift  console.log()</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> aver = sum(a, b) / <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> aver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> num = average(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><p>用栈持持续被调用，会导致内存溢出</p><p>原因是因为，JS主线程被占用会造成堵塞：事件循环，异步回调(宏任务，微任务，面试必问哦)</p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS运行原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript是如何被运行的</title>
      <link href="//posts/81adf3b6.html"/>
      <url>//posts/81adf3b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS的语言组成"><a href="#JS的语言组成" class="headerlink" title="JS的语言组成"></a>JS的语言组成</h2><ul><li>基本语法：C</li><li>数据类型 内存管理：Java</li><li>函数式编程：Scheme  函数是第一等公民</li><li>原型继承：Self   基于原型prototype的继承机制</li></ul><h2 id="奇葩的JS"><a href="#奇葩的JS" class="headerlink" title="奇葩的JS"></a>奇葩的JS</h2><p>对于熟悉javascript语言的前端开发小伙伴，直接上来两张图</p><p><a href="https://imgchr.com/i/rrE9Gq" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rrE9Gq.md.png" alt="rrE9Gq.md.png"></a></p><p><a href="https://imgchr.com/i/rrEALF" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rrEALF.md.png" alt="rrEALF.md.png"></a></p><p>是不是瞬间感觉头脑发热呢。</p><p>之所以会出现这些诡异的问题，是因为javascript是在设计之初并没有考虑的完善，是借鉴了多种语言的模式，基本是融合了面向过程和面向对象的。</p><a id="more"></a><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>动态类型语言 JS   编译环境JIT Just In Time Compilation </p><p>静态类型语言 C++  编译环境 AOT  Ahead Of Time</p><p><strong>JIT</strong></p><p>js引擎运用了一项技术叫运行时编译  JIT<br>javascript是动态类型语言，在编译是使用的是JIT(just in time compilation) 运行时编译技术<br>白话就是：在运行时编译成机器代码</p><p><strong>AOT</strong></p><p>在运行前提前生成好机器代码</p><p><strong>javascript引擎</strong></p><p>将javascript代码高级语言转化为低级语言（机器语言）来执行</p><p><strong>常用的执行javascript引擎</strong></p><p>谷歌的v8引擎，javascriptcore，spidermonkey，quickjs，hermess(react nactive)</p><ol><li>谷歌V8</li><li>苹果 - javaScriptCore</li><li>火狐 - SpideMonkey</li><li>QuickJs</li><li>FaceBook - Hermes</li></ol><h2 id="javascript引擎的编译流程"><a href="#javascript引擎的编译流程" class="headerlink" title="javascript引擎的编译流程"></a>javascript引擎的编译流程</h2><p><a href="https://imgchr.com/i/rrVTjf" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rrVTjf.md.png" alt="rrVTjf.md.png"></a></p><p>说明：</p><p>javascript代码解析器（parser）解析成抽象语法树AST，通过解释器（interpreter）将AST编译为字节码bytecode(跨平台的一种中间表示，可以在不同的操作平台运行),字节码最后通过编译器，生成机器代码。<strong>V8在5.9之前 是没有字节码的环节</strong>。</p><ol><li>parser - 将js源码通过parser解析器生成AST  抽象语法树</li><li>interpreter - 通过解释器将AST编程成功字节码bytecode (字节码与平台无关，是中间层，可以在各个平台上运行)</li><li>compiler - 根据当前平台编译出相应的机器代码也就是汇编代码  常见的操作系统平台有：IA32 X64 ARM MIPS </li></ol><p><strong><a href="https://www.bilibili.com/video/BV1vh411Z7QG" target="_blank" rel="noopener">原文地址</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> JS运行原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是如何运作的</title>
      <link href="//posts/41e3ecae.html"/>
      <url>//posts/41e3ecae.html</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器是多进程结构的"><a href="#浏览器是多进程结构的" class="headerlink" title="浏览器是多进程结构的"></a>浏览器是多进程结构的</h2><p><strong>进程</strong></p><p>操作系统进行资源分配和调度的基本单元。可以申请和拥有计算机资源，进程是程序的基本执行实体。两个进程分配的资源和内存是独立，如果需要通信就要使用进程通信管道IPC来传递信息。</p><p><strong>线程</strong></p><p>操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p><strong>浏览器功能进程拆解</strong></p><p><a href="https://imgchr.com/i/rDbTde" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rDbTde.png" alt="rDbTde.png"></a></p><ol><li><p>浏览器进程</p><p>控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作</p></li><li><p>缓存进程</p><p>负责控制浏览器的存储数据的缓存和读取</p></li><li><p>网络进程 </p><p>发起和接受网络请求</p></li><li><p>渲染器进程 </p><p>渲染Tab  有可能会为每个标签页是一个渲染进程</p></li><li><p>GPU进程</p><p>整个浏览器界面的渲染</p></li><li><p>插件进程</p><p>控制网站使用的所有内置插件，例如：flash</p></li></ol><p><strong>浏览器结构图</strong></p><p><a href="https://imgchr.com/i/rDoRuF" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rDoRuF.png" alt="rDoRuF.png"></a></p><p>说明：</p><p>用户界面：展示除了标签页窗口之外的其他用户用户界面内容</p><p>渲染引擎：渲染用户获取数据的渲染内容。一下还有很多小的功能模块，如负责网络请求的网络模块，用于解析和执行js的js解释器</p><p>浏览器引擎：用户界面和渲染引擎之间传递数据</p><p>数据持久层：帮助浏览器存储持久数据，如cokies和storage。</p><p><strong>我们称呼的内核就是指的渲染引擎，是整个浏览器的核心和灵魂</strong></p><p>Chromium会给用户创建的每一个访问实例分配一个进程，确保每一个页面是独立呈现的，并且对每个网站的独立访问也是彼此隔离的。访问不同站点和同一站点的不同页面都会创建新的进程。一个标签就是一个新的渲染器进程。</p><a id="more"></a><h2 id="渲染进程的过程"><a href="#渲染进程的过程" class="headerlink" title="渲染进程的过程"></a>渲染进程的过程</h2><ol start="0"><li>网络进程获取数据后通过SafeBrowsing来检查是不是恶意站点，如果是则会展示一个警告页面并提示，浏览器会阻止你的访问。SafeBrowsing：谷歌内部的站点安全检测系统获取数据后网络线程通知UI线程，然后UI线程创建一个渲染器进程（renderer thread）来渲染页面。</li><li>浏览器通过网络请求后获取html数据，通过tcp传给渲染器进程，正式进入渲染流程。</li><li>DOM - 通过tokeniser进行词法分析器生成标记，根据识别后的标记进行dom tree构造，创建DOM对象。主线程将html解析构造DOM树</li><li>style - 样式计算，生成css tree</li><li>layoutTree - dom+style 根据dom树和样式生成layoutTree</li><li>paint -绘制  通过遍历 Layout Tree生成绘制顺序表。将图形块转化为像素点绘制在屏幕上，这个过程叫做<strong>栅格化</strong>（rastering）。</li><li>laryer - 布局  然后根据主进程将layoutTree 和绘制信息表传给合成器线程</li><li>合成器线程  - 将得到的信息分图层分成更小的图块</li><li>栅格线程    -    将更小的图块进行栅格化raster，返还给合成器线程draw quads图块信息  存储在GPU中</li><li>frame 合成器帧通过IPC将栅格线程返回的图块合成帧交给浏览器进程</li><li>浏览器进程  收到一帧的图像后传给GPU进行渲染</li></ol><p><a href="https://imgchr.com/i/rrSaRg" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/22/rrSaRg.png" alt="rrSaRg.png"></a></p><p><strong>重排</strong><br>当改变dom的属性时，会重新进行样式计算，会重新布局和绘制<br><strong>重绘</strong><br>当改变颜色时，只会发生样式计算和绘制(layer)<br><strong>requestAnimationFrame()</strong><br>会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程<br><strong>Fiber</strong><br>react最新的渲染引擎利用浏览器的空闲时间做优化。 <code>requestIdlCallback</code>，这个会在每一帧最后的空余时间判断是否运行，react  fiber在每一个单元任务执行前判断空余时间以及设定的最大timeout值来决定是否执行。<br><strong>Transform</strong><br>会直接运行合成器线程，所以不会感染主线程的渲染<br>在移动端使用3d转换可以优化性能（如果设备有3d加速引擎 GPU 可以提高性能 , 2d转换是无法调用GPU，2G是靠的CPU）</p><p><strong><a href="https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.0" target="_blank" rel="noopener">原文地址</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 深入前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器运行原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题（2）</title>
      <link href="//posts/e210f74f.html"/>
      <url>//posts/e210f74f.html</url>
      
        <content type="html"><![CDATA[<h2 id="v-if和v-for哪个优先级更高？"><a href="#v-if和v-for哪个优先级更高？" class="headerlink" title="v-if和v-for哪个优先级更高？"></a>v-if和v-for哪个优先级更高？</h2><p> 分析：此题考查常识，文档中曾有<a href="https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起必要" target="_blank" rel="noopener">详细说明</a>；也是一个很好的实践题目，项目中经常会遇到，能够看出面试者应用能力。 </p><p>思路分析：总分总模式</p><ol><li>先给出结论</li><li>为什么是这样的</li><li>它们能放一起吗</li><li>如果不能，那应该怎样</li><li>总结</li></ol><p>回答范例：</p><ol><li>v-for优先于v-if被解析</li><li>我曾经做过实验，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件</li><li>实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。</li><li>通常有两种情况下导致我们这样做：<ul><li>为了过滤列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。此时定义一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表即可。</li><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。此时把 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)即可。</li></ul></li><li>文档中明确指出<strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上</strong>，显然这是一个重要的注意事项。</li><li><p>看过源码里面关于代码生成的部分</p><p>知其所以然： </p><p>做个测试</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="string">"app"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, _l((items), <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (item.isActive) ? _c(<span class="string">'div'</span>, &#123;</span><br><span class="line">        key: item.id</span><br><span class="line">      &#125;, [_v(<span class="string">"\n      "</span> + _s(item.name) + <span class="string">"\n    "</span>)]) : _e()</span><br><span class="line">    &#125;), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 源码中找答案</p><blockquote><p>compiler/codegen/index.js </p></blockquote><a id="more"></a><h2 id="你知道key的作用吗？"><a href="#你知道key的作用吗？" class="headerlink" title="你知道key的作用吗？"></a>你知道key的作用吗？</h2><p>分析：这是一道特别常见的问题，主要考查大家对虚拟DOM和patch细节的掌握程度，能够反映面试者理解层次。</p><p>思路分析：总分总模式</p><ol><li>给出结论，key的作用是用于优化patch性能</li><li>key的必要性</li><li>实际使用方式</li><li>总结：可从源码层面描述一下vue如何判断两个节点是否相同</li></ol><p>回答范例：</p><ol><li>key的作用主要是为了更高效的更新虚拟DOM。</li><li>vue在patch过程中<strong>判断两个节点是否是相同节点是key是一个必要条件</strong>，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，vue只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个patch过程比较低效，影响性能。</li><li>实际使用中在渲染一组列表时key必须设置，而且必须是唯一标识，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。</li><li><p>从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。</p><p>测试代码 </p></li></ol><p>使用key:</p><p><a href="https://imgchr.com/i/r0ML9A" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/21/r0ML9A.png" alt="r0ML9A.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次循环patch A</span></span><br><span class="line">A B C D E</span><br><span class="line">A B F C D E</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2次循环patch B</span></span><br><span class="line">B C D E</span><br><span class="line">B F C D E</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3次循环patch E</span></span><br><span class="line">C D E</span><br><span class="line">F C D E</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第4次循环patch D</span></span><br><span class="line">C D</span><br><span class="line">F C D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第5次循环patch C</span></span><br><span class="line">C </span><br><span class="line">F C</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldCh全部处理结束，newCh中剩下的F，创建F并插入到C前面</span></span><br></pre></td></tr></table></figure><p> 不使用key </p><p><a href="https://imgchr.com/i/r0QeBT" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/21/r0QeBT.png" alt="r0QeBT.png"></a></p><p> 源码中找答案 </p><blockquote><p> src\core\vdom\patch.js - sameVnode() </p></blockquote><h2 id="你了解vue中的diff算法吗？"><a href="#你了解vue中的diff算法吗？" class="headerlink" title="你了解vue中的diff算法吗？"></a>你了解vue中的diff算法吗？</h2><p>题目分析：vue基于虚拟DOM做更新，diff又是其核心部分，因此常被问道，此题考查面试者深度。</p><p>答题思路：3w1h</p><ol><li>定义diff</li><li>它的必要性</li><li>它在哪里被使用</li><li>它如何运作</li><li>提升：说一些细节</li></ol><p>回答范例：</p><ol><li>diff算法是虚拟DOM技术的产物，vue里面实际叫做patch，它的核心实现来自于snabbdom；通过新旧虚拟DOM作对比（即patch），将变化的地方转换为DOM操作</li><li>在vue 1中是没有patch的，因为界面中每个依赖都有专门的watcher负责更新，这样项目规模变大就会成为性能瓶颈，vue 2中为了降低watcher粒度，每个组件只有一个watcher，但是当需要更新的时候，怎样才能精确找到发生变化的地方？这就需要引入patch才行。</li><li>组件中数据发生变化时，对应的watcher会通知更新并执行其更新函数，它会执行渲染函数获取全新虚拟dom：newVnode，此时就会执行patch比对上次渲染结果oldVnode和新的渲染结果newVnode。</li><li>patch过程遵循深度优先、同层比较的策略；两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。</li></ol><h2 id="vue中组件之间的通信方式？"><a href="#vue中组件之间的通信方式？" class="headerlink" title="vue中组件之间的通信方式？"></a>vue中组件之间的通信方式？</h2><p> 题目分析：</p><p>vue是组件化开发框架，所以对于vue应用来说组件间的数据通信非常重要。此题主要考查大家vue基本功，对于vue基础api运用熟练度。另外一些边界知识如provide/inject/$attrs/$listeners则体现了面试者的知识面。 </p><p>思路分析：总分</p><ol><li>总述知道的所有方式</li><li><p>按组件关系阐述使用场景</p><p>回答范例： </p></li><li><p>组件通信方式大体有以下8种：</p></li></ol><ul><li>props</li><li>$emit/$on</li><li>$children/$parent</li><li>$attrs/$listeners</li><li>ref</li><li>$root</li><li>eventbus</li><li>vuex</li></ul><ol><li>根据组件之间关系讨论组件通信最为清晰有效</li></ol><ul><li>父子组件<ul><li><code>props</code></li><li><code>$emit</code>/<code>$on</code></li><li><code>$parent</code> / <code>$children</code></li><li><code>ref</code></li><li><code>$attrs</code> / <code>$listeners</code></li></ul></li><li>兄弟组件<ul><li><code>$parent</code></li><li><code>eventbus</code></li><li><code>vuex</code></li></ul></li><li>跨层级关系<ul><li><code>provide</code>/<code>inject</code></li><li><code>$root</code></li><li><code>eventbus</code></li><li><code>vuex</code></li></ul></li></ul><h2 id="简单说一说你对vuex理解？"><a href="#简单说一说你对vuex理解？" class="headerlink" title="简单说一说你对vuex理解？"></a>简单说一说你对vuex理解？</h2><p> 分析：此题考查实践能力，能说出用法只能60分。更重要的是对vuex设计理念和实现原理的解读。 </p><p>回答策略：3w1h</p><ol><li>首先给vuex下一个定义</li><li>vuex解决了哪些问题，解读理念</li><li>什么时候我们需要vuex</li><li>你的具体用法</li><li><p>简述原理，提升层级</p><p>首先是官网定义： </p></li></ol><blockquote><p> Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式</strong>存储管理应用的所有组件的状态，并以相应的规则保证状态以一种<strong>可预测</strong>的方式发生变化。 </p></blockquote><p>回答范例：</p><ol><li>vuex是vue专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。</li><li>vuex主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。vuex通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。</li><li>vuex并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用vuex的必要。一个简单的<a href="https://cn.vuejs.org/v2/guide/state-management.html#简单状态管理起步使用" target="_blank" rel="noopener">store 模式</a>就足够了。反之，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。</li><li>我在使用vuex过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入state对象中，它本身一棵状态树，组件中使用store实例的state访问这些状态；然后有配套的mutation方法修改这些状态，并且只能用mutation修改状态，在组件中调用commit方法提交mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写action，执行结束如果有状态修改仍然需要提交mutation，组件中调用这些action使用dispatch方法派发。最后是模块化，通过modules选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置namespace，那么在提交mutation和派发action时还需要额外的命名空间前缀。</li><li>vuex在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了vue的数据响应化特性实现的，它会利用Vue将state作为data对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。</li></ol><h2 id="vue-router中如何保护路由？"><a href="#vue-router中如何保护路由？" class="headerlink" title="vue-router中如何保护路由？"></a>vue-router中如何保护路由？</h2><p> 此题是考查项目实践能力，项目中基本都有路由守卫的需求，保护指定路由考查的就是这个知识点。 </p><p>答题整体思路：</p><ol><li>阐述vue-router中路由保护策略</li><li>描述具体实现方式</li><li>简单说一下它们是怎么生效的</li></ol><p>回答范例：</p><ol><li>vue-router中保护路由安全通常使用导航守卫来做，通过设置路由导航钩子函数的方式添加守卫函数，在里面判断用户的登录状态和权限，从而达到保护指定路由的目的。</li><li>具体实现有几个层级：全局前置守卫beforeEach、路由独享守卫beforeEnter或组件内守卫beforeRouteEnter。以全局守卫为例来说，可以使用<code>router.beforeEach((to,from,next)=&gt;{})</code>方式设置守卫，每次路由导航时，都会执行该守卫，从而检查当前用户是否可以继续导航，通过给next函数传递多种参数达到不同的目的，比如如果禁止用户继续导航可以传递next(false)，正常放行可以不传递参数，传递path字符串可以重定向到一个新的地址等等。</li><li>这些钩子函数之所以能够生效，也和vue-router工作方式有关，像beforeEach只是注册一个hook，当路由发生变化，router准备导航之前会批量执行这些hooks，并且把目标路由to，当前路由from，以及后续处理函数next传递给我们设置的hook。</li></ol><p>可能的追问：</p><p>1、能不能说说全局守卫、路由独享守卫和组件内守卫区别？</p><ul><li><p>作用范围</p></li><li><p>组件实例的获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to,<span class="keyword">from</span>,next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>名称/数量/顺序 </p><blockquote><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol></blockquote></li></ul><p>2、你项目中的路由守卫是怎么做的？</p><p>3、前后端路由一样吗？</p><p>4、前端路由是用什么方式实现的？</p><p>5、你前面提到的next方法是怎么实现的？</p><h2 id="你了解哪些Vue性能优化方法？"><a href="#你了解哪些Vue性能优化方法？" class="headerlink" title="你了解哪些Vue性能优化方法？"></a>你了解哪些Vue性能优化方法？</h2><p> 答题思路：根据题目描述，这里主要探讨Vue代码层面的优化 </p><p> <strong>路由懒加载</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>keep-alive缓存页面</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><strong>使用v-show复用DOM</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">    &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt;</span><br><span class="line">    &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt;</span><br><span class="line">      &lt;Heavy :n=&quot;10000&quot;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt;</span><br><span class="line">      &lt;Heavy :n=&quot;10000&quot;/&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p> <strong>v-for 遍历避免同时使用 v-if</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li</span><br><span class="line">        v-for=&quot;user in activeUsers&quot;</span><br><span class="line">        :key=&quot;user.id&quot;&gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">        computed: &#123;</span><br><span class="line">          activeUsers: function () &#123;</span><br><span class="line">            return this.users.filter(function (user) &#123;</span><br><span class="line">             return user.isActive</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> <strong>长列表性能优化</strong> </p><ul><li><p>如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    users: []</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> created() &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">"/api/users"</span>);</span><br><span class="line">    <span class="keyword">this</span>.users = <span class="built_in">Object</span>.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;recycle-scroller</span><br><span class="line">  class=&quot;items&quot;</span><br><span class="line">  :items=&quot;items&quot;</span><br><span class="line">  :item-size=&quot;24&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">    &lt;FetchItemView</span><br><span class="line">      :item=&quot;item&quot;</span><br><span class="line">      @vote=&quot;voteItem(item)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/recycle-scroller&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 参考<a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a>、<a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">vue-virtual-scroll-list</a> </p></blockquote></li><li><p>事件的销毁 </p><p>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="keyword">this</span>.refresh, <span class="number">2000</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图片懒加载 </p><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 参考项目：<a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">vue-lazyload</a> </p></blockquote></li><li><p>第三方插件按需引入 </p><p>像element-ui这样的第三方组件库可以按需引入避免体积太大。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"></span><br><span class="line"> Vue.use(Button)</span><br><span class="line"> Vue.use(Select)</span><br></pre></td></tr></table></figure></li><li><p>无状态的组件标记为函数式组件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&apos;value&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件分割 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ChildComp/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp: &#123;</span><br><span class="line">      methods: &#123;</span><br><span class="line">        heavy () &#123; /* 耗时任务 */ &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      render (h) &#123;</span><br><span class="line">        return h(&apos;div&apos;, this.heavy())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>变量本地化 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; result &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; heavy &#125; from &apos;@/utils&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&apos;start&apos;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    base () &#123; return 42 &#125;,</span><br><span class="line">    result () &#123;</span><br><span class="line">      const base = this.base // 不要频繁引用this.base</span><br><span class="line">      let result = this.start</span><br><span class="line">      for (let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        result += heavy(base)</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>SSR</p></li></ul><h2 id="说一说你对vue响应式理解？"><a href="#说一说你对vue响应式理解？" class="headerlink" title="说一说你对vue响应式理解？"></a>说一说你对vue响应式理解？</h2><p> 烂大街的问题，但却不是每个人都能回答到位。因为如果你只是看看别人写的网文，通常没什么底气，也经不住面试官推敲，但像我们这样即看过源码还造过轮子的，回答这个问题就会比较有底气。 </p><p>答题思路：</p><ol><li>啥是响应式？</li><li>为什么vue需要响应式？</li><li>它能给我们带来什么好处？</li><li>vue的响应式是怎么实现的？有哪些优缺点？</li><li>vue3中的响应式的新变化</li></ol><p>回答范例：</p><ol><li>所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。</li><li>mvvm框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。</li><li>以vue为例说明，通过数据响应式加上虚拟DOM和patch算法，可以使我们只需要操作数据，完全不用接触繁琐的dom操作，从而大大提升开发效率，降低开发难度。</li><li>vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。</li><li>为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的Proxy机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，我们甚至不需要引入vue都可以体验。</li></ol><h2 id="你如果想要扩展某个Vue组件时会怎么做？"><a href="#你如果想要扩展某个Vue组件时会怎么做？" class="headerlink" title="你如果想要扩展某个Vue组件时会怎么做？"></a>你如果想要扩展某个Vue组件时会怎么做？</h2><p> 此题属于实践题，着重考察大家对vue常用api使用熟练度，答题时不仅要列出这些解决方案，同时最好说出他们异同。 </p><p>答题思路：</p><p>按照逻辑扩展和内容扩展来列举，逻辑扩展有：mixins、extends、composition api；内容扩展有slots；</p><p>分别说出他们使用使用方法、场景差异和问题。</p><p>作为扩展，还可以说说vue3中新引入的composition api带来的变化</p><p> 回答范例： </p><ol><li><p>常见的组件扩展方法有：mixins，slots，extends等</p></li><li><p>混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复用代码：它是一个配置对象，选项和组件里面一样</span></span><br><span class="line"><span class="keyword">const</span> mymixin = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dosomething()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局混入：将混入对象传入</span></span><br><span class="line">Vue.mixin(mymixin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部混入：做数组项设置到mixins选项，仅作用于当前组件</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  mixins: [mymixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插槽主要用于vue组件中的内容分发，也可以用于组件扩展。 </p><p>子组件Child </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot&gt;这个内容会被父组件传递的内容替换&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>父组件Parent </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Child&gt;来自老爹的内容&lt;/Child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果要精确分发到不同位置可以使用具名插槽，如果要使用子组件中的数据可以使用作用域插槽。 </p></li><li><p>组件选项中还有一个不太常用的选项extends，也可以起到扩展组件的目的 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展对象</span></span><br><span class="line"><span class="keyword">const</span> myextends = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dosomething()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件扩展：做数组项设置到extends选项，仅作用于当前组件</span></span><br><span class="line"><span class="comment">// 跟混入的不同是它只能扩展单个对象</span></span><br><span class="line"><span class="comment">// 另外如果和混入发生冲突，该选项优先级较高，优先起作用</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  extends: myextends</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中有机组合使用。例如： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复用逻辑1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useXX</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 复用逻辑2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useYY</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 逻辑组合</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;xx&#125; = useXX()</span><br><span class="line">    <span class="keyword">const</span> &#123;yy&#125; = useYY()</span><br><span class="line">    <span class="keyword">return</span> &#123;xx, yy&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的追问 :</p><p>Vue.extend方法你用过吗？它能用来做组件扩展吗？ </p></li></ol><h2 id="Vue2和Vue3中的响应式原理对比，分别的具体实现思路"><a href="#Vue2和Vue3中的响应式原理对比，分别的具体实现思路" class="headerlink" title="Vue2和Vue3中的响应式原理对比，分别的具体实现思路"></a>Vue2和Vue3中的响应式原理对比，分别的具体实现思路</h2><p>此题非常好，既考察深度又考察广度，面试者要对两个版本的响应式原理都有深入理解才能答好。</p><p> 答题思路：</p><ol><li>可以先说vue2响应式原理</li><li>然后说出它的问题</li><li><p>最后说出vue3是怎么解决的</p><p>回答范例：</p></li><li><p>vue2数据响应式实现根据对象类型做不同处理，如果是object，则通过<code>Object.defineProperty(obj,key,descriptor)</code>拦截对象属性访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(v) &#123;</span><br><span class="line">      val = v</span><br><span class="line">      notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是数组，则覆盖数组的7个变更方法实现变更通知</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line">;[<span class="string">'push'</span>,<span class="string">'pop'</span>,<span class="string">'shift'</span>,<span class="string">'unshift'</span>,<span class="string">'splice'</span>,<span class="string">'sort'</span>,<span class="string">'reverse'</span>]</span><br><span class="line">  .forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>可以看到vue2中有几个问题：</p><ul><li>初始化时需要遍历对象所有key，如果对象层级较深，性能不好</li><li>通知更新过程需要维护大量dep实例和watcher实例，额外占用内存较多</li><li>动态新增、删除对象属性无法拦截，只能用特定set/delete api代替</li><li>不支持新的Map、Set等数据结构</li></ul></li></ol><ol start="3"><li><p>vue3中为了解决以上问题，使用原生的Proxy代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      track(target, key)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, val) &#123;</span><br><span class="line">      <span class="built_in">Reflect</span>.set(target, key, val)</span><br><span class="line">      trigger(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, key) &#123;</span><br><span class="line">      <span class="built_in">Reflect</span>.deleteProperty(target, key)</span><br><span class="line">      trigger(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以同时支持object和array，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能取得很大进步。</p></li></ol><p><strong><a href="https://github.com/57code/vue-interview" target="_blank" rel="noopener">面试题剖析</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题集锦（2）</title>
      <link href="//posts/63fad71d.html"/>
      <url>//posts/63fad71d.html</url>
      
        <content type="html"><![CDATA[<h2 id="web安全攻击手段有哪些？以及如何防范"><a href="#web安全攻击手段有哪些？以及如何防范" class="headerlink" title="web安全攻击手段有哪些？以及如何防范"></a>web安全攻击手段有哪些？以及如何防范</h2><p>常见的有xss, csrf, sql注入</p><p><strong>xss(cross site scripting) 跨站脚本攻击</strong></p><p>定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行</p><p>XSS攻击分为3类：存储型（持久型）、反射型（非持久型）、基于DOM</p><p>如何防范:</p><p>设置HttpOnly以避免cookie劫持的危险<br>过滤，对诸如<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>等标签进行过滤<br>编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码<br>限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御</p><p><strong>csrf(cross site request forgery) 跨站请求伪造</strong></p><p>定义: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式</p><p>如何防范:</p><p>验证 HTTP Referer 字段<br>请求地址中添加 token 并验证<br>HTTP 头中自定义属性并验证</p><p><strong>sql注入(SQL injection)</strong></p><p>定义: 在未授权情况下，非法访问数据库信息</p><p>如何防范:</p><p>杜绝用户提交的参数入库并且执行<br>在代码层，不准出现sql语句<br>在web输入参数处，对所有的参数做sql转义<br>上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试</p><h2 id="前端优化手段有哪些？"><a href="#前端优化手段有哪些？" class="headerlink" title="前端优化手段有哪些？"></a>前端优化手段有哪些？</h2><ul><li>静态资源合并压缩(js,css, images)<ul><li>请求数量优化</li></ul></li><li>Gzip压缩<ul><li>带宽优化</li></ul></li><li>CDN<ul><li>就近节点，减少DNS查找</li></ul></li><li>按需加载</li><li>lazyload<ul><li>减少请求</li></ul></li><li>骨架屏<ul><li>优化白屏</li></ul></li><li>web缓存<ul><li>缓存ajax数据</li></ul></li><li>减少重绘和重排<ul><li>批量更新ＤＯＭ样式</li></ul></li><li>页面结构<ul><li>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</li></ul></li></ul><h2 id="如何理解es6中的Decorator（装饰器）？"><a href="#如何理解es6中的Decorator（装饰器）？" class="headerlink" title="如何理解es6中的Decorator（装饰器）？"></a>如何理解es6中的Decorator（装饰器）？</h2><p><strong>定义</strong></p><p>Decorator是ES7中的提案，概念借鉴于python， 它作用于一个目标类为其添加属性于方法</p><p>我们用一个比喻来理解Decorator, 把孙悟空看成是一个类，那么棒子就是装饰器为其装备的武器</p><p> 代码理解: </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@stick</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stick</span><span class="params">(target)</span> </span>&#123;<span class="comment">// 第一个参数就是目标类的本身</span></span><br><span class="line">  target.ATK = <span class="number">100000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Monkey.ATK<span class="comment">// 为悟空装备了棒子，攻击力提高了100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个参数不够用，可以在装饰器外层再包一层</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stick</span><span class="params">(atk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(targt)</span> </span>&#123;</span><br><span class="line">    target.ATK = atk</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@stick(<span class="number">200000</span>)<span class="comment">// 这样我们就为悟空增加了200000攻击力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p> Decorator 不仅能修饰类，也能修饰类的方法 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123;</span><br><span class="line">  <span class="meta">@setName</span></span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'孙悟空'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Decorator 只能修饰类及类的方法,不能修饰于函数,因为存在函数提升 </p><p><strong>Mixin</strong></p><p> 在修饰器基础上，我们可以实现mixin(混入),意思在一个对象中混入另一个对象的方法 </p><p> 代码示例: </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export <span class="function"><span class="keyword">function</span> <span class="title">mixins</span><span class="params">(<span class="rest_arg">...list</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(target)</span> </span>&#123;</span><br><span class="line">    Object.assign(target.prototype, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> skill = &#123;</span><br><span class="line">  shapeshifting() &#123;</span><br><span class="line">    console.log(<span class="string">'72变'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixins(skill)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Monkey.prototype, skill)</span><br><span class="line"><span class="keyword">const</span> swk = <span class="keyword">new</span> Monkey()</span><br><span class="line">swk.shapeshifting() <span class="comment">// 72变</span></span><br></pre></td></tr></table></figure><p><strong>使用Decorator的好处</strong></p><ul><li>扩展功能，相对于继承增加了更多的灵活性</li><li>代码可读性更高，装饰器正确命名相当于注释</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入webpack</title>
      <link href="//posts/a441c8bd.html"/>
      <url>//posts/a441c8bd.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2><p>0、读取webpack.config.js</p><p>1、解析文件依赖</p><p>2、替换require为<strong>webpack_require</strong></p><p>3、本地使用{}存储所有的文件，然后通过使用为<strong>webpack_require</strong>获取文件内容，执行函数方式为evel的包裹代码字符串</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>index.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取config</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">const</span> defaultConfig = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'build.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终的配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  ...defaultConfig,</span><br><span class="line">  ...require(path.resolve(<span class="string">'./mywebpack.config.js'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWebPack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(config) &#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config</span><br><span class="line">    <span class="keyword">this</span>.entry = config.entry</span><br><span class="line">    <span class="comment">// 根目录</span></span><br><span class="line">    <span class="keyword">this</span>.root = process.cwd()</span><br><span class="line">    <span class="comment">// 存储所有代码</span></span><br><span class="line">    <span class="keyword">this</span>.modules = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'解析依赖'</span>)</span><br><span class="line">    <span class="keyword">const</span> entryPath = path.resolve(<span class="keyword">this</span>.root, <span class="keyword">this</span>.entry)</span><br><span class="line">    <span class="keyword">this</span>.createModule(entryPath, <span class="keyword">this</span>.entry)</span><br><span class="line">    <span class="comment">// 生成新文件</span></span><br><span class="line">    <span class="keyword">this</span>.generaleFile()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 代码字符串</span></span><br><span class="line">  generaleModuleString() &#123;</span><br><span class="line">    <span class="keyword">let</span> fnTmp = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> <span class="keyword">this</span>.modules) &#123;</span><br><span class="line">      fnTmp += <span class="string">`"<span class="subst">$&#123;name&#125;</span>":<span class="subst">$&#123;<span class="keyword">this</span>.modules[name].replace(<span class="regexp">/\r|\n/g</span>, <span class="string">""</span>)&#125;</span>,`</span></span><br><span class="line">    &#125;</span><br><span class="line">    fnTmp = fnTmp.substring(<span class="number">0</span>, fnTmp.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;fnTmp&#125;</span>&#125;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成新文件</span></span><br><span class="line">  generaleFile() &#123;</span><br><span class="line">    <span class="keyword">let</span> template = fs.readFileSync(path.resolve(__dirname, <span class="string">'./template.js'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">this</span>.template = template.replace(<span class="string">'__entry__'</span>, <span class="keyword">this</span>.entry).replace(<span class="string">'__modules_content__'</span>, <span class="keyword">this</span>.generaleModuleString())</span><br><span class="line">    fs.mkdirSync(<span class="string">"./mydist"</span>);</span><br><span class="line">    fs.writeFileSync(<span class="string">'./mydist/'</span> + <span class="keyword">this</span>.config.output.filename, <span class="keyword">this</span>.template)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'写入文件完毕'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建依赖</span></span><br><span class="line">  createModule(modulePath, name) &#123;</span><br><span class="line">    <span class="comment">// 出现了循环依赖</span></span><br><span class="line">    <span class="comment">// if (this.modules[modulePath]) return</span></span><br><span class="line">    <span class="keyword">const</span> fileContent = fs.readFileSync(modulePath, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">// 替换后的代码和依赖数组</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code, deps &#125; = <span class="keyword">this</span>.parse(fileContent, path.dirname(name))</span><br><span class="line">    <span class="keyword">this</span>.modules[name] = <span class="string">`function (module, module.exports, __mywebpack_require__) &#123;</span></span><br><span class="line"><span class="string">      eval(\`<span class="subst">$&#123;code&#125;</span>\`)</span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">    <span class="comment">// 循环获取所有依赖数组的内容</span></span><br><span class="line">    deps.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.createModule(path.join(<span class="keyword">this</span>.root, dep), <span class="string">'./'</span> + dep)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.modules)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 文件解析</span></span><br><span class="line">  parse(code, parent) &#123;</span><br><span class="line">    <span class="keyword">let</span> deps = []</span><br><span class="line">    <span class="keyword">let</span> r = <span class="regexp">/require\('(.*)'\)/g</span></span><br><span class="line">    <span class="comment">// require('xxx') 将require替换__mywebpack_require__</span></span><br><span class="line">    code = code.replace(r, <span class="function"><span class="keyword">function</span> (<span class="params">match, arg</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> retPath = path.join(parent, arg.replace(<span class="regexp">/'|"/g</span>, <span class="string">''</span>))</span><br><span class="line">      deps.push(retPath)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`__mywebpack_require__("./<span class="subst">$&#123;retPath&#125;</span>")`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; code, deps &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mywebpack = <span class="keyword">new</span> MyWebPack(config)</span><br><span class="line"></span><br><span class="line">mywebpack.start()</span><br></pre></td></tr></table></figure><p><strong>template.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">const</span> installModules = &#123;&#125;</span><br><span class="line">  <span class="comment">// 替换后的require</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__mywebpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 是否缓存</span></span><br><span class="line">    <span class="keyword">if</span> (installModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installModules[moduleId].exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> modules = installModules[moduleId] = &#123;</span><br><span class="line">      exports: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modules[moduleId].call(modules.exports, <span class="built_in">module</span>, exports, __mywebpack_require__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="keyword">return</span> __mywebpack_require__(<span class="string">"__entry__"</span>)</span><br><span class="line">&#125;(__modules_content__)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入前端模块化</title>
      <link href="//posts/c00659d0.html"/>
      <url>//posts/c00659d0.html</url>
      
        <content type="html"><![CDATA[<p>什么是前端的模块化？理解的不太透彻。</p><p>平常一直用的也只有ES6模块化，对于其他几种模块化规范用的也少，理解不够深，但是经常会见到一些面试题是问这几种模块化规范的区别，所以这次做一个整理总结</p><h1 id="一、对于模块化的理解"><a href="#一、对于模块化的理解" class="headerlink" title="一、对于模块化的理解"></a>一、对于模块化的理解</h1><h2 id="1、什么是模块化？"><a href="#1、什么是模块化？" class="headerlink" title="1、什么是模块化？"></a>1、什么是模块化？</h2><p>模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的AMD规范，CMD规范，以及ES6自带的模块化规范</p><h2 id="2、模块化带来的好处？"><a href="#2、模块化带来的好处？" class="headerlink" title="2、模块化带来的好处？"></a>2、模块化带来的好处？</h2><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li><li>灵活架构，焦点分离，方便模块间组合、分解</li><li>多人协作互不干扰</li></ul><h2 id="3、模块化规范的发展进程"><a href="#3、模块化规范的发展进程" class="headerlink" title="3、模块化规范的发展进程"></a>3、模块化规范的发展进程</h2><ul><li><strong>原始写法（全局function）</strong></li></ul><p>模块就是实现特定**功能的一组方法，只要把不同的函数（以及记录状态的变量）简单的放在一起，就算是一个模块。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这样写上面的函数 m1() 和 m2() ，组成了一个模块，在使用的时候直接调用就可以了。但是带来的问题也很明显：&quot;污染&quot;了全局变量 ，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系</code></p><ul><li><strong>namespace写法（简单对象）</strong></li></ul><p>为了解决上面写法带来的缺点，可以吧模块写成一个对象，所有的模块成员都放到这个对象里面，这样减少了全局变量，减少命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  m1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'m1:'</span> + <span class="keyword">this</span>.count);</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  m2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'m2:'</span> + <span class="keyword">this</span>.count)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">myModule.m1() <span class="comment">// m1:0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变模块内部状态</span></span><br><span class="line">myModule.count = <span class="number">5</span>;</span><br><span class="line">myModule.m1() <span class="comment">// m1:5</span></span><br></pre></td></tr></table></figure><p><code>上面的函数 m1 和 m2 ，都封装在myModule对象里。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</code></p><ul><li><strong>立即执行函数写法（匿名函数自执行 ，闭包）</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'m1:'</span> + count)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'m2:'</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; m1, m2 &#125;;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写在外面就无法读取内部的 count 变量</span></span><br><span class="line"><span class="built_in">console</span>.log(myModule.count); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><strong>立即执行函数增强(引入依赖)</strong></li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = (<span class="function"><span class="keyword">function</span> <span class="params">($)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里面就可以使用JQuery</span></span><br><span class="line">&#125;)(JQuery)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h1><h2 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1. CommonJS"></a>1. CommonJS</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="(1)简介"></a>(1)简介</h3><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h3 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">暴露模块：module<span class="selector-class">.exports</span> = value或exports<span class="selector-class">.xxx</span> = value</span><br><span class="line">引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</span><br></pre></td></tr></table></figure><p><code>CommonJS暴露的模块到底是什么? CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</code></p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="built_in">let</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">let</span> incrementCount = <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  return ++count</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span>.<span class="title">count</span> =</span> count;</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span>.<span class="title">incrementCount</span> =</span> incrementCount;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// require.js</span></span><br><span class="line"><span class="keyword">const</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(example.count); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.incrementCount()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</strong></p><h3 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h3><p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值</strong>，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（ES6输入的是值的引用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> incrementCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; count, incrementCount &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// require.js</span></span><br><span class="line"><span class="keyword">const</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.count); <span class="comment">// 5</span></span><br><span class="line">example.incrementCount();</span><br><span class="line"><span class="built_in">console</span>.log(example.count); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2. AMD"></a>2. AMD</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="(1)简介"></a>(1)简介</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p><p><strong>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</strong></p><p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</strong> 此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p><h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="(2)基本语法"></a>(2)基本语法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param id</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param dependencies</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param factory</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br><span class="line"></span><br><span class="line">define(id?: <span class="built_in">String</span>, dependencies?: <span class="built_in">String</span>[], <span class="keyword">factory</span>: <span class="built_in">Function</span>|<span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><p><code>id</code> 是模块的名字，它是可选的参数。</p><p><code>dependencies</code> 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。</p><p><code>factory</code> 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p><h3 id="3-用例"><a href="#3-用例" class="headerlink" title="(3)用例"></a>(3)用例</h3><p>定义一个名为 myModule 的模块，它依赖 jQuery 模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'myModule'</span>, [<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ 是 jquery 模块的输出</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>依赖多个模块的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>, <span class="string">'./math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ 和 math 一次传入 factory</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>模块输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> HelloWorldize = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">        $(selector).text(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HelloWorldize 是该模块输出的对外接口</span></span><br><span class="line">    <span class="keyword">return</span> HelloWorldize;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在模块定义内部引用依赖：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="name">function</span>(<span class="name">require</span>) &#123;</span><br><span class="line">    var $ = require('jquery')<span class="comment">;</span></span><br><span class="line">    $('body').text('hello world')<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3. CMD"></a>3. CMD</h2><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="(1)简介"></a>(1)简介</h3><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h3 id="2-基本语法-1"><a href="#2-基本语法-1" class="headerlink" title="(2)基本语法"></a>(2)基本语法</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">param</span> &#123;String&#125; <span class="keyword">id</span></span><br><span class="line">* @<span class="keyword">param</span> &#123;Array&#125; <span class="keyword">dependencies</span></span><br><span class="line">* @<span class="keyword">param</span> &#123;Function | Object | String&#125; <span class="keyword">factory</span></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">define</span>(<span class="section">id</span>?, dependencies?, factory)</span><br></pre></td></tr></table></figure><p>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span>(&#123; <span class="string">"foo"</span>: <span class="string">"bar"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span>('<span class="section">I</span> am a template. My name <span class="keyword">is</span> &#123;&#123;<span class="literal">name</span>&#125;&#125;.<span class="string">');</span></span><br></pre></td></tr></table></figure><p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 方法在执行时，默认会传入三个参数：require、exports 和 module：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">require</span>, exports, <span class="keyword">module</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">  // 模块代码</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br></pre></td></tr></table></figure><h3 id="3-简单用例"><a href="#3-简单用例" class="headerlink" title="(3)简单用例"></a>(3)简单用例</h3><p>定义没有依赖的模块：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">define</span><span class="params">(function(require, exports, module)</span></span>&#123;</span><br><span class="line">  exports<span class="selector-class">.xxx</span> = value</span><br><span class="line">  module<span class="selector-class">.exports</span> = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义有依赖的模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">'./module2'</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">'./module3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-ES6模块化"><a href="#4-ES6模块化" class="headerlink" title="4. ES6模块化"></a>4. ES6模块化</h2><h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="(1) 简介"></a>(1) 简介</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p><p>CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，<strong>CommonJS 模块就是对象</strong>，输入时必须查找对象属性。</p><p><strong>ES6 模块不是对象</strong>，而是通过export命令显式指定输出的代码，再通过import命令输入。</p><h3 id="2-基本语法-2"><a href="#2-基本语法-2" class="headerlink" title="(2) 基本语法"></a>(2) 基本语法</h3><p><code>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 **/</span></span><br><span class="line">var <span class="keyword">basicNum </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">var <span class="keyword">add </span>= function (a, <span class="keyword">b) </span>&#123;</span><br><span class="line">    return a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">export </span>&#123; <span class="keyword">basicNum, </span><span class="keyword">add </span>&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line">import &#123; <span class="keyword">basicNum, </span><span class="keyword">add </span>&#125; from <span class="string">'./math'</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = <span class="keyword">add(99 </span>+ <span class="keyword">basicNum);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>导出模块还可以有种默认导出的写法 <code>module.export</code> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</span></span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>; </span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><h3 id="3-ES6-模块与-CommonJS-模块的差异"><a href="#3-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(3) ES6 模块与 CommonJS 模块的差异"></a>(3) ES6 模块与 CommonJS 模块的差异</h3><ol><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块输出的是一个值的拷贝， ES6 模块输出的是一个值的引用</li></ol><p>差异一：</p><p>是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>差异二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> incrementNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; num, num2, incrementNum &#125; <span class="keyword">from</span> <span class="string">'../export.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(incrementNum());</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>从上面我们不难看出 ES6 模块化 与上面CommonJS不一样的地方</p><p><strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。CommonJS输入的是值的拷贝（原始类型），如果是函数、对象，也是用的引用</strong></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul><li><p>CommonJS规范主要用于服务端编程，<strong>加载模块是同步的，这并不适合在浏览器环境</strong>，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</p></li><li><p>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p></li><li><p>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重</p></li><li><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</strong></p></li></ul><h2 id="前端模块化详解-完整版"><a href="#前端模块化详解-完整版" class="headerlink" title="前端模块化详解(完整版)"></a><a href="https://juejin.cn/post/6844903744518389768#heading-9" target="_blank" rel="noopener">前端模块化详解(完整版)</a></h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么前端需要学习node</title>
      <link href="//posts/fbba48cc.html"/>
      <url>//posts/fbba48cc.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>理解解决跨域、token鉴权、Rsetful风格、XSS、CSRF等问题，学习后端的思维。（与后端有效沟通）</p></li><li><p>如何只用js语言如何开发一个全栈的应用（快速开发全栈应用）</p></li><li><p>学习全栈和架构思维的有效途径（践行工程化思想）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue性能优化</title>
      <link href="//posts/93532fe.html"/>
      <url>//posts/93532fe.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、使用单文件组件"><a href="#1、使用单文件组件" class="headerlink" title="1、使用单文件组件"></a>1、使用单文件组件</h2><p>我们写的tmplate配置，实际上需要编译为render函数在执行的</p><p>当使用DOM内模板或者JS内的字符串模板时，模板会在运行时被编译为render函数，通常情况这个过程已经足够快乐，但是对性能敏感的应用还是有影响的。</p><p><a href="https://imgchr.com/i/rAis9f" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAis9f.png" alt="rAis9f.png"></a></p><p>预编译模板最简单的方式就是使用<strong>单文件组件</strong>，单文件组件将相关的构建设置自动预编译好了，所以构建的代码已经包含了编译出来的render函数了，而不是原始的模板字符串了，减少了重新编译的过程了。（单文件组件导入使用直接使用vue-loader来处理，没有vue-tmplate的出来，使用起来会足够快速的。）</p><a id="more"></a><h2 id="2、使用Objaec-freeze-提升性能"><a href="#2、使用Objaec-freeze-提升性能" class="headerlink" title="2、使用Objaec.freeze()提升性能"></a>2、使用<code>Objaec.freeze()</code>提升性能</h2><p>参考vue源码，定义响应式的时候，如果freeze后的数据，不会加上setter和getter</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">property</span><span class="title"> </span>= Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">if (<span class="keyword">property</span><span class="title"> </span>&amp;&amp; <span class="keyword">property</span>.<span class="title"></span>configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、扁平化数据store"><a href="#3、扁平化数据store" class="headerlink" title="3、扁平化数据store"></a>3、扁平化数据store</h2><p>store数据扁平化，减少数据层级嵌套，减少遍历。</p><h2 id="4、列表渲染优化"><a href="#4、列表渲染优化" class="headerlink" title="4、列表渲染优化"></a>4、列表渲染优化</h2><p>如果的我们的应用存在无限长或者无限滚动的长列表，那么采用 <strong>窗口化</strong>的技术来优化，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。</p><p><a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">vue-virtual-scroll-list</a></p><p><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a></p><p>可以使用上面的两个库来处理</p><p><a href="https://imgchr.com/i/rAt2MF" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAt2MF.png" alt="rAt2MF.png"></a></p><h2 id="5、骨架屏"><a href="#5、骨架屏" class="headerlink" title="5、骨架屏"></a>5、骨架屏</h2><p><a href="https://imgchr.com/i/rANGw9" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rANGw9.png" alt="rANGw9.png"></a></p><p>webpack骨架屏的实践方案: <a href="https://www.jianshu.com/p/ec4bf33ab2c8" target="_blank" rel="noopener">https://www.jianshu.com/p/ec4bf33ab2c8</a></p><h2 id="6、-ssr服务端渲染"><a href="#6、-ssr服务端渲染" class="headerlink" title="6、 ssr服务端渲染"></a>6、 ssr服务端渲染</h2><p><a href="https://imgchr.com/i/rAUzgf" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAUzgf.png" alt="rAUzgf.png"></a></p><p>实现方案可以采用<a href="https://www.nuxtjs.cn/" target="_blank" rel="noopener">nuxt.js</a></p><h2 id="7、-路由懒加载"><a href="#7、-路由懒加载" class="headerlink" title="7、 路由懒加载"></a>7、 路由懒加载</h2><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><h2 id="8、-gzip、缓存控制、cdn"><a href="#8、-gzip、缓存控制、cdn" class="headerlink" title="8、 gzip、缓存控制、cdn"></a>8、 gzip、缓存控制、cdn</h2><p><strong>开启GZIP</strong></p><p>体积对比图：<br>1541KB vs 466KB</p><p><a href="https://imgchr.com/i/rAdpJ1" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAdpJ1.png" alt="rAdpJ1.png"></a></p><p>耗时对比图：<br>333ms vs 225ms</p><p><a href="https://imgchr.com/i/rAdZod" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAdZod.png" alt="rAdZod.png"></a></p><p>操作步骤：</p><p>1、安装包（新版本的好像配置还要改~~）</p><p><code>npm install --save-dev compression-webpack-plugin</code></p><p>2、webpack的配置</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">productionGzip</span>: true,</span><br><span class="line"></span><br><span class="line"><span class="attribute">productionGzipExtensions</span>: ['js', 'css']</span><br></pre></td></tr></table></figure><p>3、nginx添加配置：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  gzip <span class="keyword">on</span>; <span class="comment">#开启或关闭gzip on off</span></span><br><span class="line">  gzip_static <span class="keyword">on</span>;</span><br><span class="line">  gzip_disable <span class="string">"msie6"</span>; <span class="comment">#不使用gzip IE6</span></span><br><span class="line">  gzip_min_length <span class="number">100</span>k;  <span class="comment">#gzip压缩最小文件大小，超出进行压缩（自行调节）</span></span><br><span class="line">  gzip_types <span class="built_in">text</span>/plain <span class="built_in">application</span>/x-javascript <span class="built_in">text</span>/css <span class="built_in">application</span>/xml <span class="built_in">text</span>/javascript <span class="built_in">application</span>/x-httpd-php image/jpeg image/gif image/png;  <span class="comment">#压缩文件类型</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CND加速</strong></p><p>vue打包文件会默认把所有的第三方代码打包到一个vendor.js中，我们可以把部分超大的文件剥离出来，使用cnd资源。如图，我们将vue/vuex/vue-router/axios分离出来降低vendor.js的压力。</p><p><a href="https://imgchr.com/i/rAwVXT" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAwVXT.png" alt="rAwVXT.png"></a></p><p>1、引入外部资源CDN</p><p><a href="https://imgchr.com/i/rAwMN9" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAwMN9.png" alt="rAwMN9.png"></a></p><p>2、webpack处理（别名处理）</p><p>key：要引入的资源名称；value：模块提供给外部引用的名称</p><p><a href="https://imgchr.com/i/rAw31x" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAw31x.png" alt="rAw31x.png"></a></p><p>3、去除引用，如果想避免全局污染，可如下定义</p><p><a href="https://imgchr.com/i/rAwYnO" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/11/rAwYnO.png" alt="rAwYnO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题（1）</title>
      <link href="//posts/f0a558a1.html"/>
      <url>//posts/f0a558a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue双向绑定实现原理？"><a href="#Vue双向绑定实现原理？" class="headerlink" title="Vue双向绑定实现原理？"></a>Vue双向绑定实现原理？</h2><p>vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p><p>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 双花括弧），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p><ul><li>Observer 对所有数据的属性进行监听</li><li>Compile 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li><li>Watcher 作为连接Observer 跟 Compile 之间的桥梁, 能够订阅接收到每个属性变动的通知,执行相应的回调函数</li></ul><p>代码理解: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Dep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(sub = &gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Watcher = <span class="function"><span class="keyword">function</span>(<span class="params">vm, node, name</span>) </span>&#123;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.node = node;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.update();</span><br><span class="line">  Dep.target = <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.get();</span><br><span class="line">    <span class="keyword">this</span>.node.nodeValue = <span class="keyword">this</span>.value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.vm[<span class="keyword">this</span>.name]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> compile = <span class="function"><span class="keyword">function</span>(<span class="params">node, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> attr = node.attributes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attr[i].nodeName === <span class="string">'v-model'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = attr[i].nodeValue;</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, e = &gt; &#123;</span><br><span class="line">          vm[name] = node.value</span><br><span class="line">        &#125;);</span><br><span class="line">        node.value = vm[name];</span><br><span class="line">        node.removeAttribute(<span class="string">'v-model'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>.test(node.nodeValue)) &#123;</span><br><span class="line">      <span class="keyword">let</span> name = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">      name = name.trim();</span><br><span class="line">      node.nodeValue = vm[name];</span><br><span class="line">      <span class="keyword">new</span> Watcher(vm, node, name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observe = data = &gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span> <span class="number">3344</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(key = &gt; defineReactive(data, key, data[key]))</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> defineReactive = (data, key, value) = &gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  observe(value);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>: () = &gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) dep.addSub(Dep.target);</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`数据已发生变化，新的值为$ &#123;</span></span><br><span class="line"><span class="string">newValue</span></span><br><span class="line"><span class="string">&#125;`</span>);</span><br><span class="line">      value = newValue;</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nodeToFragment</span>(<span class="params">node, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> ((child = node.firstChild)) &#123;</span><br><span class="line">    compile(child, vm);</span><br><span class="line">    flag.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>.data = options.data;</span><br><span class="line">  observe(data, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> id = options.el;</span><br><span class="line">  <span class="keyword">let</span> dom = nodeToFragment(<span class="built_in">document</span>.getElementById(id), data);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(id).appendChild(dom)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: <span class="string">'example text'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 题目分析：双向绑定是vue的特色之一，开发中必然会用到的知识点，然而此题还问了实现原理，升级为深度考查。 </p><p>思路分析：3w1h</p><ol><li>给出双绑定义</li><li>双绑带来的好处</li><li>在哪使用双绑</li><li>使用方式</li><li>扩展：使用细节、原理实现描述</li></ol><p>回答范例：</p><ol><li>vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。</li><li>使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</li><li>通常在表单项上使用v-model</li><li>原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件</li><li>我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。</li></ol><p>可能的追问：</p><ol><li>v-model和sync修饰符有什么区别</li><li><p>自定义组件使用v-model如果想要改变事件名或者属性名应该怎么做</p><p>观察输出的渲染函数： </p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" v-model="foo"&gt;</span></span><br><span class="line">_c(<span class="string">'input'</span>, &#123; </span><br><span class="line">  directives: [&#123; <span class="attr">name</span>: <span class="string">"model"</span>, <span class="attr">rawName</span>: <span class="string">"v-model"</span>, <span class="attr">value</span>: (foo), <span class="attr">expression</span>: <span class="string">"foo"</span> &#125;], </span><br><span class="line">  attrs: &#123; <span class="string">"type"</span>: <span class="string">"text"</span> &#125;, </span><br><span class="line">  domProps: &#123; <span class="string">"value"</span>: (foo) &#125;, </span><br><span class="line">  on: &#123; </span><br><span class="line">    <span class="string">"input"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">$event</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">if</span> ($event.target.composing) <span class="keyword">return</span>; </span><br><span class="line">      foo = $event.target.value </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="checkbox" v-model="bar"&gt;</span></span><br><span class="line">_c(<span class="string">'input'</span>, &#123; </span><br><span class="line">  directives: [&#123; <span class="attr">name</span>: <span class="string">"model"</span>, <span class="attr">rawName</span>: <span class="string">"v-model"</span>, <span class="attr">value</span>: (bar), <span class="attr">expression</span>: <span class="string">"bar"</span> &#125;], </span><br><span class="line">  attrs: &#123; <span class="string">"type"</span>: <span class="string">"checkbox"</span> &#125;, </span><br><span class="line">  domProps: &#123; </span><br><span class="line">    <span class="string">"checked"</span>: <span class="built_in">Array</span>.isArray(bar) ? _i(bar, <span class="literal">null</span>) &gt; <span class="number">-1</span> : (bar) </span><br><span class="line">  &#125;, </span><br><span class="line">  on: &#123; </span><br><span class="line">    <span class="string">"change"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">$event</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">var</span> $$a = bar, $$el = $event.target, $$c = $$el.checked ? (<span class="literal">true</span>) : (<span class="literal">false</span>); </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray($$a)) &#123; </span><br><span class="line">        <span class="keyword">var</span> $$v = <span class="literal">null</span>, $$i = _i($$a, $$v); </span><br><span class="line">        <span class="keyword">if</span> ($$el.checked) &#123; $$i &lt; <span class="number">0</span> &amp;&amp; (bar = $$a.concat([$$v])) &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">          $$i &gt; <span class="number">-1</span> &amp;&amp; (bar = $$a.slice(<span class="number">0</span>, $$i).concat($$a.slice($$i + <span class="number">1</span>))) &#125; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        bar = $$c </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;select v-model="baz"&gt;</span></span><br><span class="line"><span class="comment">//     &lt;option value="vue"&gt;vue&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//     &lt;option value="react"&gt;react&lt;/option&gt;</span></span><br><span class="line"><span class="comment">// &lt;/select&gt;</span></span><br><span class="line">_c(<span class="string">'select'</span>, &#123; </span><br><span class="line">  directives: [&#123; <span class="attr">name</span>: <span class="string">"model"</span>, <span class="attr">rawName</span>: <span class="string">"v-model"</span>, <span class="attr">value</span>: (baz), <span class="attr">expression</span>: <span class="string">"baz"</span> &#125;], </span><br><span class="line">  on: &#123; </span><br><span class="line">    <span class="string">"change"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">$event</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">var</span> $$selectedVal = <span class="built_in">Array</span>.prototype.filter.call(</span><br><span class="line">        $event.target.options, </span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="keyword">return</span> o.selected &#125;</span><br><span class="line">      ).map(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; </span><br><span class="line">          <span class="keyword">var</span> val = <span class="string">"_value"</span> <span class="keyword">in</span> o ? o._value : o.value; </span><br><span class="line">          <span class="keyword">return</span> val </span><br><span class="line">        &#125;</span><br><span class="line">      ); </span><br><span class="line">      baz = $event.target.multiple ? $$selectedVal : $$selectedVal[<span class="number">0</span>] </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;, [</span><br><span class="line">  _c(<span class="string">'option'</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="string">"value"</span>: <span class="string">"vue"</span> &#125; &#125;, [_v(<span class="string">"vue"</span>)]), _v(<span class="string">" "</span>), </span><br><span class="line">  _c(<span class="string">'option'</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="string">"value"</span>: <span class="string">"react"</span> &#125; &#125;, [_v(<span class="string">"react"</span>)])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Vue-router有几种模式？如何实现呢？"><a href="#Vue-router有几种模式？如何实现呢？" class="headerlink" title="Vue-router有几种模式？如何实现呢？"></a>Vue-router有几种模式？如何实现呢？</h2><blockquote><p> 在vue-router中有两种模式 </p></blockquote><ul><li>history<br>history 为 HTML5 Api,提供了丰富的router 相关属性， 比如history.back() 就能轻松的做到页面回退</li><li>hash<br>hash router 有一个明显的标志是url 中带有#， 我们可以通过监听url中的hash来进行路由跳转</li></ul><p><strong>如何实现</strong></p><p> <strong>history</strong> </p><p> 在代码实现前，我们先看看history几个api </p><ul><li>history.pushState 浏览器历史纪录添加记录</li><li>history.replaceState 修改浏览器历史纪录中当前纪录</li><li><p>history.popState 当history 发生变化时触发</p><p>在结合代码理解: </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  contructor() &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.listerPopState()</span><br><span class="line">  &#125;</span><br><span class="line">  init(path) &#123;</span><br><span class="line">    history.replaceState(&#123;</span><br><span class="line">      path: path</span><br><span class="line">    &#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="keyword">this</span>.routes[path] &amp;&amp; <span class="keyword">this</span>.routes[path]()</span><br><span class="line">  &#125;</span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  push(path) &#123;</span><br><span class="line">    history.pushState(&#123;</span><br><span class="line">      path: path</span><br><span class="line">    &#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="keyword">this</span>.routes[path] &amp;&amp; <span class="keyword">this</span>.routes[path]()</span><br><span class="line">  &#125;</span><br><span class="line">  listerPopState() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e = &gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> path = e.state &amp;&amp; e.state.path;</span><br><span class="line">      <span class="keyword">this</span>.routers[path] &amp;&amp; <span class="keyword">this</span>.routers[path]()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.VueRouter = <span class="keyword">new</span> Routers();</span><br><span class="line">VueRouter.route(<span class="string">'/'</span>, () = &gt; <span class="built_in">console</span>.log(<span class="string">'JS'</span>)) VueRouter.route(<span class="string">'/detail'</span>, () = &gt; <span class="built_in">console</span>.log(<span class="string">'JS每日一题'</span>)) VueRouter.push(<span class="string">'/detail'</span>)</span><br></pre></td></tr></table></figure><p> <strong>hash router</strong> </p><p> 上面说过我们可以通过监听url中的hash来进行路由跳转 </p><p> 结合代码理解: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.refresh = <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  route(path, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.routes[path] = callback</span><br><span class="line">  &#125;</span><br><span class="line">  push() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl] &amp;&amp; <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.VueRouter = <span class="keyword">new</span> Routers();</span><br><span class="line">VueRouter.route(<span class="string">'/'</span>, () = &gt; <span class="built_in">console</span>.log(<span class="string">'JS'</span>)) VueRouter.route(<span class="string">'/detail'</span>, () = &gt; <span class="built_in">console</span>.log(<span class="string">'JS每日一题'</span>)) VueRouter.push(<span class="string">'/detail'</span>)</span><br></pre></td></tr></table></figure><p> 工作中不必太过纠结使用哪种模式，hash模式url中会带有#号，破坏url整体的美观性, history 需要服务端支持rewrite, 否则刷新会出现404现象 </p><h2 id="vue中keepalive怎么理解？"><a href="#vue中keepalive怎么理解？" class="headerlink" title="vue中keepalive怎么理解？"></a>vue中keepalive怎么理解？</h2><blockquote><p> 说在前面: keep-alive是vue源码中实现的一个组件, 感兴趣的可以研究源码 <a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js</a> </p></blockquote><p><strong>什么是keepalive</strong></p><p>我们平时开发中, 总有部分组件没有必要多次init, 我们需要将组件进行持久化，使组件状态维持不变，在下一次展示时， 也不会进行重新init</p><p>keepalive音译过来就是保持活着, 所以在vue中我们可以使用keepalive来进行组件缓存</p><p>基本使用</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被keepalive包含的组件会被进行缓存</span></span><br><span class="line"><span class="params">&lt; keep - alive &gt;</span> <span class="params">&lt; component / &gt;</span> <span class="params">&lt; /keep-alive&gt;</span></span><br></pre></td></tr></table></figure><p> 上面提到被keepalive包含的组件不会被再次init，也就意味着不会重走生命周期函数, 但是平常工作中很多业务场景是希望我们缓存的组件在再次渲染的能做一些事情,vue为keepalive提供了两个额外的hook </p><ul><li>activated 当keepalive包含的组件再次渲染的时候触发</li><li><p>deactivated 当keepalive包含的组件销毁的时候触发</p><p>注: 2.1.0 版本后keepalive包含但被exclude排除的组件不会有以上两个hook </p></li></ul><p><strong>参数</strong></p><p> keepalive可以接收3个属性做为参数进行匹配对应的组件进行缓存 </p><ul><li>include 包含的组件</li><li>exclude 排除的组件</li><li>max 缓存组件的最大值</li></ul><p>其中include,exclude可以为字符，数组，以及正则表达式<br>max 类型为字符或者数字</p><p>代码理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只缓存组件name为a或者b的组件</span></span><br><span class="line">&lt;keep-alive include = <span class="string">"a,b"</span> &gt; </span><br><span class="line">   &lt;component: is = <span class="string">"currentView"</span> /&gt; </span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 组件名为c的组件不缓存</span></span><br><span class="line"><span class="regexp">&lt;keep-alive exclude="c"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;component:is="currentView"/</span> &gt; </span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 如果同时使用include,exclude,那么exclude优先于include， 下面的例子也就是只缓存a组件</span></span><br><span class="line"><span class="regexp">&lt;keep-alive include="a,b"exclude="b"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;component:is="currentView"/</span> &gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 如果缓存的组件超过了max设定的值5，那么将删除第一个缓存的组件</span></span><br><span class="line"><span class="regexp">&lt;keep-alive exclude="c"max="5"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;component:is="currentView"/</span> &gt; </span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配合router使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template --&gt;</span><br><span class="line"><span class="comment">// 意思就是$router.meta.keepAlive值为真是将组件进行缓存</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$router.meta.keepAlive"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-view v-if="!$router.meta.keepAlive"&gt;&lt;/</span>router-view&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//router配置</span></span><br><span class="line"><span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [&#123;</span><br><span class="line">    name: <span class="string">'a'</span>,</span><br><span class="line">    path: <span class="string">'/a'</span>,</span><br><span class="line">    component: A,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      keepAlive: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">'b'</span>,</span><br><span class="line">    path: <span class="string">'/b'</span>,</span><br><span class="line">    component: B</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p> keepalive是一个抽象组件，缓存vnode，缓存的组件不会被mounted，为此提供activated 和 deactivated 钩子函数, 使用props max 可以控制缓存组件个数 </p><h2 id="Vue-use中都发生了什么？"><a href="#Vue-use中都发生了什么？" class="headerlink" title="Vue.use中都发生了什么？"></a>Vue.use中都发生了什么？</h2><blockquote><p>源码地址: <a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js</a> </p></blockquote><p><strong>定义</strong></p><p>vue.use()往全局注入一个插件，供全局真接使用, 不需要单独引用</p><p>代码理解:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// 入口文件全局注入vue-router, 从而可以在全局使用this.$route</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line">如果不使用vue.use那么需在组件中使用都得单独引入</span><br><span class="line"><span class="comment">// a.vue</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// b.vue</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></table></figure><p>理解了其基本使用及作用，我们来看一下vue.use中都发生了什么</p><p>源码很少，所以直接摘抄了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vue.use = <span class="function"><span class="keyword">function</span>(<span class="params">plugin: Function | Object</span>) </span>&#123; <span class="comment">// flow语法, 检测参数是否是函数或对象</span></span><br><span class="line">    <span class="comment">// 拿到已安装插件列表</span></span><br><span class="line">  <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = [])) </span><br><span class="line">    <span class="comment">// 如果已经安装，直接跳出方法</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">     </span><br><span class="line">  <span class="comment">// 取vue.use() 传入的参数</span></span><br><span class="line">  <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>) </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将vue对象填充到第一位, 最后的结构为[vue,arg1,arg2,...]</span></span><br><span class="line">    args.unshift(<span class="keyword">this</span>) </span><br><span class="line">    <span class="comment">// 判断插件是否有install方法，如果有执行install方法，如果没有直接把插件当install执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">    plugin.install.apply(plugin, args)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">    plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 注册完成填充至已安装列表，保证每个插件只安装一次</span></span><br><span class="line">  installedPlugins.push(plugin) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结合代码理解 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码摘抄自elementui入口文件</span></span><br><span class="line">实现上就是在install中执行了全局注册的操作</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  locale.use(opts.locale);</span><br><span class="line">  locale.i18n(opts.i18n);</span><br><span class="line">  components.forEach(component = &gt; &#123;</span><br><span class="line">    Vue.component(component.name, component)</span><br><span class="line">  &#125;);...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span></span><br><span class="line"><span class="keyword">default</span> &#123;</span><br><span class="line">  version: <span class="string">'2.5.4'</span>,</span><br><span class="line">  locale: locale.use,</span><br><span class="line">  i18n: locale.i18n,</span><br><span class="line">  install,</span><br><span class="line">  CollapseTransition,</span><br><span class="line">  Loading,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  main.js</span></span><br><span class="line"><span class="keyword">import</span> demo <span class="keyword">from</span> <span class="string">'./idnex'</span></span><br><span class="line">vue.use(demo)</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p> vue.use()为注册全局插件所用，接收函数或者一个包含install属性的对象为参数，如果参数带有install就执行install, 如果没有就直接将参数当install执行, 第一个参数始终为vue对象, 注册过的插件不会重新注册 </p><h2 id="简述一下Vue-js的template编译过程？"><a href="#简述一下Vue-js的template编译过程？" class="headerlink" title="简述一下Vue.js的template编译过程？"></a>简述一下Vue.js的template编译过程？</h2><p> 看一下整个流程 </p><p><a href="https://imgchr.com/i/r32sIK" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/17/r32sIK.jpg" alt="r32sIK.jpg"></a></p><p> 从上图中我们可以看到compile是从mount后开始进行中, 整体逻辑分为三个部分 </p><ul><li>解析器(parse) - 将 <code>模板字符串</code> 转换成 <code>elementASTs</code></li><li>优化器(optimize) - 对 <code>AST</code> 进行静态节点标记，主要用来做虚拟DOM的渲染优化</li><li>代码生成器(generate) - 使用 <code>elementASTs</code> 生成 <code>render</code> 函数代码字符串</li></ul><p><strong>开始前先解释一下AST</strong></p><p>AST(abstract syntax tree 抽象语法树), 是源代码的抽象语法结构的树状表现形式</p><p>从代码上简单理解一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt; div <span class="class"><span class="keyword">class</span> </span>= <span class="string">"name"</span> &gt; JS每日一题 &lt; <span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/转成AST后会得到如下格式</span></span><br><span class="line"><span class="regexp">[&#123;</span></span><br><span class="line"><span class="regexp">"type": "tag",</span></span><br><span class="line"><span class="regexp">"name": "div",</span></span><br><span class="line"><span class="regexp">"attribs": &#123;</span></span><br><span class="line"><span class="regexp">"class": "name"</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">"children": [&#123;</span></span><br><span class="line"><span class="regexp">"data": "JS每日一题",</span></span><br><span class="line"><span class="regexp">"type": "text",</span></span><br><span class="line"><span class="regexp">"next": null,</span></span><br><span class="line"><span class="regexp">"startIndex": 18,</span></span><br><span class="line"><span class="regexp">"prev": null,</span></span><br><span class="line"><span class="regexp">"parent": "[Circular ~.0]",</span></span><br><span class="line"><span class="regexp">"endIndex": 24</span></span><br><span class="line"><span class="regexp">&#125;],</span></span><br><span class="line"><span class="regexp">"next": null,</span></span><br><span class="line"><span class="regexp">"startIndex": 0,</span></span><br><span class="line"><span class="regexp">"prev": null,</span></span><br><span class="line"><span class="regexp">"parent": null,</span></span><br><span class="line"><span class="regexp">"endIndex": 30</span></span><br><span class="line"><span class="regexp">&#125;]</span></span><br></pre></td></tr></table></figure><p> AST会经过generate得到render函数，render的返回值是VNode</p><blockquote><p>VNode的源码可以见    <a href="https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/core/vdom/vnode.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/core/vdom/vnode.js</a> </p></blockquote><p><strong>解析器(parse)</strong></p><blockquote><p>源码地址 <a href="https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/parser/index.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/parser/index.js</a> </p></blockquote><p> parse 的目标是把 template 模板字符串转换成 AST 树，它是一种用 JavaScript 对象的形式来描述整个模板。那么整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的 </p><p><strong>优化器(optimize)</strong></p><blockquote><p> 源码地址 <a href="https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/optimizer.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/optimizer.js</a> </p></blockquote><p> 通过 optimize 把整个 AST 树中的每一个 AST 元素节点标记了 static 和 staticRoot, optimize 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变 </p><p><strong>代码生成器(generate)</strong></p><blockquote><p>源码地址  <a href="https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/codegen/index.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/compiler/codegen/index.js</a> </p></blockquote><p> 把优化后的 AST 树转换成可执行的代码 </p><p><strong>总结</strong></p><p> 首先通过parse将template解析成AST,其次optimize对解析出来的AST进行标记，最后generate将优化后的AST转换成可执行的代码 </p><h2 id="Vue中的nextTick如何理解，它是干什么的？"><a href="#Vue中的nextTick如何理解，它是干什么的？" class="headerlink" title="Vue中的nextTick如何理解，它是干什么的？"></a>Vue中的nextTick如何理解，它是干什么的？</h2><blockquote><p>在vue中，数据发生变化之后DOM并不会立即变化，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新 </p></blockquote><p> 代码理解 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.name = <span class="string">'JS每日一题'</span> <span class="comment">// 如这个绑定在某一个DOM元素上</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) </span><br><span class="line"><span class="comment">// 这时DOM还没有更新,所以不会得到文字JS每日一题</span></span><br><span class="line"><span class="keyword">this</span>.$nextTick(() = &gt;<span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent)) </span><br><span class="line"><span class="comment">// nextTick 是在DOM更新后执行，这里打印JS每日一题</span></span><br></pre></td></tr></table></figure><p><strong>nextTick什么情况下会触发</strong></p><p> 在同一事件循环中的数据变化后，DOM更新完成, 执行nextTick(callback)内的回调 </p><p> 对事件循环不理解的可以点<a href="https://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247483672&amp;idx=1&amp;sn=d7cf78506c258e6992f9637a107d35b9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">这里</a> </p><p><strong>vue中nextTick的实现</strong></p><blockquote><p>源码地址 <a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js</a> </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复制一份callbacks  </span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 清空callbacks</span></span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 顺序执行nexttick传入的回调</span></span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb ? :Function, ctx ? :Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve </span><br><span class="line">  <span class="comment">// 将回调压入callbacks</span></span><br><span class="line">  callbacks.push(() = &gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">// timerFunc的源码较多，大致意思就是根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数 (见上面的flushCallbacks方法)</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果nextTick不传cb,就为nextTick提供一个promise调用 如: nextTick().then(()=&gt; &#123;&#125;)</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve = &gt;&#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p> 数据的变化到 DOM 的重新渲染是一个异步过程, 我们必须在 nextTick 后执行DOM相关的操作 </p><p> 这道题考查大家对vue异步更新队列的理解，有一定深度，如果能够很好回答此题，对面试效果有极大帮助 </p><p>答题思路：</p><ol><li>nextTick是啥？下一个定义</li><li>为什么需要它呢？用异步更新队列实现原理解释</li><li>我再什么地方用它呢？抓抓头，想想你在平时开发中使用它的地方</li><li>下面介绍一下如何使用nextTick</li><li><p>最后能说出源码实现就会显得你格外优秀</p><p>先看看官方定义 </p></li></ol><blockquote><p>Vue.nextTick( [callback, context] )</p><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 修改数据</span></span><br><span class="line">&gt;vm.msg = <span class="string">'Hello'</span></span><br><span class="line">&gt;<span class="comment">// DOM 还没有更新</span></span><br><span class="line">&gt;Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// DOM 更新了</span></span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p> 回答范例： </p><ol><li>nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法</li><li>Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。</li><li>所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。</li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。</li><li>我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</li></ol><h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理?"></a>nextTick实现原理?</h2><p> 此题属于原理题目，能够体现面试者对vue理解深度，答好了会加分很多。 </p><p>答题思路：</p><ol><li>此题实际考查vue异步更新策略</li><li>说出vue是怎么通过异步、批量的方式更新以提高性能的</li><li>最后把源码中实现说一下</li></ol><p>回答范例：</p><ol><li><p>vue有个批量、异步更新策略，数据变化时，vue开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。然后在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p><blockquote><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html#异步更新队列" target="_blank" rel="noopener">官方文档在这里</a></p></blockquote></li><li><p>源码中，修改一个数据，组件对应的watcher会尝试入队:</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.push(watcher)</span><br></pre></td></tr></table></figure><p> 并使用nextTick方法添加一个flushSchedulerQueue回调 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextTick(flushSchedulerQueue)</span><br></pre></td></tr></table></figure><p> flushSchedulerQueue被加入callbacks数组 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb.call(ctx) <span class="comment">// cb就是加入的回调</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 然后以异步方式启动 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">  pending = <span class="literal">true</span></span><br><span class="line">  timerFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> timerFunc的异步主要利用Promise等微任务方式实现 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="comment">// timerFunc利用p.then向微任务队列添加一个flushCallbacks</span></span><br><span class="line">  <span class="comment">// 会异步调用flushCallbacks</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> flushCallbacks遍历callbacks，执行里面所有回调 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中就有前面加入的flushSchedulerQueue，它主要用于执行queue中所有watcher的run方法，从而使组件们更新 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">  watcher = queue[index]</span><br><span class="line">  watcher.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的追问</p><p> 你平时什么时候会用到nextTick？ </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3的新特性</title>
      <link href="//posts/86248f8a.html"/>
      <url>//posts/86248f8a.html</url>
      
        <content type="html"><![CDATA[<p><strong>六大亮点</strong></p><p><a href="https://vue3js.cn/docs/zh/api/" target="_blank" rel="noopener">vue3官方文档</a></p><p><a href="https://imgchr.com/i/rSCl4A" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSCl4A.jpg" alt="rSCl4A.jpg"></a></p><ul><li><p><code>Performance</code>：性能更比<code>Vue 2.0</code>强。</p></li><li><p><code>Tree shaking support</code>：可以将无用模块“剪辑”，仅打包需要的。</p></li><li><p><code>Composition API</code>：组合<code>API</code></p></li><li><p><code>Fragment, Teleport, Suspense</code>：“碎片”，<code>Teleport</code>即<code>Protal传送门</code>，“悬念”</p></li><li><p><code>Better TypeScript support</code>：更优秀的 Ts 支持</p></li><li><p><code>Custom Renderer API</code>：暴露了自定义渲染<code>API</code></p></li></ul><a id="more"></a><h2 id="1、Performance"><a href="#1、Performance" class="headerlink" title="1、Performance"></a>1、Performance</h2><p><a href="https://imgchr.com/i/rSCr3q" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSCr3q.jpg" alt="rSCr3q.jpg"></a></p><ul><li><p>重写了虚拟<code>Dom</code>的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。</p></li><li><p>编译模板的优化。</p></li><li><p>更高效的组件初始化。</p></li><li><p><code>update</code>性能提高 1.3~2 倍。</p></li><li><p><code>SSR</code>速度提高了 2~3 倍。</p></li></ul><p><a href="https://imgchr.com/i/rSPAaQ" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSPAaQ.jpg" alt="rSPAaQ.jpg"></a></p><h2 id="2、Tree-shaking-support"><a href="#2、Tree-shaking-support" class="headerlink" title="2、Tree shaking support"></a>2、Tree shaking support</h2><p><a href="https://imgchr.com/i/rSPdsK" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSPdsK.jpg" alt="rSPdsK.jpg"></a></p><ul><li>可以将无用模块“剪辑”，仅打包需要的（比如v-model,<transition>，用不到就不会打包）。</transition></li><li>一个简单“HelloWorld”大小仅为：13.5kb，11.75kb，仅Composition API。</li><li>包含运行时完整功能：22.5kb，拥有更多的功能，却比Vue 2更迷你。</li></ul><p>很多时候，我们并不需要 <code>vue</code>提供的所有功能，在 <code>vue 2</code> 并没有方式排除掉，但是 3.0 都可能做成了按需引入</p><h2 id="3、Composition-API"><a href="#3、Composition-API" class="headerlink" title="3、Composition API"></a>3、Composition API</h2><p><a href="https://imgchr.com/i/rSk5dO" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSk5dO.jpg" alt="rSk5dO.jpg"></a></p><p>与<code>React Hooks</code> 类似的东西，实现方式不同。</p><ul><li><p>可与现有的 <code>Options API</code>一起使用</p></li><li><p>灵活的逻辑组合与复用</p></li><li><p><code>vue 3</code>的响应式模块可以和其他框架搭配使用</p></li></ul><p>混入(<code>mixin</code>) 将不再作为推荐使用， <code>Composition API</code>可以实现更灵活且无副作用的复用代码。</p><p><a href="https://composition-api.vuejs.org/zh/" target="_blank" rel="noopener">Composition API 文档地址</a></p><p><code>Composition API</code>包含了六个主要<code>API</code></p><h2 id="4、Fragment"><a href="#4、Fragment" class="headerlink" title="4、Fragment"></a>4、Fragment</h2><p><a href="https://imgchr.com/i/rSAllR" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSAllR.jpg" alt="rSAllR.jpg"></a></p><p><code>Fragment</code>翻译为：“碎片”  </p><ul><li><p>不再限于模板中的单个根节点</p></li><li><p><code>render</code> 函数也可以返回数组了，类似实现了 <code>React.Fragments</code> 的功能 。</p></li><li><p><code>Just works</code></p></li></ul><p><code>&lt;Teleport&gt;</code></p><p><a href="https://imgchr.com/i/rSE83j" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSE83j.jpg" alt="rSE83j.jpg"></a></p><p><code>&lt;Suspense&gt;</code></p><p><a href="https://imgchr.com/i/rSEwUU" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSEwUU.jpg" alt="rSEwUU.jpg"></a></p><p><code>Suspense</code>翻译为：“悬念”</p><ul><li><p>可在嵌套层级中等待嵌套的异步依赖项</p></li><li><p>支持<code>async setup()</code></p></li><li><p>支持异步组件</p></li></ul><p>虽然<code>React 16</code>引入了<code>Suspense</code>，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。</p><p>Vue 3 的<code>&lt;Suspense&gt;</code>更加轻量：</p><p>仅 5%应用能感知运行时的调度差异，综合考虑下，Vue3 的<code>&lt;Suspense&gt;</code> 没和 React 一样做运行调度处理</p><h2 id="5、更好的TypeScript支持"><a href="#5、更好的TypeScript支持" class="headerlink" title="5、更好的TypeScript支持"></a>5、更好的<code>TypeScript</code>支持</h2><p><a href="https://imgchr.com/i/rSEbrt" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSEbrt.jpg" alt="rSEbrt.jpg"></a></p><ul><li><p><code>Vue 3</code>是用<code>TypeScript</code>编写的库，可以享受到自动的类型定义提示</p></li><li><p><code>JavaScript</code>和<code>TypeScript</code>中的 API 是相同的。事实上，代码也基本相同</p></li><li><p>支持<code>TSX</code></p></li><li><p><code>class</code>组件还会继续支持，但是需要引入<code>vue-class-component@next</code>，该模块目前还处在 alpha 阶段。</p></li></ul><p>还有<code>Vue 3 + TypeScript</code> 插件正在开发，有类型检查，自动补全等功能</p><h2 id="6、Custom-Renderer-API：自定义渲染器-API"><a href="#6、Custom-Renderer-API：自定义渲染器-API" class="headerlink" title="6、Custom Renderer API：自定义渲染器 API"></a>6、<code>Custom Renderer API</code>：自定义渲染器 API</h2><p><a href="https://imgchr.com/i/rSVkZV" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSVkZV.jpg" alt="rSVkZV.jpg"></a></p><ul><li><p>正在进行<code>NativeScript Vue</code>集成</p></li><li><p>用户可以尝试<code>WebGL</code>自定义渲染器，与普通 Vue 应用程序一起使用（<code>Vugel</code>）。</p></li></ul><p>意味着以后可以通过 <code>vue</code>， <code>Dom</code> 编程的方式来进行 <code>webgl</code> 编程 。</p><p>感兴趣可以看这里：<a href="https://vugel.planning.nl/#application" target="_blank" rel="noopener">Getting started vugel</a></p><p><strong>剩余工作</strong></p><p>全家桶插件组件过渡到vue3.+</p><p><strong>要点</strong></p><p>新工具：<code>vite</code>（法语 “快”）</p><p>地址：<a href="https://github.com/vuejs/vite" target="_blank" rel="noopener">https://github.com/vuejs/vite</a></p><p>一个简易的<code>http</code>服务器，无需<code>webpack</code>编译打包，根据请求的<code>Vue</code>文件，直接发回渲染，且支持热更新（非常快）</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写简易版vue，minivue的实现</title>
      <link href="//posts/d3643a0f.html"/>
      <url>//posts/d3643a0f.html</url>
      
        <content type="html"><![CDATA[<p>基于vue2.*</p><p><code>vue采取数据劫持，配合观察者模式，通过Object.defineProperty() 来劫持各个属性的setter和getter，在数据变动时，发布消息给依赖收集器dep，去通知观察者，做出对应的回调函数，去更新视图。（也就是在getter中收集依赖，在setter中通知依赖更新。</code></p><blockquote><p>其实vue主要就是整合Observer，compile和watcher三者，通过Observer来监听 model数据变化表，通过compile来解析编译模板指令，最终利用Watcher搭起observer 和compile的通信桥梁，达到数据变化=&gt;视图变化，视图变化=&gt;数据变化的双向绑定效果。</p></blockquote><p> 下面来一张图↓ </p><p><a href="https://imgchr.com/i/rSsjT1" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSsjT1.png" alt="rSsjT1.png"></a></p><p> 这个流程图已经非常形象深刻的表达了vue的运行模式，当你理解了这个流程，再去看vue源码时就会容易很多了 </p><p> 声明一下，下面的代码只简单实现了vue里的 </p><ol><li>v-model（数据的双向绑定）</li><li>v-bind/v-on</li><li>v-text/v-html</li><li>没有实现虚拟dom，采用文档碎片（createDocumentFragment）代替</li><li><p>数据只劫持了Object，数组Array没有做处理</p><p>代码大致结构如下，初步定义了6个类 </p></li></ol><p><a href="https://imgchr.com/i/rSyiOH" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSyiOH.png" alt="rSyiOH.png"></a></p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Vue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="comment">// 把数据对象挂载到实例上</span></span><br><span class="line">        <span class="keyword">this</span>.$el = options.el;</span><br><span class="line">        <span class="keyword">this</span>.$<span class="keyword">data</span> = options.<span class="keyword">data</span>;</span><br><span class="line">        <span class="keyword">this</span>.$options = options;</span><br><span class="line">        <span class="comment">// 如果有需要编译的模板</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">            <span class="comment">// 数据劫持 就是把对象的所有属性 改成get和set方法</span></span><br><span class="line">            new Observer(<span class="keyword">this</span>.$<span class="keyword">data</span>);</span><br><span class="line">            <span class="comment">// 用数据和元素进行编译</span></span><br><span class="line">            new Compiler(<span class="keyword">this</span>.$el, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 3. 通过数据代理实现 主要给methods里的方法this直接访问data</span></span><br><span class="line">            <span class="keyword">this</span>.proxyData(<span class="keyword">this</span>.$<span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用vm代理vm.$data</span></span><br><span class="line">    proxyData(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(let key <span class="keyword">in</span> <span class="keyword">data</span>)&#123;</span><br><span class="line">            Object.defineProperty(<span class="keyword">this</span>,key,&#123;</span><br><span class="line">                <span class="keyword">get</span>()&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">data</span>[key];</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">                    <span class="keyword">data</span>[key] = newVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 编译html模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vm就是vue对象</span></span><br><span class="line">    <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">        <span class="keyword">this</span>.el = <span class="keyword">this</span>.isElementNode(el) ? el : document.querySelector(el);</span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.el)&#123; <span class="comment">// 如果该元素能获取到，我们开始编译</span></span><br><span class="line">            <span class="comment">// 1.把真实的dom放到内存中fragment文档碎片</span></span><br><span class="line">            let fragment = <span class="keyword">this</span>.node2fragment(<span class="keyword">this</span>.el);</span><br><span class="line">            <span class="comment">// console.log(fragment);</span></span><br><span class="line">            <span class="comment">// 2.编译 =&gt; 提取想要的元素节点 v-model和文本节点&#123;&#123;&#125;&#125;</span></span><br><span class="line">            <span class="keyword">this</span>.compile(fragment);</span><br><span class="line">            <span class="comment">// 3.把编译好的fragment再放到页面里</span></span><br><span class="line">            <span class="keyword">this</span>.el.appendChild(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 一些辅助方法 */</span></span><br><span class="line">    isElementNode(node) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isDirective(name) &#123; <span class="comment">// 判断是不是指令</span></span><br><span class="line">        <span class="keyword">return</span> name.includes(<span class="string">'v-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isEventName(attrName)&#123; <span class="comment">// 判断是否@开头</span></span><br><span class="line">        <span class="keyword">return</span> attrName.startsWith(<span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isBindName(attrName)&#123; <span class="comment">// 判断是否:开头</span></span><br><span class="line">        <span class="keyword">return</span> attrName.startsWith(<span class="string">':'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 核心方法区 */</span></span><br><span class="line">    node2fragment(el)&#123; <span class="comment">// 需要将el中的内容全部放到内存中</span></span><br><span class="line">        <span class="comment">// 文档碎片</span></span><br><span class="line">        let fragment = document.createDocumentFragment();</span><br><span class="line">        let firstChild;</span><br><span class="line">        <span class="keyword">while</span>(firstChild = el.firstChild)&#123;</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment; <span class="comment">// 内存中的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    compile(fragment)&#123;</span><br><span class="line">        <span class="comment">// 1.获取子节点</span></span><br><span class="line">        let childNodes = fragment.childNodes;</span><br><span class="line">        <span class="comment">// 2.递归循环编译</span></span><br><span class="line">        [...childNodes].forEach(node=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isElementNode(node))&#123;</span><br><span class="line">                <span class="keyword">this</span>.compileElement(node); <span class="comment">// 这里需要编译元素</span></span><br><span class="line">                <span class="keyword">this</span>.compile(node); <span class="comment">// 是元素节点，还需要继续深入的检查</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 文本节点</span></span><br><span class="line">                <span class="comment">// 这里需要编译文本</span></span><br><span class="line">                <span class="keyword">this</span>.compileText(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    compileElement(node)&#123; <span class="comment">// 编译元素</span></span><br><span class="line">        <span class="comment">// 带v-model v-html ...</span></span><br><span class="line">        let attrs = node.attributes; <span class="comment">// 取出当前节点的属性</span></span><br><span class="line">        <span class="comment">// attrs是类数组，因此需要先转数组</span></span><br><span class="line">        [...attrs].forEach(attr=&gt;&#123;</span><br><span class="line">            <span class="comment">// console.log(attr); // type="text" v-model="content" v-on:click="handleclick" @click=""...</span></span><br><span class="line">            let attrName = attr.name; <span class="comment">// type v-model v-on:click @click</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isDirective(attrName))&#123; <span class="comment">// 判断属性名字是不是包含v-</span></span><br><span class="line">                <span class="comment">// 取到对应的值放到节点中</span></span><br><span class="line">                let expr = attr.value; <span class="comment">// content/变量 handleclick/方法名</span></span><br><span class="line">                <span class="comment">// console.log(expr)</span></span><br><span class="line">                let [, type] = attrName.split(<span class="string">'-'</span>); <span class="comment">// model html on:click</span></span><br><span class="line">                let [compileKey, detailStr] = type.split(<span class="string">':'</span>); <span class="comment">// 处理 on: bind:</span></span><br><span class="line">                <span class="comment">// node this.vm.$data expr</span></span><br><span class="line">                CompileUtil[compileKey](node, <span class="keyword">this</span>.vm, expr, detailStr);</span><br><span class="line">                <span class="comment">// 删除有指令的标签属性 v-text v-html等，普通的value等原生html标签不必删除</span></span><br><span class="line">                node.removeAttribute(<span class="string">'v-'</span> + type);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.isEventName(attrName))&#123; <span class="comment">// 如果是事件处理 @click='handleClick'</span></span><br><span class="line">                let [, detailStr] = attrName.split(<span class="string">'@'</span>);</span><br><span class="line">                CompileUtil[<span class="string">'on'</span>](node, <span class="keyword">this</span>.vm, attr.value, detailStr);</span><br><span class="line">                <span class="comment">// 删除有指令的标签属性</span></span><br><span class="line">                node.removeAttribute(<span class="string">'@'</span> + detailStr);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.isBindName(attrName))&#123; <span class="comment">// 如果是:开头，动态绑定值</span></span><br><span class="line">                let [, detailStr] = attrName.split(<span class="string">':'</span>);</span><br><span class="line">                CompileUtil[<span class="string">'bind'</span>](node, <span class="keyword">this</span>.vm, attr.value, detailStr);</span><br><span class="line">                <span class="comment">// 删除有指令的标签属性</span></span><br><span class="line">                node.removeAttribute(<span class="string">':'</span> + detailStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileText(node)&#123; <span class="comment">// 编译文本</span></span><br><span class="line">        <span class="comment">// 带&#123;&#123;&#125;&#125;</span></span><br><span class="line">        let expr = node.textContent; <span class="comment">// 取文本中的内容</span></span><br><span class="line">        let reg = /\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g; <span class="comment">// &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(reg.test(expr))&#123;</span><br><span class="line">            <span class="comment">// node this.$data</span></span><br><span class="line">            <span class="comment">// console.log(expr); // &#123;&#123;content&#125;&#125;</span></span><br><span class="line">            CompileUtil[<span class="string">'text'</span>](node, <span class="keyword">this</span>.vm, expr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 编译模版具体执行</span></span><br><span class="line"><span class="keyword">const</span> CompileUtil = &#123;</span><br><span class="line">    getVal(vm, expr)&#123; <span class="comment">// 获取实例上对应的数据</span></span><br><span class="line">        expr = expr.split(<span class="string">'.'</span>); <span class="comment">// [animal,dog]/[animal,cat]</span></span><br><span class="line">        <span class="keyword">return</span> expr.reduce((prev, next)=&gt;&#123; <span class="comment">// vm.$data.</span></span><br><span class="line">            <span class="keyword">return</span> prev[next];</span><br><span class="line">        &#125;, vm.$<span class="keyword">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这里实现input输入值变化时 修改绑定的v-model对应的值</span></span><br><span class="line">    setVal(vm, expr, inputValue)&#123; <span class="comment">// [animal,dog]</span></span><br><span class="line">        let exprs = expr.split(<span class="string">'.'</span>), len = exprs.length;</span><br><span class="line">        exprs.reduce((<span class="keyword">data</span>,currentVal, idx)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(idx===len-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">data</span>[currentVal] = inputValue;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">data</span>[currentVal]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, vm.$<span class="keyword">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    getTextVal(vm, expr)&#123; <span class="comment">// 获取编译文本后的结果</span></span><br><span class="line">        <span class="keyword">return</span> expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, (...args)=&gt;&#123;</span><br><span class="line">            <span class="comment">// console.log(args); // ["&#123;&#123;title&#125;&#125;", "title", 0, "&#123;&#123;title&#125;&#125;"]</span></span><br><span class="line">            <span class="comment">// ["&#123;&#123; animal.dog &#125;&#125;", " animal.dog ", 0, "&#123;&#123; animal.dog &#125;&#125;-vs-&#123;&#123; animal.cat &#125;&#125;"]</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getVal(vm, args[<span class="number">1</span>].trim());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    text(node, vm, expr)&#123; <span class="comment">// 文本处理</span></span><br><span class="line">        let updateFn = <span class="keyword">this</span>.updater[<span class="string">'textUpdater'</span>];</span><br><span class="line">        <span class="comment">// &#123;&#123;content&#125;&#125; =&gt; "welcome to animal world"</span></span><br><span class="line">        let value;</span><br><span class="line">        <span class="keyword">if</span>(expr.indexOf(<span class="string">'&#123;&#123;'</span>)!==-<span class="number">1</span>)&#123; <span class="comment">// dom里直接写&#123;&#123;&#125;&#125;的时候</span></span><br><span class="line">            value = <span class="keyword">this</span>.getTextVal(vm, expr);</span><br><span class="line">            <span class="comment">// &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; 对多个值进行监控</span></span><br><span class="line">            expr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g, (...args)=&gt;&#123;</span><br><span class="line">                new Watcher(vm, args[<span class="number">1</span>].trim(), ()=&gt;&#123;</span><br><span class="line">                    <span class="comment">// 如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容</span></span><br><span class="line">                    updateFn &amp;&amp; updateFn(node, <span class="keyword">this</span>.getTextVal(vm, expr));</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// v-text 的时候</span></span><br><span class="line">            value = <span class="keyword">this</span>.getVal(vm, expr);</span><br><span class="line">            new Watcher(vm, expr, (newVal)=&gt;&#123;</span><br><span class="line">                <span class="comment">// 当值变化后会调用cb 将新值传递过来</span></span><br><span class="line">                updateFn &amp;&amp; updateFn(node, newVal);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        updateFn &amp;&amp; updateFn(node, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    html(node, vm, expr) &#123; <span class="comment">//</span></span><br><span class="line">        let updateFn = <span class="keyword">this</span>.updater[<span class="string">'htmlUpdater'</span>];</span><br><span class="line">        updateFn &amp;&amp; updateFn(node, <span class="keyword">this</span>.getVal(vm, expr));</span><br><span class="line">    &#125;,</span><br><span class="line">    model(node, vm, expr)&#123; <span class="comment">// 输入框处理</span></span><br><span class="line">        let updateFn = <span class="keyword">this</span>.updater[<span class="string">'modelUpdater'</span>];</span><br><span class="line">        <span class="comment">// console.log(this.getVal(vm, expr)); // "welcome to animal world"</span></span><br><span class="line">        <span class="comment">// 这里应该加一个监控 数据变化了  应该调用这个watch的callback</span></span><br><span class="line">        new Watcher(vm, expr, (newVal)=&gt;&#123;</span><br><span class="line">            <span class="comment">// 当值变化后会调用cb 将新值传递过来</span></span><br><span class="line">            updateFn &amp;&amp; updateFn(node, newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 视图 =&gt; 数据 =&gt; 视图</span></span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, (e)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.setVal(vm, expr, e.target.value);</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn &amp;&amp; updateFn(node, <span class="keyword">this</span>.getVal(vm, expr));</span><br><span class="line">    &#125;,</span><br><span class="line">    on(node, vm, expr, detailStr) &#123;</span><br><span class="line">        let fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr];</span><br><span class="line">        node.addEventListener(detailStr, fn.bind(vm), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    bind(node, vm, expr, detailStr)&#123;</span><br><span class="line">        <span class="comment">// v-bind:src='...' =&gt; href='...'</span></span><br><span class="line">        node.setAttribute(detailStr, expr);</span><br><span class="line">    &#125;,</span><br><span class="line">    updater:&#123;</span><br><span class="line">        <span class="comment">// 文本更新</span></span><br><span class="line">        textUpdater(node, value)&#123;</span><br><span class="line">            node.textContent = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// html更新</span></span><br><span class="line">        htmlUpdater(node, value)&#123;</span><br><span class="line">            node.innerHTML = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 输入框更新</span></span><br><span class="line">        modelUpdater(node, value)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.observe(<span class="keyword">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    observe(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 要对data数据原有属性改成set和get的形式</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">data</span> || typeof <span class="keyword">data</span> !== <span class="string">'object'</span>)&#123; <span class="comment">// 不是对象就不劫持了</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要劫持 先获取到data的key和value</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(<span class="keyword">data</span>, key, <span class="keyword">data</span>[key]); <span class="comment">// 劫持</span></span><br><span class="line">            <span class="keyword">this</span>.observe(<span class="keyword">data</span>[key]); <span class="comment">// 深度递归劫持</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义响应式</span></span><br><span class="line">    defineReactive(obj, key, value)&#123;</span><br><span class="line">        let dep = new Dep();</span><br><span class="line">        <span class="comment">// 在获取某个值的时候</span></span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">            configurable: <span class="literal">true</span>, <span class="comment">// 可修改</span></span><br><span class="line">            <span class="keyword">get</span>()&#123; <span class="comment">// 当取值的时候</span></span><br><span class="line">                <span class="comment">// 订阅数据变化时，往Dev中添加观察者</span></span><br><span class="line">                Dep.target &amp;&amp; dep.addSub(Dep.target);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 采用箭头函数在定义时绑定this的定义域</span></span><br><span class="line">            <span class="keyword">set</span>: (newVal)=&gt;&#123; <span class="comment">// 更改data里的属性值的时候</span></span><br><span class="line">                <span class="keyword">if</span>(value === newVal) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">this</span>.observe(newVal); <span class="comment">// 如果设置新值是对象，劫持</span></span><br><span class="line">                value = newVal;</span><br><span class="line">                <span class="comment">// 通知watcher数据发生改变</span></span><br><span class="line">                dep.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expr, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="keyword">this</span>.expr = expr;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">        <span class="comment">// 先获取一下老的值</span></span><br><span class="line">        <span class="keyword">this</span>.oldVal = <span class="keyword">this</span>.getOldVal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取实例上对应的老值</span></span><br><span class="line">    getOldVal()&#123;</span><br><span class="line">        <span class="comment">// 在利用getValue获取数据调用getter()方法时先把当前观察者挂载</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> oldVal = CompileUtil.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.expr);</span><br><span class="line">        <span class="comment">// 挂载完毕需要注销，防止重复挂载 (数据一更新就会挂载)</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露的方法 通过回调函数更新数据</span></span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="keyword">const</span> newVal = CompileUtil.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.expr);</span><br><span class="line">        <span class="keyword">if</span>(newVal !== <span class="keyword">this</span>.oldVal)&#123;</span><br><span class="line">            <span class="keyword">this</span>.cb(newVal); <span class="comment">// 对应watch的callback</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Dep类存储watcher对象，并在数据变化时通知watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(arg) &#123;</span><br><span class="line">        <span class="comment">// 订阅的数组</span></span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(watcher)&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123; <span class="comment">// 数据变化时通知watcher更新</span></span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(w=&gt;w.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/bobo1/category/1452477.html" target="_blank" rel="noopener">vue源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用JavaScript实现纯前端读取和导出excel文件</title>
      <link href="//posts/ce0a6a78.html"/>
      <url>//posts/ce0a6a78.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、js-xlsx-介绍"><a href="#1、js-xlsx-介绍" class="headerlink" title="1、js-xlsx 介绍"></a>1、js-xlsx 介绍</h1><p><code>由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。</code></p><ul><li>官方github：<a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">https://github.com/SheetJS/js-xlsx</a></li><li>本文配套demo在线演示地址：<a href="http://demo.haoji.me/2017/02/08-js-xlsx/" target="_blank" rel="noopener">http://demo.haoji.me/2017/02/08-js-xlsx/</a></li></ul><a id="more"></a><h2 id="1-1-兼容性"><a href="#1-1-兼容性" class="headerlink" title="1.1 兼容性"></a>1.1 兼容性</h2><p><a href="https://imgchr.com/i/rS2F8P" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rS2F8P.png" alt="rS2F8P.png"></a></p><h2 id="1-2-如何使用"><a href="#1-2-如何使用" class="headerlink" title="1.2. 如何使用"></a>1.2. 如何使用</h2><p><code>dist</code>目录下有很多个JS文件，一般情况下用<code>xlsx.core.min.js</code>就够了，<code>xlsx.full.min.js</code>则是包含了所有功能模块。</p><p><a href="https://imgchr.com/i/rS2K5n" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rS2K5n.png" alt="rS2K5n.png"></a></p><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./js/xlsx.core.min.js&quot;&gt;&lt;/script&gt;</code></p><h1 id="2、读取excel"><a href="#2、读取excel" class="headerlink" title="2、读取excel"></a>2、读取excel</h1><p>读取excel主要是通过<code>XLSX.read(data, {type: type});</code>方法来实现，返回一个叫WorkBook的对象，type主要取值如下：</p><ul><li>base64: 以base64方式读取；</li><li>binary: BinaryString格式(byte n is data.charCodeAt(n))</li><li>string: UTF8编码的字符串；</li><li>buffer: nodejs Buffer；</li><li>array: Uint8Array，8位无符号数组；</li><li>file: 文件的路径（仅nodejs下支持）；</li></ul><h2 id="2-1-获取workbook对象"><a href="#2-1-获取workbook对象" class="headerlink" title="2.1 获取workbook对象"></a>2.1 获取workbook对象</h2><p><strong>读取本地文件</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取本地excel文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readWorkbookFromLocalFile</span><span class="params">(file, callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = e.target.result;</span><br><span class="line">    <span class="keyword">var</span> workbook = XLSX.read(data, &#123;type: <span class="string">'binary'</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(callback) callback(workbook);</span><br><span class="line">  &#125;;</span><br><span class="line">  reader.readAsBinaryString(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取网络文件</strong></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从网络上读取某个excel文件，url必须同域，否则报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readWorkbookFromRemoteFile</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'get'</span>, <span class="built_in">url</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.responseType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(xhr.response)</span><br><span class="line">      <span class="keyword">var</span> workbook = XLSX.read(data, &#123;<span class="attribute">type</span>: <span class="string">'array'</span>&#125;);</span><br><span class="line">      <span class="keyword">if</span>(callback) callback(workbook);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取workbook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 excel文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputWorkbook</span>(<span class="params">workbook</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sheetNames = workbook.SheetNames; <span class="comment">// 工作表名称集合</span></span><br><span class="line">  sheetNames.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> worksheet = workbook.Sheets[name]; <span class="comment">// 只能通过工作表名称来获取指定工作表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> worksheet) &#123;</span><br><span class="line">      <span class="comment">// v是读取单元格的原始值</span></span><br><span class="line">      <span class="built_in">console</span>.log(key, key[<span class="number">0</span>] === <span class="string">'!'</span> ? worksheet[key] : worksheet[key].v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据!ref确定excel的范围，再根据!merges确定单元格合并（如果有），最后输出整个table，比较麻烦，幸运的是，插件自身已经写好工具类XLSX.utils给我们直接使用，无需我们自己遍历，工具类输出主要包括如下：</p><p><a href="https://imgchr.com/i/rSRFo9" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/12/08/rSRFo9.png" alt="rSRFo9.png"></a></p><p>有些不常用，常用的主要是：</p><ul><li>XLSX.utils.sheet_to_csv：生成CSV格式</li><li>XLSX.utils.sheet_to_txt：生成纯文本格式</li><li>XLSX.utils.sheet_to_html：生成HTML格式</li><li>XLSX.utils.sheet_to_json：输出JSON格式</li></ul><p>常用的主要是sheet_to_csv或者sheet_to_html，转csv的话会忽略格式、单元格合并等信息，所以复杂表格可能不适用。转html的话会保留单元格合并，但是生成的是<html></html>代码，而不是<table></table>，需要对表格进行一些定制时不太方便，所以具体还是要视情况来采用合适的工具类。</p><p>这里写一个采用转csv方式输出结果的简单示例，可点击这里查看<a href="http://demo.haoji.me/2017/02/08-js-xlsx/" target="_blank" rel="noopener">在线DEMO</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> csv = XLSX.utils.sheet_to_csv(worksheet);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).innerHTML = csv2table(csv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将csv转换成简单的表格，会忽略单元格合并，在第一行和第一列追加类似excel的索引</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csv2table</span>(<span class="params">csv</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> html = <span class="string">'&lt;table&gt;'</span>;</span><br><span class="line">  <span class="keyword">var</span> rows = csv.split(<span class="string">'\n'</span>);</span><br><span class="line">  rows.pop(); <span class="comment">// 最后一行没用的</span></span><br><span class="line">  rows.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">row, idx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> columns = row.split(<span class="string">','</span>);</span><br><span class="line">    columns.unshift(idx+<span class="number">1</span>); <span class="comment">// 添加行索引</span></span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">0</span>) &#123; <span class="comment">// 添加列索引</span></span><br><span class="line">      html += <span class="string">'&lt;tr&gt;'</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;columns.length; i++) &#123;</span><br><span class="line">        html += <span class="string">'&lt;th&gt;'</span> + (i==<span class="number">0</span>?<span class="string">''</span>:<span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+i<span class="number">-1</span>)) + <span class="string">'&lt;/th&gt;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      html += <span class="string">'&lt;/tr&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    html += <span class="string">'&lt;tr&gt;'</span>;</span><br><span class="line">    columns.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">column</span>) </span>&#123;</span><br><span class="line">      html += <span class="string">'&lt;td&gt;'</span>+column+<span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    html += <span class="string">'&lt;/tr&gt;'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  html += <span class="string">'&lt;/table&gt;'</span>;</span><br><span class="line">  <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="导出excel"><a href="#导出excel" class="headerlink" title="导出excel"></a>导出excel</h1><p>导出分为2种，一种是基于现有excel修改，一种是全新生成，前者比较简单，我们这里着重讲后者。</p><p><strong>自己手写代码生成</strong></p><p>导出excel文件，主要是如何生成一个sheet，我们这里写一个最简单的csv转excel示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csv转sheet对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csv2sheet</span>(<span class="params">csv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sheet = &#123;&#125;; <span class="comment">// 将要生成的sheet</span></span><br><span class="line">  csv = csv.split(<span class="string">'\n'</span>);</span><br><span class="line">  csv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">row, i</span>) </span>&#123;</span><br><span class="line">    row = row.split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) sheet[<span class="string">'!ref'</span>] = <span class="string">'A1:'</span>+<span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+row.length<span class="number">-1</span>)+(csv.length<span class="number">-1</span>);</span><br><span class="line">    row.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">col, j</span>) </span>&#123;</span><br><span class="line">      sheet[<span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+j)+(i+<span class="number">1</span>)] = &#123;<span class="attr">v</span>: col&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> sheet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sheet2blob</span>(<span class="params">sheet, sheetName</span>) </span>&#123;</span><br><span class="line">  sheetName = sheetName || <span class="string">'sheet1'</span>;</span><br><span class="line">  <span class="keyword">var</span> workbook = &#123;</span><br><span class="line">    SheetNames: [sheetName],</span><br><span class="line">    Sheets: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  workbook.Sheets[sheetName] = sheet;</span><br><span class="line">  <span class="comment">// 生成excel的配置项</span></span><br><span class="line">  <span class="keyword">var</span> wopts = &#123;</span><br><span class="line">    bookType: <span class="string">'xlsx'</span>, <span class="comment">// 要生成的文件类型</span></span><br><span class="line">    bookSST: <span class="literal">false</span>, <span class="comment">// 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性</span></span><br><span class="line">    type: <span class="string">'binary'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> wbout = XLSX.write(workbook, wopts);</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([s2ab(wbout)], &#123;<span class="attr">type</span>:<span class="string">"application/octet-stream"</span>&#125;);</span><br><span class="line">  <span class="comment">// 字符串转ArrayBuffer</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">s2ab</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(s.length);</span><br><span class="line">    <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> blob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到上面的blob对象就可以直接下载了，参考我之前在<a href="http://blog.haoji.me/js-download.html#JS-dan-chu-xia-zai-dui-hua-kuang" target="_blank" rel="noopener">JS弹出下载对话框</a>里面封装好的openDownloadDialog方法：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的打开下载对话框方法，没有测试过具体兼容性</span></span><br><span class="line"><span class="comment"> * @param url 下载地址，也可以是一个blob对象，必选</span></span><br><span class="line"><span class="comment"> * @param saveName 保存文件名，可选</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openDownloadDialog</span>(<span class="params">url, saveName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">url</span> == <span class="string">'object'</span> &amp;&amp; <span class="built_in">url</span> <span class="keyword">instanceof</span> Blob)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">url</span> = URL.createObjectURL(<span class="built_in">url</span>); <span class="comment">// 创建blob地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> aLink = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  aLink.href = <span class="built_in">url</span>;</span><br><span class="line">  aLink.download = saveName || <span class="string">''</span>; <span class="comment">// HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效</span></span><br><span class="line">  <span class="keyword">var</span> event;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.MouseEvent) event = <span class="keyword">new</span> MouseEvent(<span class="string">'click'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">    event.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  aLink.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，最终下载实现如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入csv，执行后就会弹出下载框</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exportExcel</span><span class="params">(csv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sheet = csv2sheet(csv);</span><br><span class="line">  <span class="keyword">var</span> blob = sheet2blob(sheet);</span><br><span class="line">  openDownloadDialog(blob, <span class="string">'导出.xlsx'</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理单元格合并</strong></p><p>一般来说，前端生成excel而不是csv最主要目的都是为了解决csv不能实现单元格合并的问题，要不然直接导出csv文件就好了，何必引入几百kb的插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var aoa = [</span><br><span class="line">  [<span class="string">'主要信息'</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">'其它信息'</span>], <span class="comment">// 特别注意合并的地方后面预留2个null</span></span><br><span class="line">  [<span class="string">'姓名'</span>, <span class="string">'性别'</span>, <span class="string">'年龄'</span>, <span class="string">'注册时间'</span>],</span><br><span class="line">  [<span class="string">'张三'</span>, <span class="string">'男'</span>, <span class="number">18</span>, <span class="keyword">new</span> Date()],</span><br><span class="line">  [<span class="string">'李四'</span>, <span class="string">'女'</span>, <span class="number">22</span>, <span class="keyword">new</span> Date()]</span><br><span class="line">];</span><br><span class="line">var sheet = XLSX.utils.aoa_to_sheet(aoa);</span><br><span class="line">sheet[<span class="string">'!merges'</span>] = [</span><br><span class="line">  <span class="comment">// 设置A1-C1的单元格合并</span></span><br><span class="line">    &#123;<span class="string">s:</span> &#123;<span class="string">r:</span> <span class="number">0</span>, <span class="string">c:</span> <span class="number">0</span>&#125;, <span class="string">e:</span> &#123;<span class="string">r:</span> <span class="number">0</span>, <span class="string">c:</span> <span class="number">2</span>&#125;&#125;</span><br><span class="line">];</span><br><span class="line">openDownloadDialog(sheet2blob(sheet), <span class="string">'单元格合并示例.xlsx'</span>);</span><br></pre></td></tr></table></figure><p>需要注意的地方就是被合并的单元格要用null预留出位置，否则后面的内容（本例中是第四列其它信息）会被覆盖。</p><p>| 原文地址：<a href="https://www.cnblogs.com/liuxianan/p/js-excel.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/js-excel.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> excel </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue响应式原理源码剖析</title>
      <link href="//posts/b0d42301.html"/>
      <url>//posts/b0d42301.html</url>
      
        <content type="html"><![CDATA[<p>vue2更新到vue3对数据的响应式，做了重大的调整。</p><h2 id="先回顾下vue2的响应式怎么做的"><a href="#先回顾下vue2的响应式怎么做的" class="headerlink" title="先回顾下vue2的响应式怎么做的"></a>先回顾下vue2的响应式怎么做的</h2><p>vue2对象响应式原理：Object.defineProperty()</p><p>vue2数组响应式原理：覆盖可以修改数组7个方法，从数组原型中获取这7个方法，并覆盖为可以发送更新通知的函数实现</p><a id="more"></a><h3 id="对象的属性劫持"><a href="#对象的属性劫持" class="headerlink" title="对象的属性劫持"></a>对象的属性劫持</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体定义指定的key拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归遍历</span></span><br><span class="line">  observe(val)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// val实际上是一个闭包</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="comment">// val可能是对象</span></span><br><span class="line">        observe(newVal)</span><br><span class="line">        notifyUpdate()</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组属性的劫持"><a href="#数组属性的劫持" class="headerlink" title="数组属性的劫持"></a>数组属性的劫持</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数组的7个api的原型</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Object</span>.create(originalProto)</span><br><span class="line">;[<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'reverse'</span>, <span class="string">'sort'</span>].forEach(</span><br><span class="line">  method =&gt; &#123;</span><br><span class="line">    arrayProto[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 做之前的事情</span></span><br><span class="line">      originalProto[method].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通知更新</span></span><br><span class="line">      notifyUpdate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据响应"><a href="#数据响应" class="headerlink" title="数据响应"></a>数据响应</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想：递归遍历传入obj，定义每个属性的拦截</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断类型：如果是数组则替换它的原型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(obj, arrayProto)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; keys.length; index++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[index]</span><br><span class="line">      <span class="comment">// 对obj每个key执行拦截</span></span><br><span class="line">      defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跟新处理"><a href="#跟新处理" class="headerlink" title="跟新处理"></a>跟新处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notifyUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'页面更新！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="attr">tua</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 1.普通更新</span></span><br><span class="line"><span class="comment">// data.foo = 'foooooooo'</span></span><br><span class="line"><span class="comment">// 2.嵌套属性更新</span></span><br><span class="line"><span class="comment">// data.bar.a = 10</span></span><br><span class="line"><span class="comment">// data.dong = 'lalala' // no ok</span></span><br><span class="line"><span class="comment">// 3.赋值是对象</span></span><br><span class="line"><span class="comment">// data.bar = &#123;a:10&#125;</span></span><br><span class="line"><span class="comment">// 4.数组</span></span><br><span class="line"><span class="comment">// data.tua.push(4)</span></span><br></pre></td></tr></table></figure><h3 id="以上方式会出现什么问题呢？"><a href="#以上方式会出现什么问题呢？" class="headerlink" title="以上方式会出现什么问题呢？"></a>以上方式会出现什么问题呢？</h3><ol><li>需要响应化的数据较大，递归遍历性能不好、消耗较大</li><li>新增或删除属性无法监听</li><li>数组响应化需要额外实现</li><li>修改语法有限制</li></ol><p><strong>所以在vue3跟新做了更加优化方案</strong></p><h2 id="vue3的响应式原理的实现"><a href="#vue3的响应式原理的实现" class="headerlink" title="vue3的响应式原理的实现"></a>vue3的响应式原理的实现</h2><p><strong>vue3响应式原理：利用<a href="https://es6.ruanyifeng.com/?search=Proxy&amp;x=0&amp;y=0#docs/proxy" target="_blank" rel="noopener">Proxy</a>对象对数据拦截</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 弱引用的方式缓存代理数据和原始数据</span></span><br><span class="line"><span class="keyword">const</span> toProxy = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// 形如 obj: observed</span></span><br><span class="line"><span class="keyword">const</span> toRaw = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// 形如 observed: obj</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> || obj === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.hasOwnProperty(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 响应对象数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找缓存</span></span><br><span class="line">  <span class="keyword">if</span> (toProxy.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> toProxy.get(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 传入obj就是代理对象,此时不用反复代理</span></span><br><span class="line">  <span class="keyword">if</span> (toRaw.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">      <span class="comment">// 访问</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      track(target, key)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isObject(res) ? reactive(res) : res</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      <span class="comment">// 新增和更新</span></span><br><span class="line">      <span class="keyword">const</span> hadKey = hasOwn(target, key) <span class="comment">// ADD 或 SET</span></span><br><span class="line">      <span class="keyword">const</span> oldVal = target[key]</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`新增<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        trigger(target, <span class="string">'ADD'</span>, key)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVal !== value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        trigger(target, <span class="string">'SET'</span>, key)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, key) &#123;</span><br><span class="line">      <span class="comment">// 删除</span></span><br><span class="line">      <span class="keyword">const</span> hadKey = hasOwn(target, key)</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.deleteProperty(target, key)</span><br><span class="line">      <span class="comment">// key存在并且删除成功</span></span><br><span class="line">      <span class="keyword">if</span> (res &amp;&amp; hadKey) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">        trigger(target, <span class="string">'DELETE'</span>, key)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  toProxy.set(obj, observed)</span><br><span class="line">  toRaw.set(observed, obj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每一个属性的响应回调方法</span></span><br><span class="line"><span class="keyword">const</span> activeReativeEffectStack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集执行</span></span><br><span class="line"><span class="comment">// 基本结构&#123;target:&#123;key:[eff1，eff2]&#125;&#125;</span></span><br><span class="line"><span class="keyword">let</span> targetsMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从栈中获取响应函数</span></span><br><span class="line">  <span class="keyword">const</span> effect = activeReativeEffectStack[activeReativeEffectStack.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">if</span> (effect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetsMap.get(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      <span class="comment">// 首次访问target</span></span><br><span class="line">      depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">      targetsMap.set(target, depsMap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放key</span></span><br><span class="line">    <span class="keyword">let</span> deps = depsMap.get(key)</span><br><span class="line">    <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">      deps = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">      depsMap.set(key, deps)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!deps.has(effect)) &#123;</span><br><span class="line">      deps.add(effect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据变化响应回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.异常处理</span></span><br><span class="line">  <span class="comment">// 2.执行函数</span></span><br><span class="line">  <span class="comment">// 3.放置到activeReativeEffectStack</span></span><br><span class="line">  <span class="keyword">const</span> rxEffect = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      activeReativeEffectStack.push(rxEffect)</span><br><span class="line">      <span class="keyword">return</span> fn(...args) <span class="comment">// 执行函数触发依赖收集</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      activeReativeEffectStack.pop()</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rxEffect() <span class="comment">// 默认立即执行</span></span><br><span class="line">  <span class="keyword">return</span> rxEffect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发target.key对应响应函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, type, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取依赖表</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetsMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (depsMap) &#123;</span><br><span class="line">    <span class="comment">// 获取响应函数集合</span></span><br><span class="line">    <span class="keyword">const</span> deps = depsMap.get(key)</span><br><span class="line">    <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">      <span class="comment">// 执行所有响应函数</span></span><br><span class="line">      deps.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// effect()</span></span><br><span class="line">        effects.add(effect)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组新增或删除</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'ADD'</span> || type === <span class="string">'DELETE'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">        <span class="keyword">const</span> deps = depsMap.get(<span class="string">'length'</span>)</span><br><span class="line">        <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">          deps.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">            effects.add(effect)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取已存在的Dep Set执行</span></span><br><span class="line">    effects.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> effect())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> react = reactive(data)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line"><span class="comment">// react.foo // ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line"><span class="comment">// react.foo = 'foooooooo'</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line"><span class="comment">// react.baz = 'bazzzzzz'</span></span><br><span class="line"><span class="comment">// 4.嵌套对象</span></span><br><span class="line"><span class="comment">// react.bar.a = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免重复代理</span></span><br><span class="line"><span class="comment">// console.log(reactive(data) === react) // true</span></span><br><span class="line"><span class="comment">// reactive(react)</span></span><br><span class="line">effect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'count发生了变化：'</span>, react.foo)</span><br><span class="line">  <span class="comment">// dom</span></span><br><span class="line">&#125;)</span><br><span class="line">react.foo = <span class="string">'fooooooo'</span></span><br></pre></td></tr></table></figure><h2 id="vue响应式数据更新的流程"><a href="#vue响应式数据更新的流程" class="headerlink" title="vue响应式数据更新的流程"></a>vue响应式数据更新的流程</h2><p><a href="https://imgchr.com/i/ymNdWF" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2021/02/02/ymNdWF.png" alt="ymNdWF.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是PWA</title>
      <link href="//posts/138dbef8.html"/>
      <url>//posts/138dbef8.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>大家都知道Native app体验确实很好，下载到手机上之后入口也方便。它也有一些缺点:</p><ul><li>开发成本高(ios和安卓)</li><li>软件上线需要审核</li><li>版本更新需要将新版本上传到不同的应用商店</li><li>想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下</li></ul><p>而web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是除了体验上比Native app还是差一些，还有一些明显的缺点</p><ul><li>手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签</li><li>没网络就没响应，不具备离线能力</li><li>不像APP一样能进行消息推送</li></ul><p>那么什么是PWA呢？</p><h1 id="二、What’s-PWA"><a href="#二、What’s-PWA" class="headerlink" title="二、What’s PWA?"></a>二、What’s PWA?</h1><p>PWA全称Progressive Web App，即渐进式WEB应用。</p><p>一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能</p><p>解决了哪些问题？</p><ul><li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li><li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li><li>实现了消息推送</li></ul><p>它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。</p><a id="more"></a><h1 id="三、PWA的实现"><a href="#三、PWA的实现" class="headerlink" title="三、PWA的实现"></a>三、PWA的实现</h1><h2 id="3-1-Manifest实现添加至主屏幕"><a href="#3-1-Manifest实现添加至主屏幕" class="headerlink" title="3.1 Manifest实现添加至主屏幕"></a>3.1 Manifest实现添加至主屏幕</h2><p>index.html</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Minimal PWA<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"manifest.json"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"/e.png"</span> <span class="attr">type</span>=<span class="string">"image/png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>manifest.json</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Minimal PWA"</span>, <span class="comment">// 必填 显示的插件名称</span></span><br><span class="line">  <span class="string">"short_name"</span>: <span class="string">"PWA Demo"</span>, <span class="comment">// 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name</span></span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"The app that helps you understand PWA"</span>, <span class="comment">//用于描述应用</span></span><br><span class="line">  <span class="string">"display"</span>: <span class="string">"standalone"</span>, <span class="comment">// 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的</span></span><br><span class="line">  <span class="string">"start_url"</span>: <span class="string">"/"</span>, <span class="comment">// 应用启动时的url</span></span><br><span class="line">  <span class="string">"theme_color"</span>: <span class="string">"#313131"</span>, <span class="comment">// 桌面图标的背景色</span></span><br><span class="line">  <span class="string">"background_color"</span>: <span class="string">"#313131"</span>, <span class="comment">// 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。</span></span><br><span class="line">  <span class="string">"icons"</span>: [ <span class="comment">// 桌面图标，是一个数组</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"icon/lowres.webp"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"48x48"</span>,  <span class="comment">// 以空格分隔的图片尺寸</span></span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"image/webp"</span>  <span class="comment">// 帮助userAgent快速排除不支持的类型</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"icon/lowres"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"48x48"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"icon/hd_hi.ico"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"72x72 96x96 128x128 256x256"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"icon/hd_hi.svg"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"72x72"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Manifest" target="_blank" rel="noopener">Manifest参考文档</a>可以打开<a href="https://developers.google.cn/web/showcase/2015/chrome-dev-summit" target="_blank" rel="noopener">网站</a>查看添加至主屏幕的动图。</p><p>如果用的是安卓手机，可以下载chrome浏览器自己操作看看</p><h2 id="3-2-service-worker实现离线缓存"><a href="#3-2-service-worker实现离线缓存" class="headerlink" title="3.2 service worker实现离线缓存"></a>3.2 service worker实现离线缓存</h2><h3 id="3-2-1-什么是service-worker"><a href="#3-2-1-什么是service-worker" class="headerlink" title="3.2.1 什么是service worker"></a>3.2.1 什么是service worker</h3><p>Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。</p><p><a href="https://imgchr.com/i/DeyZsU" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/18/DeyZsU.png" alt="DeyZsU.png"></a></p><p>Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。</p><h4 id="最主要的特点"><a href="#最主要的特点" class="headerlink" title="最主要的特点"></a>最主要的特点</h4><ul><li>在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</li><li>网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)</li><li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li><li>单独的作用域范围，单独的运行环境和执行线程</li><li>不能操作页面 DOM。但可以通过事件机制来处理</li><li>事件驱动型服务线程</li></ul><p>为什么要求网站必须是HTTPS的，大概是因为service worker权限太大能拦截所有页面的请求吧，如果http的网站安装service worker很容易被攻击</p><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a><strong>浏览器支持情况</strong></h4><p><a href="https://imgchr.com/i/Dey0JI" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/18/Dey0JI.png" alt="Dey0JI.png"></a></p><p>浏览器支持情况详见： <a href="https://caniuse.com/#feat=serviceworkers" target="_blank" rel="noopener">https://caniuse.com/#feat=serviceworkers</a></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><p><a href="https://imgchr.com/i/DeyIS0" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/18/DeyIS0.png" alt="DeyIS0.png"></a></p><p>当用户首次导航至 URL 时，服务器会返回响应的网页。</p><ul><li>第1步:当你调用 register() 函数时， Service Worker 开始下载。</li><li>第2步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。</li><li>第3步:一旦 Service Worker 成功执行了，install 事件就会激活</li><li>第4步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用了！</li></ul><p>chrome://serviceworker-internals 来了解当前浏览器中所有已安装Service Worker的详细情况</p><h3 id="3-2-2-HTTP缓存与service-worker缓存"><a href="#3-2-2-HTTP缓存与service-worker缓存" class="headerlink" title="3.2.2 HTTP缓存与service worker缓存"></a>3.2.2 HTTP缓存与service worker缓存</h3><ul><li>HTTP缓存</li></ul><p>Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。<br>使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。</p><ul><li>service worker缓存</li></ul><p>Service Workers 的强大在于它们拦截 HTTP 请求的能力<br>进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！</p><h3 id="3-2-3-实现离线缓存"><a href="#3-2-3-实现离线缓存" class="headerlink" title="3.2.3 实现离线缓存"></a>3.2.3 实现离线缓存</h3><p>index.html</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Caching World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Image --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/hello.png"</span> /&gt;</span>                 </span><br><span class="line">    <span class="comment">&lt;!-- JavaScript --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/script.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 注册 service worker</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;           </span></span><br><span class="line"><span class="actionscript">        navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>, &#123;scope: <span class="string">'/'</span>&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(registration)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 注册成功</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful with scope: '</span>, registration.scope);</span></span><br><span class="line"><span class="actionscript">        &#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;                   </span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 注册失败 :(</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：Service Worker 的注册路径决定了其 scope 默认作用页面的范围。<br>如果 service-worker.js 是在 /sw/ 页面路径下，这使得该 Service Worker 默认只会收到 页面/sw/ 路径下的 fetch 事件。<br>如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。<br>如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。</p><p>service-worker.js</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'helloWorld'</span>;     <span class="comment">// 缓存的名称  </span></span><br><span class="line"><span class="comment">// install 事件，它发生在浏览器安装并注册 Service Worker 时        </span></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'install'</span>, event =&gt; &#123; </span><br><span class="line"><span class="comment">/* event.waitUtil 用于在安装成功之前执行一些预装逻辑</span></span><br><span class="line"><span class="comment"> 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span></span><br><span class="line"><span class="comment"> 安装成功后 ServiceWorker 状态会从 installing 变为 installed */</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheName)                  </span><br><span class="line">    .then(cache =&gt; cache.addAll([    <span class="comment">// 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。        </span></span><br><span class="line">      <span class="string">'/js/script.js'</span>,</span><br><span class="line">      <span class="string">'/images/hello.png'</span></span><br><span class="line">    ]))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。</span></span><br><span class="line"><span class="comment">如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)                  </span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;                            </span><br><span class="line">        <span class="keyword">return</span> response;                         </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> requestToCache = event.request.<span class="keyword">clone</span>();  <span class="comment">//          </span></span><br><span class="line">      <span class="keyword">return</span> fetch(requestToCache).then(                   </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span>) &#123;      </span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">var</span> responseToCache = response.<span class="keyword">clone</span>();          </span><br><span class="line">          caches.open(cacheName)                           </span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> <span class="params">(cache)</span> </span>&#123;</span><br><span class="line">              cache.put(requestToCache, responseToCache);  </span><br><span class="line">            &#125;);</span><br><span class="line">          <span class="keyword">return</span> response;             </span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：为什么用request.clone()和response.clone()<br>需要这么做是因为request和response是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求<br>Clone the request—a request is a stream and can only be consumed once.</p><h3 id="3-2-4-调试相关"><a href="#3-2-4-调试相关" class="headerlink" title="3.2.4 调试相关"></a>3.2.4 调试相关</h3><p>chrome浏览器打开<a href="https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service" target="_blank" rel="noopener">https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service</a> worker离线缓存功能的网站，打开调试工具</p><p><a href="https://imgchr.\\\\\\\\\\com/i/De6Q0g" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/18/De6Q0g.png" alt="De6Q0g.png"></a></p><p>介绍一个图中的1.和2.</p><ol><li>勾选可以模拟网站离线情况，勾选后network会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示</li><li>当前service worker的scope。它能够拦截<a href="https://googlechrome.github.io/samples/service-worker/basic/index.html下的请求" target="_blank" rel="noopener">https://googlechrome.github.i…</a>，同样也能够拦截<a href="https://googlechrome.github.io/samples/service-worker/basic/" target="_blank" rel="noopener">https://googlechrome.github.i…</a><em>/</em>.html下的请求</li></ol><p>调试面板具体代表的什么参看<a href="https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分" target="_blank" rel="noopener">https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分</a></p><h2 id="3-3-serice-worker实现消息推送"><a href="#3-3-serice-worker实现消息推送" class="headerlink" title="3.3 serice worker实现消息推送"></a>3.3 serice worker实现消息推送</h2><p><a href="https://imgchr.com/i/De6t10" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/18/De6t10.png" alt="De6t10.png"></a></p><ul><li>步骤一、提示用户并获得他们的订阅详细信息</li><li>步骤二、将这些详细信息保存在服务器上</li><li>步骤三、在需要时发送任何消息</li></ul><p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<gcm> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</gcm></p><p><strong>步骤一和步骤二</strong></p><p>index.html</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Progressive Times<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span>                                      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> endpoint;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> key;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> authSecret;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vapidPublicKey = <span class="string">'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY'</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">urlBase64ToUint8Array</span><span class="params">(base64String)</span> </span>&#123;                                  </span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> padding = <span class="string">'='</span>.repeat((<span class="number">4</span> - base64String.length % <span class="number">4</span>) % <span class="number">4</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> base64 = (base64String + padding)</span></span><br><span class="line"><span class="javascript">          .replace(<span class="regexp">/\-/g</span>, <span class="string">'+'</span>)</span></span><br><span class="line"><span class="javascript">          .replace(<span class="regexp">/_/g</span>, <span class="string">'/'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> rawData = <span class="built_in">window</span>.atob(base64);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> outputArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawData.length);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rawData.length; ++i) &#123;</span></span><br><span class="line">          outputArray[i] = rawData.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> outputArray;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span></span><br><span class="line"><span class="actionscript">        navigator.serviceWorker.register(<span class="string">'sw.js'</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(registration)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> registration.pushManager.getSubscription()                            </span></span><br><span class="line"><span class="actionscript">            .then(<span class="function"><span class="keyword">function</span> <span class="params">(subscription)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">if</span> (subscription) &#123;                                                      </span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>;</span></span><br><span class="line">              &#125;</span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span> registration.pushManager.subscribe(&#123;                              </span></span><br><span class="line"><span class="actionscript">                  userVisibleOnly: <span class="literal">true</span>,</span></span><br><span class="line">                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)</span><br><span class="line">                &#125;)</span><br><span class="line"><span class="actionscript">                .then(<span class="function"><span class="keyword">function</span> <span class="params">(subscription)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">var</span> rawKey = subscription.getKey ? subscription.getKey(<span class="string">'p256dh'</span>) : <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">                  key = rawKey ? btoa(<span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawKey))) : <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">var</span> rawAuthSecret = subscription.getKey ? subscription.getKey(<span class="string">'auth'</span>) : <span class="string">''</span>;</span></span><br><span class="line">                  authSecret = rawAuthSecret ?</span><br><span class="line"><span class="javascript">                    btoa(<span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawAuthSecret))) : <span class="string">''</span>;</span></span><br><span class="line">                  endpoint = subscription.endpoint;</span><br><span class="line"><span class="actionscript">                  <span class="keyword">return</span> fetch(<span class="string">'./register'</span>, &#123;                                         </span></span><br><span class="line"><span class="actionscript">                    method: <span class="string">'post'</span>,</span></span><br><span class="line"><span class="actionscript">                    headers: <span class="keyword">new</span> Headers(&#123;</span></span><br><span class="line"><span class="actionscript">                      <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span></span><br><span class="line">                    &#125;),</span><br><span class="line"><span class="javascript">                    body: <span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line">                      endpoint: subscription.endpoint,</span><br><span class="line">                      key: key,</span><br><span class="line">                      authSecret: authSecret,</span><br><span class="line">                    &#125;),</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">        &#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 注册失败 :(</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤三 服务器发送消息给service worker</strong></p><p>app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpush = <span class="built_in">require</span>(<span class="string">'web-push'</span>);                 </span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">webpush.setVapidDetails(                             </span><br><span class="line">  <span class="string">'mailto:contact@deanhume.com'</span>,</span><br><span class="line">  <span class="string">'BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY'</span>,</span><br><span class="line">  <span class="string">'p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0'</span></span><br><span class="line">);</span><br><span class="line">app.post(<span class="string">'/register'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;           </span><br><span class="line">  <span class="keyword">var</span> endpoint = req.body.endpoint;</span><br><span class="line">  saveRegistrationDetails(endpoint, key, authSecret); </span><br><span class="line">  <span class="keyword">const</span> pushSubscription = &#123;                          </span><br><span class="line">    endpoint: req.body.endpoint,</span><br><span class="line">    keys: &#123;</span><br><span class="line">      auth: req.body.authSecret,</span><br><span class="line">      p256dh: req.body.key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="string">'Thank you for registering'</span>;</span><br><span class="line">  <span class="keyword">var</span> iconUrl = <span class="string">'https://example.com/images/homescreen.png'</span>;</span><br><span class="line">  <span class="comment">// 发送 Web 推送消息</span></span><br><span class="line">  webpush.sendNotification(pushSubscription,          </span><br><span class="line">      <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        msg: body,</span><br><span class="line">        url: <span class="string">'http://localhost:3111/'</span>,</span><br><span class="line">        icon: iconUrl</span><br><span class="line">      &#125;))</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> res.sendStatus(<span class="number">201</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3111</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Web push app listening on port 3111!'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>service worker监听push事件，将通知详情推送给用户</strong></p><p>service-worker.js</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 检查服务端是否发来了任何有效载荷数据</span></span><br><span class="line">  <span class="keyword">var</span> payload = event.data ? JSON.parse(event.data.text()) : <span class="string">'no payload'</span>;</span><br><span class="line">  <span class="keyword">var</span> title = <span class="string">'Progressive Times'</span>;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// 使用提供的信息来显示 Web 推送通知</span></span><br><span class="line">    <span class="keyword">self</span>.registration.showNotification(title, &#123;                           </span><br><span class="line">      body: payload.msg,</span><br><span class="line">      url: payload.url,</span><br><span class="line">      icon: payload.icon</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>扩展知识：<a href="https://lzw.me/a/pwa-service-worker.html#3.3" target="_blank" rel="noopener">service worker的更新</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="PWA的优势"><a href="#PWA的优势" class="headerlink" title="PWA的优势"></a>PWA的优势</h3><ul><li>可以将app的快捷方式放置到桌面上，全屏运行，与原生app无异</li><li>能够在各种网络环境下使用，包括网络差和断网条件下，不会显示undefind</li><li>推送消息的能力</li><li>其本质是一个网页，没有原生app的各种启动条件，快速响应用户指令</li></ul><h3 id="PWA存在的问题"><a href="#PWA存在的问题" class="headerlink" title="PWA存在的问题"></a>PWA存在的问题</h3><ul><li>支持率不高:现在ios手机端不支持pwa，IE也暂时不支持</li><li>Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低</li><li>各大厂商还未明确支持pwa</li><li>依赖的GCM服务在国内无法使用</li><li>微信小程序的竞争</li></ul><p>尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。</p><ul><li>service worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。</li><li>service worker实现消息推送，使用浏览器推送功能，吸引用户</li><li>渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/SangKa/PWA-Book-CN" target="_blank" rel="noopener">第一本 PWA 中文书</a></li><li><a href="https://github.com/deanhume/progressive-web-apps-book" target="_blank" rel="noopener">PWA 英文书</a></li><li><a href="https://lzw.me/a/pwa-service-worker.html" target="_blank" rel="noopener">网站渐进式增强体验(PWA)改造：Service Worker 应用详解</a></li><li><a href="https://googlechrome.github.io/samples/service-worker/basic/index.html" target="_blank" rel="noopener">Basic Service Worker Sample</a></li><li><a href="https://www.w3ctech.com/topic/866" target="_blank" rel="noopener">【翻译】Service Worker 入门</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Manifest" target="_blank" rel="noopener">Web App Manifest</a></li><li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener">Service Workers: an Introduction</a></li><li><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" target="_blank" rel="noopener">The Offline Cookbook</a></li><li><a href="http://blog.csdn.net/baidu_browser/article/details/64440238" target="_blank" rel="noopener">微信小程序和PWA对比分析</a></li><li><a href="https://x5.tencent.com/tbs/guide/serviceworker.html" target="_blank" rel="noopener">Service Worker最佳实践</a></li></ul><p><a href="https://segmentfault.com/a/1190000012353473" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>⼤⼚⾯试章法</title>
      <link href="//posts/37eb3f8a.html"/>
      <url>//posts/37eb3f8a.html</url>
      
        <content type="html"><![CDATA[<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>2⻚以内，简历有点类似相亲的介绍，⼩时候拿过三好学</p><p>⽣就别说了，就像别写你会html+css，别写你⽤vue做 </p><p>过todolist⼀样</p><p>突出⾃⼰的技术亮点</p><p>别瞎写精通</p><p>markdown就好，别⽤word</p><p>突出亮点！</p><h2 id="⽬标公司"><a href="#⽬标公司" class="headerlink" title="⽬标公司"></a>⽬标公司</h2><p>天眼查，脉脉，知乎</p><h2 id="如何描述做过的项⽬"><a href="#如何描述做过的项⽬" class="headerlink" title="如何描述做过的项⽬"></a>如何描述做过的项⽬</h2><ol><li><p>做过的明星项⽬</p></li><li><p>项⽬技术栈和细节</p></li><li><p>源码深度</p></li><li><p>优化，性能，体验，极客</p></li><li><p>填坑</p></li><li><p>成⻓</p></li></ol><h2 id="⾯试技巧合计"><a href="#⾯试技巧合计" class="headerlink" title="⾯试技巧合计"></a>⾯试技巧合计</h2><ol><li><p>认识⾃⼰（市场）</p></li><li><p>阐述优势</p></li><li><p>谈判得来的 都是纯利润</p></li><li><p>hr细节(考勤，补贴，996，五险⼀⾦，补贴</p></li><li>⼀个⾯试题的精讲</li></ol><h2 id="精讲面试题之前端⽂件上传"><a href="#精讲面试题之前端⽂件上传" class="headerlink" title="精讲面试题之前端⽂件上传"></a>精讲面试题之前端⽂件上传</h2><p><strong>1、原理概述</strong></p><p>考察全栈思维，http协议 ，node⽂件处理</p><p>我⽤vue+element+nodejs来演示</p><p>基本答案 （<strong>10K</strong>）</p><a id="more"></a><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formData</span><br><span class="line">&lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"file"</span> <span class="meta">@change</span>=<span class="string">"handleFileChange"</span> /&gt;</span><br><span class="line">&lt;el-button <span class="class"><span class="keyword">type</span></span>=<span class="string">"primary"</span> <span class="meta">@click</span>=<span class="string">"handleUpload"</span>&gt;上传&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">handleFileChange(<span class="keyword">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [<span class="keyword">file</span>] = <span class="keyword">e</span>.target.files; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">file</span>) <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"filename"</span>, this.container.<span class="keyword">file</span>.name);</span><br><span class="line">  <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"file"</span>, this.container.<span class="keyword">file</span>);</span><br><span class="line"> request(&#123;url: '/upload', 9 data: <span class="keyword">form</span>&#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">node</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'./controller'</span>)</span><br><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">'./schedule'</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"><span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">".."</span>, <span class="string">"target"</span>); <span class="comment">// ⼤⽂件存储⽬录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// schedule.start(UPLOAD_DIR)</span></span><br><span class="line"> <span class="keyword">const</span> ctrl = <span class="keyword">new</span> Controller(UPLOAD_DIR)</span><br><span class="line"> server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">   res.setHeader(<span class="string">"Access-Control-AllowOrigin"</span>, <span class="string">"*"</span>)</span><br><span class="line">   res.setHeader(<span class="string">"Access-Control-AllowHeaders"</span>, <span class="string">"*"</span>)</span><br><span class="line">   <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">     res.status = <span class="number">200</span></span><br><span class="line">     res.end()</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (req.method === <span class="string">"POST"</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (req.url == <span class="string">'/upload'</span>) &#123;</span><br><span class="line">       <span class="keyword">await</span> ctrl.handleUpload(req, res)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> server.listen(<span class="number">3000</span>, <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端⼝"</span>))</span><br><span class="line"> </span><br><span class="line"> Controller.js</span><br><span class="line"> <span class="keyword">async</span> handleUpload(req, res) &#123;</span><br><span class="line">   <span class="keyword">const</span> multipart = <span class="keyword">new</span> multiparty.Form()</span><br><span class="line">   multipart.parse(req, <span class="keyword">async</span> (err,</span><br><span class="line">     field, file) =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(err) <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">const</span> [chunk] = file.file</span><br><span class="line">     <span class="keyword">const</span> [filename] = field.filename</span><br><span class="line">     <span class="keyword">const</span> filePath = path.resolve(<span class="keyword">this</span>.UPLOAD_DIR, <span class="string">`<span class="subst">$&#123;fileHash&#125;</span><span class="subst">$&#123;extractExt(filename)&#125;</span>`</span>)</span><br><span class="line">     <span class="keyword">const</span> chunkDir = path.resolve(<span class="keyword">this</span>.UPLOAD_DIR, fileHash)</span><br><span class="line">     <span class="comment">// ⽂件存在直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (fse.existsSync(filePath)) &#123;</span><br><span class="line">       res.end(<span class="string">"file exist"</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">       <span class="keyword">await</span> fse.mkdirs(chunkDir)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">await</span> fse.move(chunk.path, <span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>`</span>)</span><br><span class="line">     res.end(<span class="string">"received file chunk"</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>formData</p></li><li><p>httpserver</p></li><li><p>fs⽂件处理</p></li><li><p>multiparty解析post数据</p></li></ol><p><strong>加分项-拖拽，粘贴</strong></p><p>考点: 拖拽事件drop，clipboardData</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"drop-box"</span> id=<span class="string">"drop-box"</span>&gt;</span><br><span class="line"><span class="comment">// 拖拽</span></span><br><span class="line">box.addEventListener(<span class="string">"drop"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault(); <span class="comment">//取消浏览器默认拖拽效果</span></span><br><span class="line">    <span class="keyword">var</span> fileList = e.dataTransfer.files; <span class="comment">//获取拖拽中的⽂件对象 </span></span><br><span class="line">    <span class="keyword">var</span> len = fileList.length; <span class="comment">//⽤来获取⽂件的⻓度（其实是获得⽂件数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [file] = e.target.files;</span><br><span class="line">    <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ...上传</span></span><br><span class="line"></span><br><span class="line"> &#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 粘贴 </span></span><br><span class="line"> box.addEventListener(<span class="string">'paste'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = (event.clipboardData)</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><strong>⼤⽂件上传(20K)</strong></p><p>blob.slice分⽚ 思想+语法</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const chunks = <span class="keyword">this</span>.createFileChunk(<span class="keyword">this</span>.container.<span class="keyword">file</span>);</span><br><span class="line">createFileChunk(<span class="keyword">file</span>, <span class="keyword">size</span> = <span class="keyword">SIZE</span>) &#123; <span class="comment">// ⽣成⽂件块</span></span><br><span class="line">    const chunks = [];</span><br><span class="line">    let cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; <span class="keyword">file</span>.<span class="keyword">size</span>) &#123;</span><br><span class="line">      chunks.<span class="keyword">push</span>(&#123;</span><br><span class="line">        <span class="keyword">file</span>: <span class="keyword">file</span>.slice(cur, cur + <span class="keyword">size</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">      cur += <span class="keyword">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chunks;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所有切⽚挨个发请求，然后merge</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> handleMerge(req, res) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req)</span><br><span class="line">    <span class="title">const</span> &#123;</span><br><span class="line">      fileHash,</span><br><span class="line">      filename,</span><br><span class="line">      <span class="built_in">size</span></span><br><span class="line">    &#125; = data</span><br><span class="line">    <span class="keyword">const</span> ext = extractExt(filename)</span><br><span class="line">    <span class="keyword">const</span> filePath =</span><br><span class="line">      path.resolve(<span class="keyword">this</span>.UPLOAD_DIR, <span class="string">`<span class="subst">$&#123;fileHash&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.mergeFileChunk(filePath, fileHash, <span class="built_in">size</span>)</span><br><span class="line">    res.end(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="attribute">code</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attribute">message</span>: <span class="string">"file merged success"</span></span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>断点续传+秒传</strong></p><p>md5计算，缓存思想 ⽂件⽤md5计算⼀个指纹，上传之前，先问后端，这个⽂件的hash在不在，在的话就不⽤传了，就是所谓的断点续传，如果整个⽂件都存在了 就是秒传</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> handleVerify(req, res) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req)</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      filename,</span><br><span class="line">      hash</span><br><span class="line">    &#125; = data</span><br><span class="line">    <span class="keyword">const</span> ext = extractExt(filename)</span><br><span class="line">    <span class="keyword">const</span> filePath = path.resolve(<span class="keyword">this</span>.UPLOAD_DIR, <span class="string">`<span class="subst">$&#123;hash&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// ⽂件是否存在</span></span><br><span class="line">    <span class="keyword">let</span> uploaded = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> uploadedList = []</span><br><span class="line">    <span class="keyword">if</span> (fse.existsSync(filePath)) &#123;</span><br><span class="line">      uploaded = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ⽂件没有完全上传完毕，但是可能存在部分切⽚上传完毕了</span></span><br><span class="line">      uploadedList = <span class="keyword">await</span> getUploadedList(path.resolve(<span class="keyword">this</span>.UPLOAD_DIR, hash))</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        uploaded,</span><br><span class="line">        uploadedList <span class="comment">// 过滤诡异的隐藏⽂件</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>计算hash优化(25+)</strong></p><p>1、<strong>web-worker</strong></p><p>⼤⽂件的md5太慢了,启⽤webworker计算</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// web-worker</span></span><br><span class="line">  <span class="keyword">self</span>.importScripts(<span class="string">'spark-md5.min.js'</span>)</span><br><span class="line">  <span class="keyword">self</span>.onmessage = e =&gt; &#123;</span><br><span class="line">    <span class="comment">// 接受主线程的通知</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      chunks</span><br><span class="line">    &#125; = e.data</span><br><span class="line">    <span class="keyword">const</span> spark = <span class="keyword">new</span></span><br><span class="line">    <span class="keyword">self</span>.SparkMD5.ArrayBuffer()</span><br><span class="line">    <span class="keyword">let</span> progress = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> loadNext = index =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">      reader.readAsArrayBuffer(chunks[index].file)</span><br><span class="line">      reader.onload = e =&gt; &#123;</span><br><span class="line">        <span class="comment">// 累加器 不能依赖index，</span></span><br><span class="line">        count++</span><br><span class="line">        <span class="comment">// 增量计算md5</span></span><br><span class="line">        spark.append(e.target.result)</span><br><span class="line">        <span class="keyword">if</span> (count === chunks.length) &#123;</span><br><span class="line">          <span class="comment">// 通知主线程，计算结束</span></span><br><span class="line">          <span class="keyword">self</span>.postMessage(&#123;</span><br><span class="line">            progress: <span class="number">100</span>,</span><br><span class="line">            hash: spark.end()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 每个区块计算结束，通知进度即可</span></span><br><span class="line">          progress += <span class="number">100</span> / chunks.length</span><br><span class="line">          <span class="keyword">self</span>.postMessage(&#123;</span><br><span class="line">            progress</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 计算下⼀个</span></span><br><span class="line">          loadNext(count)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    loadNext(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>1、<strong>time-slice(30+)</strong></p><p>react fifiber架构学习，利⽤浏览器空闲时间</p><p>requestIdleCallback</p><p><a href="https://imgchr.com/i/DweIhj" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/26/DweIhj.png" alt="DweIhj.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">requestIdelCallback(myNonEssentialWork);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// deadline.timeRemaining()可以获取到当前帧剩余时间</span></span><br><span class="line">    <span class="comment">// 当前帧还有时间 并且任务队列不为空</span></span><br><span class="line">    <span class="keyword">while</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      doWorkIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      requestIdleCallback(myNonEssentialWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> calculateHashIdle(chunks) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> spark = <span class="keyword">new</span></span><br><span class="line">      SparkMD5.ArrayBuffer();</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 根据⽂件内容追加计算</span></span><br><span class="line">      <span class="keyword">const</span> appendToSpark = <span class="keyword">async</span></span><br><span class="line">      file =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> reader = <span class="keyword">new</span></span><br><span class="line">          FileReader();</span><br><span class="line"></span><br><span class="line">          reader.readAsArrayBuffer(file);</span><br><span class="line">          reader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            spark.append(e.target.result);</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">const</span> workLoop = <span class="keyword">async</span> deadline =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有任务，并且当前帧还没结束</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; chunks.length &amp;&amp;</span><br><span class="line">          deadline.timeRemaining() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">await</span></span><br><span class="line">          appendToSpark(chunks[count].file);</span><br><span class="line">          count++;</span><br><span class="line">          <span class="comment">// 没有了 计算完毕</span></span><br><span class="line">          <span class="keyword">if</span> (count &lt; chunks.length) &#123;</span><br><span class="line">            <span class="comment">// 计算中</span></span><br><span class="line">            <span class="keyword">this</span>.hashProgress =</span><br><span class="line">              <span class="built_in">Number</span>(</span><br><span class="line">                ((<span class="number">100</span> * count) /</span><br><span class="line">                  chunks.length).toFixed(<span class="number">2</span>)</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.hashProgress)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算完毕</span></span><br><span class="line">            <span class="keyword">this</span>.hashProgress = <span class="number">100</span>;</span><br><span class="line">            resolve(spark.end());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.requestIdleCallback(workLoop);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、<strong>算法优化</strong></p><h2 id="精讲面试题之请求并发数控制和重试"><a href="#精讲面试题之请求并发数控制和重试" class="headerlink" title="精讲面试题之请求并发数控制和重试"></a>精讲面试题之请求并发数控制和重试</h2><p><a href="https://imgchr.com/i/DwmGVS" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s3.ax1x.com/2020/11/26/DwmGVS.png" alt="DwmGVS.png"></a></p><p>1、<strong>基本实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> sendRequest(forms, max = <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> len = forms.length;</span><br><span class="line">      <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> start = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 有请求，有通道</span></span><br><span class="line">        <span class="keyword">while</span> (idx &lt; len &amp;&amp; max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          max--; <span class="comment">// 占⽤通道</span></span><br><span class="line">          <span class="built_in">console</span>.log(idx, <span class="string">"start"</span>);</span><br><span class="line">          <span class="keyword">const</span> form = forms[idx].form;</span><br><span class="line">          <span class="keyword">const</span> index =</span><br><span class="line">            forms[idx].index; + idx++</span><br><span class="line">          request(&#123;</span><br><span class="line">            url: <span class="string">'/upload'</span>,</span><br><span class="line">            data: form,</span><br><span class="line">            onProgress: <span class="keyword">this</span>.createProgresshandler(<span class="keyword">this</span>.chunks[</span><br><span class="line">              index]),</span><br><span class="line">            requestList: <span class="keyword">this</span>.requestList</span><br><span class="line">          &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            max++; <span class="comment">// 释放通道</span></span><br><span class="line">            counter++;</span><br><span class="line">            <span class="keyword">if</span> (counter === len) &#123;</span><br><span class="line">              resolve();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              start();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      start();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> uploadChunks(uploadedList = []) &#123;</span><br><span class="line">    <span class="comment">// 这⾥⼀起上传，碰⻅⼤⽂件就是灾难</span></span><br><span class="line">    <span class="comment">// 没被hash计算打到，被⼀次性的tcp链接把浏览器稿挂了</span></span><br><span class="line">    <span class="comment">// 异步并发控制策略，我记得这个也是头条⼀个⾯试题</span></span><br><span class="line">    <span class="comment">// ⽐如并发量控制成4</span></span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">this</span>.chunks.filter(<span class="function"><span class="params">chunk</span> =&gt;</span> uploadedList.indexOf(chunk.hash) == <span class="number">-1</span>)</span><br><span class="line">      .map((&#123;</span><br><span class="line">        chunk,</span><br><span class="line">        hash,</span><br><span class="line">        index</span><br><span class="line">      &#125;, i) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> form = <span class="keyword">new</span> FormData();</span><br><span class="line">        form.append(<span class="string">"chunk"</span>, chunk);</span><br><span class="line">        form.append(<span class="string">"hash"</span>, hash);</span><br><span class="line">        form.append(<span class="string">"filename"</span>, <span class="keyword">this</span>.container.file.name);</span><br><span class="line">        form.append(<span class="string">"fileHash"</span>, <span class="keyword">this</span>.container.hash);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          form,</span><br><span class="line">          index</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;).map((&#123;</span><br><span class="line">          form,</span><br><span class="line">          index</span><br><span class="line">        &#125;) =&gt;</span><br><span class="line">        request(&#123;</span><br><span class="line">          url: <span class="string">"/upload"</span>,</span><br><span class="line">          data: form,</span><br><span class="line">          onProgress: <span class="keyword">this</span>.createProgresshandler(<span class="keyword">this</span>.chunks[index]),</span><br><span class="line">          requestList: <span class="keyword">this</span>.requestList</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    <span class="comment">// 直接全量并发</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(list);</span><br><span class="line">    <span class="comment">// 控制并发 </span></span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span></span><br><span class="line">    <span class="keyword">this</span>.sendRequest(list, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> (uploadedList.length + list.length ===</span><br><span class="line">      <span class="keyword">this</span>.chunks.length) &#123;</span><br><span class="line">      <span class="comment">// 上传和已经存在之和 等于全部的再合并</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.mergeRequest();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2、<strong>慢启动策略</strong></p><p>TCP拥塞控制的问题 其实就是根据当前⽹络情况，动态</p><p>调整切⽚的⼤⼩</p><ol><li><p>chunk中带上size值，不过进度条数量不确定了，修改createFileChunk， 请求加上时间统计)</p></li><li><p>⽐如我们理想是30秒传递⼀个</p></li><li><p>初始⼤⼩定为1M，如果上传花了10秒，那下⼀个区块⼤⼩变成3M</p></li><li><p>如果上传花了60秒，那下⼀个区块⼤⼩变成500KB以此类推</p></li><li><p>并发+慢启动的逻辑有些复杂，我⾃⼰还没绕明⽩，囧所以先⼀次只传⼀个切⽚，来演示这个逻辑，新建⼀个handleUpload1函数</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">async handleUpload1() &#123;</span><br><span class="line">    <span class="comment">// @todo数据缩放的⽐率 可以更平缓  // @todo 并发+慢启动</span></span><br><span class="line">    <span class="comment">// 慢启动上传逻辑</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">file</span> = this.container.<span class="keyword">file</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">file</span>) <span class="keyword">return</span>;</span><br><span class="line">    this.status = Status.uploading;</span><br><span class="line">    <span class="keyword">const</span> fileSize = <span class="keyword">file</span>.size</span><br><span class="line">    let offset = 1024 * 1024</span><br><span class="line">    let cur = 0</span><br><span class="line">    let <span class="keyword">count</span> = 0</span><br><span class="line">    this.container.hash = await</span><br><span class="line">    this.calculateHashSample();</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; fileSize) &#123;</span><br><span class="line">      <span class="comment">// 切割offfset⼤⼩</span></span><br><span class="line">      <span class="keyword">const</span> chunk = <span class="keyword">file</span>.slice(cur, cur + offset)</span><br><span class="line">      cur += offset</span><br><span class="line">      <span class="keyword">const</span> chunkName = this.container.hash + <span class="string">"-"</span> + <span class="keyword">count</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">form</span> = new FormData();</span><br><span class="line">      <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"chunk"</span>, chunk);</span><br><span class="line">      <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"hash"</span>, chunkName);</span><br><span class="line">      <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"filename"</span>, <span class="keyword">file</span>.name);</span><br><span class="line">      <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"fileHash"</span>, this.container.hash);</span><br><span class="line">      <span class="keyword">form</span>.<span class="keyword">append</span>(<span class="string">"size"</span>, chunk.size);</span><br><span class="line"></span><br><span class="line">      let start = new</span><br><span class="line">      <span class="built_in">Date</span>().getTime()</span><br><span class="line">      await request(&#123;</span><br><span class="line">        url: '/upload',</span><br><span class="line">        data: <span class="keyword">form</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">const</span> now = new</span><br><span class="line">      <span class="built_in">Date</span>().getTime()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> time = ((now - start) / 1000).toFixed(4)</span><br><span class="line">      let rate = time / 30</span><br><span class="line">      <span class="comment">// 速率有最⼤2和最⼩0.5</span></span><br><span class="line">      <span class="keyword">if</span> (rate &lt; 0.5) rate = 0.5</span><br><span class="line">      <span class="keyword">if</span> (rate &gt; 2) rate = 2</span><br><span class="line">      <span class="comment">// 新的切⽚⼤⼩等⽐变化</span></span><br><span class="line">      console.<span class="built_in">log</span>(`切⽚<span class="variable">$&#123;count&#125;</span>⼤⼩是<span class="variable">$&#123;this</span>.<span class="keyword">format</span>(offset)&#125;,耗时<span class="variable">$&#123;time&#125;</span>秒，是30秒的<span class="variable">$&#123;rate&#125;</span>倍，修正⼤⼩为<span class="variable">$&#123;this</span>.<span class="keyword">format</span>(offset/rate)&#125;`)</span><br><span class="line">      <span class="comment">// 动态调整offset</span></span><br><span class="line">      offset = parseInt(offset / rate)</span><br><span class="line">      <span class="comment">// if(time)</span></span><br><span class="line">      <span class="keyword">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//切⽚0⼤⼩是1024.00KB,耗时13.2770秒，是30秒的0.5倍，修正⼤⼩为2.00MB</span></span><br><span class="line"><span class="comment">//切⽚1⼤⼩是2.00MB,耗时25.4130秒，是30秒的0.8471倍，修正⼤⼩为2.36MB</span></span><br><span class="line"><span class="comment">//切⽚2⼤⼩是2.36MB,耗时14.1260秒，是30秒的0.5倍，修正⼤⼩为4.72MB</span></span><br></pre></td></tr></table></figure><p>3、<strong>碎⽚清理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了⽅便测试，我改成每5秒扫⼀次， 过期1钟的删除做演示</span></span><br><span class="line">  <span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)</span><br><span class="line">  <span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">  <span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">'nodeschedule'</span>) <span class="comment">// 空⽬录删除</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">file, stats</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">const</span> offset = now - stats.ctimeMs</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; <span class="number">1000</span> * <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="comment">// ⼤于60秒的碎⽚</span></span><br><span class="line">      <span class="built_in">console</span>.log(file, <span class="string">'过期了，浪费空间的玩意，删除'</span>)</span><br><span class="line">      fse.unlinkSync(file)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">scan</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> files = fse.readdirSync(dir)</span><br><span class="line">    files.forEach(<span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fileDir = path.resolve(dir, filename)</span><br><span class="line">      <span class="keyword">const</span> stats = fse.statSync(fileDir)</span><br><span class="line">      <span class="keyword">if</span> (stats.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">return</span> scan(fileDir, remove)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        callback(fileDir, stats)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="function"><span class="keyword">function</span> (<span class="params">UPLOAD_DIR</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每5秒</span></span><br><span class="line">    schedule.scheduleJob(<span class="string">"*/5 * * * * *"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'开始扫描'</span>)</span><br><span class="line">      scan(UPLOAD_DIR)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  exports.start = start</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">开始扫描</span><br><span class="line">/upload/target/<span class="number">625</span>c.../<span class="number">625</span>c...<span class="number">-0</span> 过期了，</span><br><span class="line">删除</span><br><span class="line">/upload/target/<span class="number">625</span>c.../<span class="number">625</span>c...<span class="number">-1</span> 过期了，</span><br><span class="line">删除</span><br><span class="line">/upload/target/<span class="number">625</span>c.../<span class="number">625</span>c...<span class="number">-10</span> 过期了，</span><br><span class="line">删除</span><br><span class="line">/upload/target/<span class="number">625</span>c.../<span class="number">625</span>c...<span class="number">-11</span> 过期了，</span><br><span class="line">删除</span><br><span class="line">/upload/target/<span class="number">625</span>c.../<span class="number">625</span>c...<span class="number">-12</span> 过期了，</span><br><span class="line">删除</span><br></pre></td></tr></table></figure><h2 id="面试题之后续问题"><a href="#面试题之后续问题" class="headerlink" title="面试题之后续问题"></a>面试题之后续问题</h2><ol><li>requestIdleCallback兼容性，如何⾃⼰实现⼀个<br>react也是⾃⼰写的调度逻辑,React⾃⼰实现的requestIdleCallback(<a href="https://www.dazhuanlan.com/2019/10/20/5dabc56a750fd/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/10/20/5dabc56a750fd/</a>)</li><li>并发+慢启动配合</li><li>抽样hash+全量哈希+时间切⽚配合</li><li>⼤⽂件切⽚下载</li><li>websocket推送进度</li><li>⽂件碎⽚分机器存储以及⽂件碎⽚备份</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs中数据库的使用</title>
      <link href="//posts/e4aa7462.html"/>
      <url>//posts/e4aa7462.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Node-js-连接-MySQL"><a href="#1-Node-js-连接-MySQL" class="headerlink" title="1.Node.js 连接 MySQL"></a>1.Node.js 连接 MySQL</h2><p>cnpm install mysql</p><p>连接mysql:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql      = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : <span class="string">'localhost'</span>,</span><br><span class="line">  user     : <span class="string">'root'</span>,</span><br><span class="line">  password : <span class="string">'123456'</span>,</span><br><span class="line">  database : <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line">  </span><br><span class="line">connection.query(<span class="string">'SELECT 1 + 1 AS solution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The solution is: '</span>, results[<span class="number">0</span>].solution);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>数据库连接参数说明</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">参数 描述</span><br><span class="line">host 主机地址 （默认：localhost）</span><br><span class="line"></span><br><span class="line">user 用户名</span><br><span class="line"></span><br><span class="line">password 密码</span><br><span class="line"></span><br><span class="line">port 端口号 （默认：<span class="number">3306</span>）</span><br><span class="line"></span><br><span class="line">database  数据库名</span><br><span class="line"></span><br><span class="line">charset  连接字符集（默认：<span class="string">'UTF8_GENERAL_CI'</span>，注意字符集的字母都要大写）</span><br><span class="line"></span><br><span class="line">localAddress  此IP用于TCP连接（可选）</span><br><span class="line"></span><br><span class="line">socketPath  连接到unix域路径，当使用 host 和 port 时会被忽略</span><br><span class="line"></span><br><span class="line">timezone  时区（默认：<span class="string">'local'</span>）</span><br><span class="line"></span><br><span class="line">connectTimeout 连接超时（默认：不限制；单位：毫秒）</span><br><span class="line"></span><br><span class="line">stringifyObjects 是否序列化对象</span><br><span class="line"></span><br><span class="line">typeCast  是否将列值转化为本地JavaScript类型值 （默认：<span class="literal">true</span>）</span><br><span class="line"></span><br><span class="line">queryFormat  自定义query语句格式化方法</span><br><span class="line"></span><br><span class="line">supportBigNumbers  数据库支持bigint或<span class="built_in">decimal</span>类型列时，需要设此option为<span class="literal">true</span> （默认：<span class="literal">false</span>）bigNumberStrings supportBigNumbers和bigNumberStrings启用 强制bigint或<span class="built_in">decimal</span>列以JavaScript字符串类型返回（默认：<span class="literal">false</span>）</span><br><span class="line"></span><br><span class="line">dateStrings  强制timestamp,datetime,<span class="built_in">data</span>类型以字符串类型返回，而不是JavaScript <span class="built_in">Date</span>类型（默认：<span class="literal">false</span>）</span><br><span class="line"></span><br><span class="line">debug  开启调试（默认：<span class="literal">false</span>）</span><br><span class="line"></span><br><span class="line">multipleStatements 是否许一个query中有多个MySQL语句 （默认：<span class="literal">false</span>）</span><br><span class="line"></span><br><span class="line">flags 用于修改连接标志</span><br><span class="line"></span><br><span class="line">ssl  使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.Node.js 连接 MongoDB：</p><p>MongoDB是一种文档导向数据库管理系统，由C++撰写而成。MongoDB 教程。 安装驱动</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm <span class="keyword">install</span> mongodb</span><br></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><blockquote><p>要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。<br>如果数据库不存在，MongoDB 将创建数据库并建立连接。</p></blockquote><p>创建连接</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">"mongodb://localhost:27017/mydb"</span>;</span><br><span class="line">  </span><br><span class="line">MongoClient.connect(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"数据库已创建!"</span>);</span><br><span class="line">  db.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>创建集合</p><blockquote><p>我们可以使用 createCollection() 方法来创建集合： 创建集合</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">'mongodb://localhost:27017/mydb'</span>;</span><br><span class="line">MongoClient.connect(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库已创建'</span>);</span><br><span class="line">    <span class="keyword">var</span> dbase = db.db(<span class="string">"mydb"</span>);</span><br><span class="line">    dbase.createCollection(<span class="string">'runoob'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"创建集合!"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>数据库操作( CURD )</p><blockquote><p>与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 插入数据 以下实例我们连接数据库</p></blockquote><blockquote><p>runoob 的 site 表，并插入两条数据：</p></blockquote><p>插入数据</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="keyword">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> DB_CONN_STR = <span class="string">'mongodb://localhost:27017/runoob'</span>; <span class="comment"># 数据库为 runoob</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> insertData = <span class="function"><span class="keyword">function</span><span class="params">(db, callback)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//连接到表 site</span></span><br><span class="line">    <span class="keyword">var</span> collection = db.collection(<span class="string">'site'</span>);</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    <span class="keyword">var</span> data = [&#123;<span class="string">"name"</span>:<span class="string">"菜鸟教程"</span>,<span class="string">"url"</span>:<span class="string">"www.runoob.com"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"菜鸟工具"</span>,<span class="string">"url"</span>:<span class="string">"c.runoob.com"</span>&#125;];</span><br><span class="line">    collection.insert(data, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            console.log(<span class="string">'Error:'</span>+ err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        callback(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(DB_CONN_STR, <span class="function"><span class="keyword">function</span><span class="params">(err, db)</span> </span>&#123;</span><br><span class="line">    console.log(<span class="string">"连接成功！"</span>);</span><br><span class="line">    insertData(db, <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span><br><span class="line">        console.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行以下命令输出就结果为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">node</span> <span class="string">test.js</span> <span class="string">//连接成功！</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#123;</span> <span class="attr">result:</span> <span class="string">&#123;</span> <span class="attr">ok:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">n:</span> <span class="number">2</span> <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  ops:</span> </span><br><span class="line">   <span class="string">[</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'菜鸟教程'</span><span class="string">,</span></span><br><span class="line"><span class="attr">       url:</span> <span class="string">'www.runoob.com'</span><span class="string">,</span></span><br><span class="line"><span class="attr">       _id:</span> <span class="number">58</span><span class="string">c25e13a08de70d3b9d4116</span> <span class="string">&#125;,</span></span><br><span class="line">     <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'菜鸟工具'</span><span class="string">,</span></span><br><span class="line"><span class="attr">       url:</span> <span class="string">'c.runoob.com'</span><span class="string">,</span></span><br><span class="line"><span class="attr">       _id:</span> <span class="number">58</span><span class="string">c25e13a08de70d3b9d4117</span> <span class="string">&#125;</span> <span class="string">],</span></span><br><span class="line"><span class="attr">  insertedCount:</span> <span class="number">2</span><span class="string">,</span></span><br><span class="line"><span class="attr">  insertedIds:</span> <span class="string">[58c25e13a08de70d3b9d4116,</span> <span class="number">58</span><span class="string">c25e13a08de70d3b9d4117]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>从输出结果来看，数据已插入成功。</p><p>我们也可以打开 MongoDB 的客户端查看数据，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> dbs</span><br><span class="line"></span><br><span class="line"><span class="keyword">admin</span>   <span class="number">0.000</span>GB</span><br><span class="line"><span class="keyword">local</span>   <span class="number">0.000</span>GB</span><br><span class="line">runoob  <span class="number">0.000</span>GB          <span class="comment"># 自动创建了 runoob 数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span></span><br><span class="line">site                     <span class="comment"># 自动创建了 site 集合（数据表）</span></span><br><span class="line"></span><br><span class="line">db.site.find()         <span class="comment"># 查看集合中的数据</span></span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"58c25f300cd56e0d7ddfc0c8"</span>), <span class="string">"name"</span> : <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span> : <span class="string">"www.runoob.com"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"58c25f300cd56e0d7ddfc0c9"</span>), <span class="string">"name"</span> : <span class="string">"菜鸟工具"</span>, <span class="string">"url"</span> : <span class="string">"c.runoob.com"</span> &#125;</span><br></pre></td></tr></table></figure><p>查询数据</p><p>以下实例检索 name 为 “菜鸟教程” 的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> DB_CONN_STR = <span class="string">'mongodb://localhost:27017/runoob'</span>;    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> selectData = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">//连接到表  </span></span><br><span class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'site'</span>);</span><br><span class="line">  <span class="comment">//查询数据</span></span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;</span><br><span class="line">  collection.find(whereStr).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error:'</span>+ err);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    callback(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(DB_CONN_STR, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"连接成功！"</span>);</span><br><span class="line">  selectData(db, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行以下命令输出就结果为：</p><blockquote><p>连接成功！</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; _id: <span class="number">58</span>c25f300cd56e0d7ddfc0c8,</span><br><span class="line">    name: <span class="symbol">'菜鸟教程</span>',</span><br><span class="line">    url: <span class="symbol">'www.runoob.com</span>' &#125; ]</span><br></pre></td></tr></table></figure><p>更新数据</p><p>我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 <a href="https://www.runoob.com：" target="_blank" rel="noopener">https://www.runoob.com：</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> DB_CONN_STR = <span class="string">'mongodb://localhost:27017/runoob'</span>;    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> updateData = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">//连接到表  </span></span><br><span class="line">    <span class="keyword">var</span> collection = db.collection(<span class="string">'site'</span>);</span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    collection.update(whereStr,updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error:'</span>+ err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        callback(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(DB_CONN_STR, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"连接成功！"</span>);</span><br><span class="line">    updateData(db, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>执行成功后，进入 mongo 管理工具查看数据已修改：</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.site</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"58c25f300cd56e0d7ddfc0c8"</span>), <span class="string">"name"</span> : <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"58c25f300cd56e0d7ddfc0c9"</span>), <span class="string">"name"</span> : <span class="string">"菜鸟工具"</span>, <span class="string">"url"</span> : <span class="string">"c.runoob.com"</span> &#125;</span><br></pre></td></tr></table></figure><p>删除数据</p><blockquote><p>以下实例将 name 为 “菜鸟工具” 的数据删除 :</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> DB_CONN_STR = <span class="string">'mongodb://localhost:27017/runoob'</span>;    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> delData = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">//连接到表  </span></span><br><span class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'site'</span>);</span><br><span class="line">  <span class="comment">//删除数据</span></span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟工具'</span>&#125;;</span><br><span class="line">  collection.remove(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error:'</span>+ err);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    callback(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(DB_CONN_STR, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"连接成功！"</span>);</span><br><span class="line">  delData(db, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行成功后，进入 mongo 管理工具查看数据已删除：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.site</span><span class="selector-class">.find</span>()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"58c25f300cd56e0d7ddfc0c8"</span>), <span class="string">"name"</span> : <span class="string">"菜鸟教程"</span>, <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http协议</title>
      <link href="//posts/6a5e2f06.html"/>
      <url>//posts/6a5e2f06.html</url>
      
        <content type="html"><![CDATA[<p><strong>HTTP 简介：</strong></p><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写</p><p>HTTP是因特网上应用最为广泛的一种网络传输协议，是一个无状态的请求/响应协议</p><p>HTTP是基于客户端/服务端（C/S）的架构模型</p><p>HTTP是一个基于TCP/IP通信协议来传递数据</p><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS默认HTTP的端口号为80，HTTPS的端口号为443</p><p><strong>HTTP的请求响应模型：</strong></p><p>HTTP协议永远都是客户端发起请求，服务器回送响应</p><p>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p><p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系</p><p><strong>HTTP 工作原理：</strong></p><p>HTTP协议工作于客户端-服务端架构上。浏览器作为Http客户端通过地址栏 Url将请求发送到Http服务端即Web服务器上。</p><p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等</p><p><strong>HTTP三点注意事项：</strong></p><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。<br>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p><strong>工作流程：</strong></p><p>一次完整的Http事务：<a href="http://blog.csdn.net/yipiankongbai/article/details/25029183" target="_blank" rel="noopener">http://blog.csdn.net/yipiankongbai/article/details/25029183</a></p><p>一次HTTP操作称为一个事务，其工作过程可分为六步：</p><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><p>域名解析 -&gt; 三次握手 -&gt; 建立连接 -&gt; 发送请求 -&gt; 响应请求 -&gt; 接收响应</p><p>任何一步发生错误，都会将错误信息返回到客户端</p><p>1）域名解析 ：将网站名称转变成IP地址：localhost–&gt;127.0.0.1 2）发起TCP的3次握手 ：</p><p>客户端发出一个SYN消息 -》</p><p>服务器使用SYN+ACK应答表示接收到了这个消息 -》</p><p>客户机再以ACK消息响应 -》</p><p>建立起可靠的TCP连接，数据传递</p><p>3）客户端与服务端建立连接</p><p>4）客户端发送请求给服务端，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p><p>5）服务端接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p><p>6）客户端接收服务端所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p><strong>HTTP请求方法：</strong></p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><p>GET 请求指定的页面信息，并返回实体主体。</p><p>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p><p>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p>PUT 从客户端向服务器传送的数据取代指定的文档的内容。</p><p>DELETE 请求服务器删除指定的页面。</p><p>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p>OPTIONS 允许客户端查看服务器的性能。</p><p>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p><p><strong>HTTP 响应头信息：</strong></p><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p><p>服务器支持哪些请求方法（如GET、POST等）。</p><p>Content-Encoding</p><p>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</p><p>Content-Length</p><p>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</p><p>Content-Type</p><p>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</p><p>Date</p><p>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</p><p>Expires</p><p>应该在什么时候认为文档已经过期，从而不再缓存它？</p><p>Last-Modified</p><p>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</p><p>Location</p><p>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</p><p>Refresh</p><p>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。" target="_blank" rel="noopener">http://host/path&quot;)让浏览器读取指定的页面。</a> </p><p>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。" target="_blank" rel="noopener">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a> </p><p>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 </p><p>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p><p>Server</p><p>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</p><p>Set-Cookie</p><p>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</p><p>WWW-Authenticate</p><p>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 </p><p>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</p><p><strong>HTTP状态码：</strong></p><p>下面是常见的HTTP状态码：</p><p>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误<br>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><p>1** 信息，服务器收到请求，需要请求者继续执行操作</p><p>2** 成功，操作被成功接收并处理</p><p>3** 重定向，需要进一步的操作以完成请求</p><p>4** 客户端错误，请求包含语法错误或无法完成请求</p><p>5** 服务器错误，服务器在处理请求的过程中发生了错误</p><p>HTTP content-type：<a href="http://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-content-type.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP3次握手</title>
      <link href="//posts/6a5e2f06.html"/>
      <url>//posts/6a5e2f06.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是http"><a href="#什么是http" class="headerlink" title="什么是http?"></a><a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">什么是http?</a></h2><p>为了提供可靠的传送，TCP在发送新的<a href="https://baike.baidu.com/item/数据" target="_blank" rel="noopener">数据</a>之前，以特定的顺序将数据包的序号，并需要这些包传送给目标机之后的确认消息。TCP总是用来发送大批量的<a href="https://baike.baidu.com/item/数据" target="_blank" rel="noopener">数据</a>。当<a href="https://baike.baidu.com/item/应用程序" target="_blank" rel="noopener">应用程序</a>在收到<a href="https://baike.baidu.com/item/数据" target="_blank" rel="noopener">数据</a>后要做出确认时也要用到TCP。</p><p>过程</p><p>第一次</p><p>第一次握手：建立连接时，<a href="https://baike.baidu.com/item/客户端" target="_blank" rel="noopener">客户端</a>发送<a href="https://baike.baidu.com/item/syn" target="_blank" rel="noopener">syn</a>包（syn=j）到<a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a>，并进入<a href="https://baike.baidu.com/item/SYN_SENT" target="_blank" rel="noopener">SYN_SENT</a>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次</p><p><a href="https://baike.baidu.com/item/第二次握手" target="_blank" rel="noopener">第二次握手</a>：<a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a>收到<a href="https://baike.baidu.com/item/syn" target="_blank" rel="noopener">syn</a>包，必须确认客户的SYN（<a href="https://baike.baidu.com/item/ack" target="_blank" rel="noopener">ack</a>=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入<a href="https://baike.baidu.com/item/SYN_RECV" target="_blank" rel="noopener">SYN_RECV</a>状态；</p><p>第三次</p><p>第三次握手：<a href="https://baike.baidu.com/item/客户端" target="_blank" rel="noopener">客户端</a>收到<a href="https://baike.baidu.com/item/服务" target="_blank" rel="noopener">服务</a>器的SYN+ACK包，向<a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a>发送确认包ACK(<a href="https://baike.baidu.com/item/ack" target="_blank" rel="noopener">ack</a>=k+1），此包发送完毕，客户端和服务器进入<a href="https://baike.baidu.com/item/ESTABLISHED" target="_blank" rel="noopener">ESTABLISHED</a>（TCP连接成功）状态，完成三次握手。</p>]]></content>
      
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>create-react-app(注意事项)</title>
      <link href="//posts/6a5e2f06.html"/>
      <url>//posts/6a5e2f06.html</url>
      
        <content type="html"><![CDATA[<h2 id="React-createClass-is-not-a-function"><a href="#React-createClass-is-not-a-function" class="headerlink" title="React.createClass is not a function"></a>React.createClass is not a function</h2><p>在React16以上，已经摒弃React.createClass()这个方法</p><p>取而代之的是<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>配置webpack</strong></p><p>前置条件(precondition)</p><ul><li><p><a href="https://link.jianshu.com/?t=https://reactjs.org/docs/installation.html" target="_blank" rel="noopener">Creating a New Application</a></p></li><li><p>安装yarn</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> yarn -g</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">install</span></span><br></pre></td></tr></table></figure></li><li><p>显示webpack配置</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> eject</span></span><br></pre></td></tr></table></figure></li><li><p>添加alias</p><p>可以根据项目自行配置</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">'react-native'</span>: <span class="string">'react-native-web'</span>, </span><br><span class="line">  <span class="string">'src'</span>:path.<span class="built_in">join</span>(<span class="variable">__dirname</span>, <span class="string">'..'</span>, <span class="string">'src'</span>), </span><br><span class="line">  <span class="string">'language'</span>:path.<span class="built_in">join</span>(<span class="variable">__dirname</span>, <span class="string">'..'</span>, <span class="string">'src/language'</span>), </span><br><span class="line">  <span class="string">'router'</span>:path.<span class="built_in">join</span>(<span class="variable">__dirname</span>, <span class="string">'..'</span>, <span class="string">'src/router'</span>), </span><br><span class="line">  <span class="string">'Modebase'</span>:path.<span class="built_in">join</span>(<span class="variable">__dirname</span>, <span class="string">'..'</span>, <span class="string">'src/Modebase'</span>), </span><br><span class="line">  <span class="string">'containers'</span>:path.<span class="built_in">join</span>(<span class="variable">__dirname</span>, <span class="string">'..'</span>, <span class="string">'src/containers'</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加cssnext(postcs)<br>一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。</p></li></ul><a id="more"></a><p><strong>修改webpack.config.dev.js添加postcss插件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attribute">loader</span>: require.<span class="built_in">resolve</span>(<span class="string">'postcss-loader'</span>), </span><br><span class="line">  options: &#123; </span><br><span class="line">    ident: <span class="string">'postcss'</span>, </span><br><span class="line">    plugins: () =&gt; [ </span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>), </span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>, </span><br><span class="line">      &#123; browsers: [<span class="string">'last 2 version'</span>] &#125;</span><br><span class="line">    ], </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webPack按需加载</strong></p><ul><li><p>添加react-router4</p><p>使用react-router-dom，参考<a href="https://link.jianshu.com/?t=http://blog.csdn.net/sinat_17775997/article/details/69218382" target="_blank" rel="noopener">初探 React Router 4.0</a></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-router-dom</span></span><br></pre></td></tr></table></figure></li><li><p>在react-router4中进行代码拆分</p><p>react-router升级到4后，便没有了getComponent这个参数。所以我们得换种方式，react-router4官方示例也提供了code splitting的方法，利用webpack结合bundle-loader，它是在require.ensure基础上封装的，更友好的实现异步加载过程。</p></li></ul><p><strong>添加Bundle.js组件</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">  constructor(props) &#123; </span><br><span class="line">    <span class="keyword">super</span>(props); </span><br><span class="line">    <span class="keyword">this</span>.state = &#123; mod: <span class="literal">null</span> &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">  load = props =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; mod: <span class="literal">null</span> &#125;); </span><br><span class="line">    props.load(mod =&gt; &#123; </span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; mod: mod ? mod : <span class="literal">null</span> &#125;); &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">    componentWillMount() &#123; </span><br><span class="line">    <span class="keyword">this</span>.load(<span class="keyword">this</span>.props); </span><br><span class="line">    &#125; </span><br><span class="line">    render() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.mod ? <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.mod) : <span class="literal">null</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用require.ensure()来进行模块的异步加载</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Bundle load=&#123;<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123; <span class="built_in">require</span>.ensure([], <span class="function"><span class="params">require</span> =&gt;</span> &#123; cb(<span class="built_in">require</span>(<span class="string">'containers/Buttons/containers'</span>).default); &#125;,<span class="string">'Buttons'</span>); &#125;&#125;&gt; &#123;<span class="function">(<span class="params">Buttons</span>) =&gt;</span> &lt;Buttons &#123;...props&#125;/&gt;&#125; &lt;<span class="regexp">/Bundle&gt;</span></span><br></pre></td></tr></table></figure><p><strong>webPack提取公共模块</strong></p><ul><li><p>首先把入口处改写为下面这样，把公共的方法提取出来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">entry</span>: &#123; </span><br><span class="line">  <span class="attribute">app</span>:[ </span><br><span class="line">    require.<span class="built_in">resolve</span>(<span class="string">'./polyfills'</span>), </span><br><span class="line">    paths.appIndexJs,</span><br><span class="line">    require.<span class="built_in">resolve</span>(<span class="string">'react-error-overlay'</span>), </span><br><span class="line">    require.<span class="built_in">resolve</span>(<span class="string">'react-dev-utils/webpackHotDevClient'</span>) </span><br><span class="line">  ], </span><br><span class="line">  vendor: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-router'</span>,<span class="string">'react-router-dom'</span>, <span class="string">'mobx'</span>, <span class="string">'mobx-react'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提取公共模块</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">webpack</span><span class="selector-class">.optimize</span><span class="selector-class">.CommonsChunkPlugin</span>(&#123; <span class="attribute">name</span>: <span class="string">'vendor'</span>, filename: <span class="string">'vendor.[hash:8].js'</span> &#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>Webpack DLL 用法</strong></p><p>Dll使用方法其实挺简单的。网上也有很多例子。</p><p>我遇到一些坑这里和大家说明一下</p><p>首先在主目录下面新建 webpack.dll.dev.js</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); </span><br><span class="line">const <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>); </span><br><span class="line">module.exports = &#123; </span><br><span class="line">  entry: &#123; </span><br><span class="line">    vendor: [<span class="built_in">path</span>.join(__dirname, <span class="string">'src'</span>, <span class="string">'vendor.js'</span>)], </span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="built_in">output</span>: &#123; </span><br><span class="line">    <span class="built_in">path</span>: <span class="built_in">path</span>.join(__dirname, <span class="string">'dll'</span>), </span><br><span class="line">    filename: <span class="string">'[name].js'</span>, </span><br><span class="line">    library: <span class="string">'[name]'</span>, </span><br><span class="line">  &#125;, </span><br><span class="line">    plugins: [ </span><br><span class="line">    new webpack.DllPlugin(&#123; <span class="built_in">path</span>: <span class="built_in">path</span>.join(__dirname, <span class="string">'dll'</span>, <span class="string">'[name]-manifest.json'</span>), filename: <span class="string">'[name].js'</span>, name: <span class="string">'[name]'</span>, &#125;), ] </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个Webpack文件主要的功能是在根目录生成dll文件夹。里面包含有vendor.js（index.html需要添加的js）和vendor-manifest.json （DllPlugin生成的json文件）</p><p>在主webpack文件里面通过DllReferencePlugin插件引用</p><p>然后再package.json里面添加</p><p>webpack –config webpack.dll.dev.js</p><p>然后在主webpack文件添加如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> manifest = <span class="built_in">require</span>(<span class="string">'../dll/vendor-manifest.json'</span>); plugins: [ <span class="keyword">new</span> webpack.DllReferencePlugin(&#123; manifest &#125;) ]</span><br></pre></td></tr></table></figure><p>下面就是dll比较坑的地方，如何在index.html中引入verdor.js呢。</p><p>首先我们思考直接在public底下的index.html中直接引用，这个dllplugin的包并不会被打进内存里，需要指定一个static目录</p><p>解决办法使用AddAssetHtmlPlugin</p><p>在htmlwebpack后插入一个AddAssetHtmlPlugin插件，用于将vendor插入打包后的页面 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">AddAssetHtmlPlugin</span>(&#123; <span class="attribute">filepath</span>: require.<span class="built_in">resolve</span>(<span class="string">'../dll/vendor.js'</span>), includeSourcemap: false &#125;)</span><br></pre></td></tr></table></figure><p>节省了近30S!!!</p><p><strong>使用UglifyJsPlugin压缩代码</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">webpack</span><span class="selector-class">.optimize</span><span class="selector-class">.UglifyJsPlugin</span>(&#123; <span class="attribute">compressor</span>: &#123; warnings: false, &#125; &#125;)</span><br></pre></td></tr></table></figure><p><strong>添加ANTD全局组件和css</strong></p><p><a href="https://www.jianshu.com/p/a46e30d7ef39" target="_blank" rel="noopener">修改webpack</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> create-react-app </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 脚手架工具（create-react-app）</title>
      <link href="//posts/a2043eea.html"/>
      <url>//posts/a2043eea.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在开发react应用时，应该没有人用传统的方法引入react的源文件(js)，然后在html编辑吧。</p><p>大家都是用webpack + es6来结合react开发前端应用。</p><p>这个时候，我们可以手动使用npm来安装各种插件，来从头到尾自己搭建环境。</p><p>比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span>react react-dom --save</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install </span><span class="keyword">babel </span><span class="keyword">babel-loader </span><span class="keyword">babel-core </span><span class="keyword">babel-preset-es2015 </span><span class="keyword">babel-preset-react </span>--save</span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install </span><span class="keyword">babel </span>webpack webpack-dev-server -g</span><br></pre></td></tr></table></figure><a id="more"></a><p>类似这样的脚手架，我扫了网络上比较多人用和关注的，一共发现了三个，它们分别是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">react-boilerplate</span><br><span class="line">react-redux-starter-kit</span><br><span class="line"><span class="function"><span class="title">create-react-app</span><span class="params">(facebook官方开发)</span></span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>安装和使用(默认监听3000端口)</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm </span><span class="string">install </span>-g <span class="built_in">create-react-app</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app/</span></span><br><span class="line"></span><br><span class="line"><span class="string">npm </span><span class="string">start</span></span><br></pre></td></tr></table></figure><p>源码结构简单清晰</p><p>如果你使用过webpack-dev-server或webpack搭建过开发环境，你就会发现，create-react-app的开发环境也有类似webpack-dev-server的–inline –hot自动刷新的功能。</p><p>翻看了一下源码，没有找到webpack.config.js文件，如果有使用webpack就应该有这个文件，好奇怪。</p><p>看了一下node_modules目录，也没找到webpack相关的东西。</p><p><strong>package.json</strong></p><p>package.json中也没有webpack相关的东西,但是在react-scripts中依赖了webpack</p><p><strong>线上编译命令</strong></p><p>编译出来的文件很小，且文件名还带hash值，方便我们做cache，而且它还提供一个服务器，让我们在本地也能看到线上生产环境类似的效果</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> build</span></span><br></pre></td></tr></table></figure><p>运行下面两条命令，可以查看线上生产环境的运行效果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g pushstate-<span class="keyword">server</span></span><br><span class="line"></span><br><span class="line">pushstate-<span class="keyword">server</span> <span class="keyword">build</span></span><br></pre></td></tr></table></figure><p><strong>api开发</strong></p><p>CORS问题:毕竟端口不同，而线上环境却没有这个问题，因为你都控制线上环境的react应用和api应用，跑在同一个端口上。</p><p>按照以往思路，解决的方法可能是用环境变量，比如</p><p>const apiBaseUrl = process.env.NODE_ENV === ‘development’ ? ‘localhost:3001’ : ‘/‘</p><p>但是这样搞起来，还是有些复杂，然而，create-react-app提供了一个超级简单的方法，只需要在package.json文件中，加一个配置项就可以了。</p><p>“proxy”: “<a href="http://localhost:3001/&quot;" target="_blank" rel="noopener">http://localhost:3001/&quot;</a>,</p><p>执行npm run eject 暴露配置文件等</p><p><strong>报错解决方案：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先执行git <span class="builtin-name">add</span> . 和 git commit -m <span class="string">"init"</span> 在执行 npm <span class="builtin-name">run</span> eject</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> create-react-app </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>devops是什么</title>
      <link href="//posts/cfdabafc.html"/>
      <url>//posts/cfdabafc.html</url>
      
        <content type="html"><![CDATA[<p><strong>DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</strong></p><p><a href="https://www.leiue.com/tags/devops" target="_blank" rel="noopener">DevOps</a>（Development 和 Operations 的组合词）是一种重视“<a href="https://www.leiue.com/tags/软件开发" target="_blank" rel="noopener">软件开发</a>人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s1.ax1x.com/2020/09/09/w3gMZ9.png" alt></p><p>传统的软件组织将开发、IT 运营和质量保障设为各自分离的部门，在这种环境下如何采用新的开发方法（例如敏捷软件开发），是一个重要的课题。按照从前的工作方式，开发和部署，不需要 IT 支持或者 QA 深入的跨部门的支持；而现在却需要极其紧密的多部门协作。而 DevOps 考虑的还不止是软件部署，它是一套针对这几个部门间沟通与协作问题的流程和方法。</p><p>需要频繁交付的企业可能更需要对 DevOps 有一个大致的了解。Flickr 发展了自己的 DevOps 能力，使之能够支撑业务部门“每天部署 10 次”的要求，如果一个组织要生产面向多种用户、具备多样功能的应用程序，其部署周期必然会很短。这种能力也被称为持续部署，并且经常与精益创业方法联系起来。从 2009 年起，相关的工作组、专业组织和博客快速涌现。</p><p>DevOps 的引入能对产品交付、测试、功能开发和维护（包括──曾经罕见但如今已屡见不鲜的──“热补丁”）起到意义深远的影响。在缺乏 DevOps 能力的组织中，开发与运营之间存在着信息“鸿沟”──例如运营人员要求更好的可靠性和安全性，开发人员则希望基础设施响应更快，而业务用户的需求则是更快地将更多的特性发布给最终用户使用。这种信息鸿沟就是最常出问题的地方。</p><p>以下几方面因素可能促使一个组织引入 DevOps：</p><ul><li>使用敏捷或其他软件开发过程与方法</li><li>业务负责人要求加快产品交付的速率</li><li>虚拟化和云计算基础设施（可能来自内部或外部供应商）日益普遍</li><li>数据中心自动化技术和配置管理工具的普及</li><li>有一种观点认为，当前占主导地位的“传统”美国式管理风格（“斯隆模型 vs 丰田模型”）会导致“烟囱式自动化”，从而造成开发与运营之间的鸿沟，因此需要 DevOps 能力来克服由此引发的问题。</li></ul><p>DevOps 经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题集锦（1）</title>
      <link href="//posts/714f78f3.html"/>
      <url>//posts/714f78f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是跨域？跨域请求资源的方法有哪些？"><a href="#什么是跨域？跨域请求资源的方法有哪些？" class="headerlink" title="什么是跨域？跨域请求资源的方法有哪些？"></a>什么是跨域？跨域请求资源的方法有哪些？</h2><p>1、什么是跨域？<br>由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：<br>网络协议不同，如http协议访问https协议。<br>端口不同，如80端口访问8080端口。<br>域名不同，如qianduanblog.com访问baidu.com。<br>子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。<br>域名和域名对应ip,如<a href="http://www.a.com访问20.205.28.90" target="_blank" rel="noopener">www.a.com访问20.205.28.90</a>.<br>2、跨域请求资源的方法：<br>(1)、porxy代理<br>定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。<br>实现方法：通过nginx代理；<br>注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。<br>(2)、CORS 【Cross-Origin Resource Sharing】<br>定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。<br>使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"text/html; charset=UTF-8"</span>,</span><br><span class="line">    <span class="string">"Access-Control-Allow-Origin"</span>:<span class="symbol">'http</span>://localhost',</span><br><span class="line">    <span class="symbol">'Access</span>-Control-Allow-Methods': <span class="symbol">'GET</span>, POST, OPTIONS',</span><br><span class="line">    <span class="symbol">'Access</span>-Control-Allow-Headers': <span class="symbol">'X</span>-Requested-<span class="keyword">With</span>, Content-<span class="keyword">Type</span>'</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>(3)、jsonp<br>定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。<br>特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。<br>实例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">testjsonp</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(data.name); <span class="comment">// 获取返回的结果</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    _script.type = <span class="string">"text/javascript"</span>;</span></span><br><span class="line"><span class="actionscript">    _script.src = <span class="string">"http://localhost:8888/jsonp?callback=testjsonp"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(_script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>缺点：<br>　　1、这种方式无法发送post请求（这里）<br>　　2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。</p><a id="more"></a><h2 id="介绍一下-JS-的基本数据类型。"><a href="#介绍一下-JS-的基本数据类型。" class="headerlink" title="介绍一下 JS 的基本数据类型。"></a>介绍一下 JS 的基本数据类型。</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Undefined</span>、<span class="keyword">Null</span>、Boolean、<span class="keyword">Number</span>、<span class="keyword">String</span></span><br></pre></td></tr></table></figure><h2 id="如何利用JavaScript实现一个自定义事件，存在on，off，emit三个方法？"><a href="#如何利用JavaScript实现一个自定义事件，存在on，off，emit三个方法？" class="headerlink" title="如何利用JavaScript实现一个自定义事件，存在on，off，emit三个方法？"></a>如何利用JavaScript实现一个自定义事件，存在on，off，emit三个方法？</h2><p>这个题目的意义在哪里？我想，应该是对于一些特定的业务逻辑，比如在注册一个“通知”的事件，在与Native交互之后，假设这个交互是在入口级别的页面里，那么如何发送给具体某个业务呢？事件应该是最简单的一种方式，在某个具体的业务中注册一个事件，然后在与Native交互完，拿到某些数据后，然后触发这个事件。</p><p>我们来一步一步实现一个最简单的事件类Event，不考虑任何其他复杂的情况。假设在这个Event类的内部有一个this._events = [] 数组来维系整个事件系统，我们分别实现on，off，emit三个方法即可。</p><p>on（注册一个事件）：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Event.prototype.on = function(type,<span class="function"><span class="keyword">fun</span>)&#123;</span></span><br><span class="line">    let cbs = <span class="keyword">this</span>._events[type];</span><br><span class="line">    cbs ? cbs.push(<span class="function"><span class="keyword">fun</span>) : this._events[type] = [];</span></span><br><span class="line">        <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">            <span class="keyword">this</span>._events[type].push(<span class="function"><span class="keyword">fun</span>)</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里为什么要将this._events设计为二维数组？因为事件可以是多个，但是事件名可能相同。这个逻辑意图非常的明显，根据type参数从this._events中获取是否存在。如果不存在，创建一个type为key的数组，并将事件句柄程序push到数组中。</p><p>off（注销一个事件）：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Event.prototype.off = function (<span class="keyword">type</span>, <span class="function"><span class="keyword">fun</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="title">let</span></span> cbs = this._events[<span class="keyword">type</span>];</span><br><span class="line">    /<span class="regexp">/事件列队中无事件</span></span><br><span class="line"><span class="regexp">    if (!cbs) &#123;</span></span><br><span class="line"><span class="regexp">      return this;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/删除所有的事件</span></span><br><span class="line"><span class="regexp">    if (!event &amp;&amp; !fun) &#123;</span></span><br><span class="line"><span class="regexp">      this._events = &#123;&#125;;</span></span><br><span class="line"><span class="regexp">      return this;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/只有事件名称时</span></span><br><span class="line"><span class="regexp">    if (event &amp;&amp; !fun) &#123;</span></span><br><span class="line"><span class="regexp">      this._events[type] = null;</span></span><br><span class="line"><span class="regexp">      return this;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/删除某个事件队列中的某个事件</span></span><br><span class="line"><span class="regexp">    let cb;</span></span><br><span class="line"><span class="regexp">    let i = cbs.length;</span></span><br><span class="line"><span class="regexp">    while (i--) &#123;</span></span><br><span class="line"><span class="regexp">      cb = cbs[i];</span></span><br><span class="line"><span class="regexp">      if (cb === fun || cb.fun === fun) &#123;</span></span><br><span class="line"><span class="regexp">        cbs.splice(i, 1);</span></span><br><span class="line"><span class="regexp">        break;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure></p><p>虽然注销事件方法的逻辑可能相比之下稍许多了些，但它的实现也非常简单，只要只存在事件组key名的情况，或者删除某个事件队列中的某个事件句柄程序即可。</p><p>emit（触发一个事件）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Event.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">let</span> cbs = <span class="keyword">this</span>._events[<span class="keyword">type</span>];    </span><br><span class="line">    <span class="keyword">let</span> args = tools.toArray(<span class="built_in">arguments</span>,<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;        </span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">let</span> j = cbs.length;        </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++)&#123;            </span><br><span class="line">            <span class="keyword">let</span> cb = cbs[i];            </span><br><span class="line">            cb.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逻辑依然非常简单，通过事件名从this._events获取相应的事件句柄程序数组，然后将arguments转成数组，（这里考虑的是可能会传入参数）如果事件句柄程序数组存在，进行循环，再讲args参数apply给每一个取出来的事件句柄程序。</p><p>##请描述一个网页从开始请求道最终显示的完整过程？<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个网页从请求到最终显示的完整过程一般可以分为如下<span class="number">7</span>个步骤：</span><br><span class="line">（<span class="number">1</span>）在浏览器中输入网址；</span><br><span class="line">（<span class="number">2</span>）发送至DNS服务器并获得域名对应的WEB服务器IP地址；</span><br><span class="line">（<span class="number">3</span>）与WEB服务器建立TCP连接；</span><br><span class="line">（<span class="number">4</span>）浏览器向WEB服务器的IP地址发送相应的HTTP请求；</span><br><span class="line">（<span class="number">5</span>）WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址；</span><br><span class="line">（<span class="number">6</span>）浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面；</span><br><span class="line">（<span class="number">7</span>）分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部数据显示。</span><br></pre></td></tr></table></figure></p><h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。</span><br><span class="line">这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。</span><br><span class="line">（<span class="number">1</span>）与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概<span class="number">5</span>M左右。</span><br><span class="line">（<span class="number">2</span>）LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。</span><br><span class="line">LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；</span><br><span class="line">sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。</span><br><span class="line">注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。</span><br><span class="line">（<span class="number">3</span>）使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。</span><br></pre></td></tr></table></figure><h2 id="说说js中的event-loop机制？"><a href="#说说js中的event-loop机制？" class="headerlink" title="说说js中的event loop机制？"></a>说说js中的event loop机制？</h2><p>首先javascript是单线程机制，就是指当我们在执行一个任务的时候，其它的事情都得等待他执行完毕</p><p>在js中所有任务分为两种, 同步任务及异步任务</p><p>执行栈执行主线程任务，当有操作dom，ajax交互，使用定时器异步操作的时候，这些任务会被移入到 callback queue 任务队列中<br>当主线程任务执行完毕为空时，会读取callback queue队列中的函数，进入主线程执行<br>上述过程会不断重复，也就是常说的Event Loop(事件循环)</p><p>在一个事件循环中,异步任务返回结果后会被扔进一个任务列队中，根据异步事件上的类型，这个事件会被放到对应的宏任务或者微任务列队中去， 当执行栈为空的时候，主线程会先查看微任务中的事件列队，<strong>如果微任务不是空先依次执行微任务</strong>，<strong>如果是空的再去宏任务列队中取出一个事件并把对应的回调加入到当前执行栈</strong>，如此反复，进入循环</p><p>下面用一道题来加深印象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then( <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出的结果是<span class="number">2</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>定时器是宏任务，Promise是异步的是微任务。所以先执行微任务 <code>console.log(2)</code>,在执行宏任务<code>console.log(1)</code></p><h2 id="怎么理解js中的内存泄漏"><a href="#怎么理解js中的内存泄漏" class="headerlink" title="怎么理解js中的内存泄漏?"></a>怎么理解js中的内存泄漏?</h2><p>内存泄漏的定义为当程序不再需要的内存，由于某种原因其不会返回到操作系统或可用内存池，内存泄漏会导致一系列问题，比如: 运行缓阳，崩溃，高延迟等</p><p>js中常见的内存泄露:</p><p>1、意外的全局变量</p><p>2、遗忘的计时器或回调函数</p><p>3、脱离文档的DOM引用</p><p>4、闭包</p><h2 id="怎么理解js中是原型链-如何实现继承"><a href="#怎么理解js中是原型链-如何实现继承" class="headerlink" title="怎么理解js中是原型链? 如何实现继承?"></a>怎么理解js中是原型链? 如何实现继承?</h2><ul><li><p>每个构造函数都有一个原型对象</p></li><li><p>每个原型对象都包含一个指向构造函数的指针</p></li><li><p>每个实例都包含一个指向原型对象的指针</p></li><li><p>查找方式是一层层向上查找直至顶层Object.prototype</p></li></ul><p><strong>实现继承的方式常用的有:</strong></p><ul><li><p>原型链继承</p></li><li><p>借用构造函数(call,apply)</p></li><li><p>组合继承(原型链＋构造函数)</p></li><li><p>原型式继承</p></li><li><p>寄生式组合式继承</p></li></ul><h2 id="new-运算符具体干了什么"><a href="#new-运算符具体干了什么" class="headerlink" title="new 运算符具体干了什么?"></a>new 运算符具体干了什么?</h2><p>1、创建一个空的对象</p><p>2、将空的对象的proto成员指向构造函数的prototype成员对象</p><p>3、调用构造函数将this指向前面创建的对象</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章置顶</title>
      <link href="//posts/7a527409.html"/>
      <url>//posts/7a527409.html</url>
      
        <content type="html"><![CDATA[<p>文章的Front-matter填写<code>top: true</code>就置顶了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>这是一个示例博客。源码目录：<a href="https://github.com/xaoxuu/blog-example" target="_blank" rel="noopener">https://github.com/xaoxuu/blog-example</a></p><a id="more"></a><p><img class="emoji tieba" src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/tieba/捂嘴笑.png">没有更多了哦。</p>]]></content>
      
      
      <categories>
          
          <category> 博客文档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>less在vue中的使用</title>
      <link href="//posts/8136685c.html"/>
      <url>//posts/8136685c.html</url>
      
        <content type="html"><![CDATA[<h1 id="less在vue中的使用"><a href="#less在vue中的使用" class="headerlink" title="less在vue中的使用"></a>less在vue中的使用</h1><p>首先vue环境搭建成功</p><h2 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h2><p><strong>安装 less 和less-loader</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装<span class="keyword">less</span>依赖：npm <span class="keyword">install</span> <span class="keyword">less</span> <span class="keyword">less</span>-loader --save</span><br></pre></td></tr></table></figure><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p><strong>修改webpack.base.config.js文件，配置loader加载依赖，让其支持外部的less,在原来的代码上添加</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种方法在控制台中标签样式显示的是style标签样式</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="symbol">    test:</span> /\.less$/,</span><br><span class="line"></span><br><span class="line"><span class="symbol">    loader:</span> <span class="string">"style-loader!css-loader!less-loader"</span>,</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">可以在控制台中看到当前标签样式来自于哪个less文件</span></span><br><span class="line"><span class="string">&#123;</span> </span><br><span class="line"><span class="attr">    test:</span> <span class="string">/\.less$/,</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    loader:</span> <span class="string">"style-loader!css-loader!less-loader"</span><span class="string">,</span></span><br><span class="line">　　　　 <span class="attr">options:</span> <span class="string">&#123;</span> <span class="attr">sourceMap:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img2018.cnblogs.com/blog/1281517/201902/1281517-20190220094624448-2102626446.png" alt></p><h2 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h2><p><strong>在vue文件中的style标签中添加lang=”less”即可在标签中使用less，或者外部引入less</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img2018.cnblogs.com/blog/1281517/201902/1281517-20190220095032656-1323519047.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> less </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言的安装</title>
      <link href="//posts/7b1282c0.html"/>
      <url>//posts/7b1282c0.html</url>
      
        <content type="html"><![CDATA[<p>go语言的安装</p>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>microsoft vs code换主题</title>
      <link href="//posts/e8b3e153.html"/>
      <url>//posts/e8b3e153.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>01、菜单选择 -&gt; 参考下图</p></li><li><p>02、对话框说明 -&gt; 参考下图</p></li></ul><a id="more"></a><h2 id="01、菜单选择-gt-参考下图"><a href="#01、菜单选择-gt-参考下图" class="headerlink" title="01、菜单选择 -&gt; 参考下图"></a>01、菜单选择 -&gt; 参考下图</h2><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20190802095136432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnhpODY5Mw==,size_16,color_FFFFFF,t_70" alt></p><h2 id="02、对话框说明-gt-参考下图"><a href="#02、对话框说明-gt-参考下图" class="headerlink" title="02、对话框说明 -&gt; 参考下图"></a>02、对话框说明 -&gt; 参考下图</h2><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20190802095441113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnhpODY5Mw==,size_16,color_FFFFFF,t_70" alt></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microsoft vs code常用主题收集</title>
      <link href="//posts/230490ec.html"/>
      <url>//posts/230490ec.html</url>
      
        <content type="html"><![CDATA[<p>页面太白不喜欢，黑色又太压抑怎么办？</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20190814164734204.gif" alt></p><a id="more"></a><p>Slack Theme（本人很喜欢）</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20190814163032334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3NjMzMjI=,size_16,color_FFFFFF,t_70" alt></p><p>cozygreen（近视眼必备&lt;(▰˘◡˘▰)&gt;）</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20190814163551655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3NjMzMjI=,size_16,color_FFFFFF,t_70" alt></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode汉化教程</title>
      <link href="//posts/e8b3e153.html"/>
      <url>//posts/e8b3e153.html</url>
      
        <content type="html"><![CDATA[<p>VSCODE默认情况下是英文的。</p><p>相关推荐：《<a href="https://www.php.cn/tool/vscode/" target="_blank" rel="noopener">vscode使用教程</a>》</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img.php.cn/upload/image/885/406/534/1573182893262296.png" alt></p><p>点击左侧菜单栏最底下的四方形按钮打开扩展程序界面，在输入框内输入Chinese并找到【Chinese (Simplified) Language Pack for Visual Studio Code】这个插件。在这个插件的详细界面点击【Install】按钮进行安装。</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img.php.cn/upload/image/997/371/924/1573182897206223.png" alt></p><p>安装完成后按快捷键【CTRL+SHILF+P】打开命令面板并输入【config】后找到【Configure Display Language】选项并点击。</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img.php.cn/upload/image/193/319/631/1573182901159705.png" alt></p><p>在接下来的二级菜单选择【zh-cn】，此时编辑器会弹出个访问窗口是否要重启编辑器生效语言的修改，点击【restart】按钮重新启动编辑器。</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img.php.cn/upload/image/182/992/751/1573182905475148.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img.php.cn/upload/image/182/992/751/1573182905475148.png" alt></p><p>重启编辑器后就汉化成中文成功了</p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://img.php.cn/upload/image/747/248/313/1573182909976081.png" alt></p><p>以上就是vscode如何汉化的详细内容</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是前端工程化</title>
      <link href="//posts/b4383892.html"/>
      <url>//posts/b4383892.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端工程化是现代前端的必备技能"><a href="#前端工程化是现代前端的必备技能" class="headerlink" title="前端工程化是现代前端的必备技能"></a>前端工程化是现代前端的必备技能</h2><p>快狗打车前端团队为例。</p><p>前端的开发框架以 Vue 为主，使用 Webpack 解决接口 mock、代码检查、代码编译、构建、压缩、添加版本号、部署等全流程的工作。涉及到的技术点有 Vue、Vuex、ESlint、stylelint、mock、Webpack、Sass、PostCSS 等。对前端的要求相比几年前已经从单纯的 JS、CSS 问题变成了更多工程化为主的问题。</p><p>前端工程化是一个很大的话题，甚至到现在都没有一个准确的定义。笔者对前端工程化的理解是：<strong>一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化。</strong></p><a id="more"></a><h2 id="实现前端工程化的好处"><a href="#实现前端工程化的好处" class="headerlink" title="实现前端工程化的好处"></a>实现前端工程化的好处</h2><p>在前端领域越来越繁荣，越来越复杂的今天，<strong>学习前端工程化又能给我们带来哪些好处呢</strong>？</p><p><strong>1. 极大提升开发效率</strong></p><p>前端工程化的演进可以极大地提升开发效率。前端发展到现在，社区涌现出大量的优秀框架和工具，得以将前端工程师从繁重的工作中解脱出来。</p><p>举个例子，同样地给一个 dom 元素绑定一个 click 事件，使用纯 JS 可能这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myDom'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们引入 jQuery 的情况下，就简单了许多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#myDom'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果在 Vue 中，既简单又清晰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">"doSomething"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  doSomething: function () &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ do some thing</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果有大量的事件绑定，没有开发工具的支撑，将有大量重复的代码需要写，想想就头疼。效率之低下可见一斑。</p><p>为了减少请求数，前端开发者通常会把大量尺寸较小、细碎的小图片合并成一张大的透明的雪碧图，在 CSS 中通过设置元素的 background-position 来使用图片。如果是完全手动去拼图、测距，将耗费大量的时间。但在雪碧图插件 webpack-spriteSmith 的帮助下，小图可以自动拼成雪碧图，并生成对应的 CSS 样式，插件能帮助我们处理这种毫无技术含量的体力活，效率加倍。</p><p>再举一个例子，没有前端脚手架的情况下，如果从零开发一个项目，需要花费大量的时间去初始化项目，比如安装各种 npm 包、配置各种 Webpack 的 loader、配置热加载。如果碰到环境搭建不顺利的情况，还需要花费很长时间去排查问题，单单一个项目初始化的动作就足以耗费一两天的时间。有脚手架工具的情况下，只需要简单的一个初始化命令，2 分钟的时间就可以完成项目的初始化。前端只需要聚焦到业务开发本身，效率大幅提升。</p><p><strong>2. 降低大型项目的开发难度</strong></p><p>首先前端工程化中提倡模块化、组件化。模块化的思想将大型项目的功能进行分解，分拆成一个个独立的模块。每个模块的开发难度直线下降。同时基于版本控制工具 Git，多个开发者可以并行开发，提升开发效率。项目在后期迭代的时候，由于每个模块相对独立，耦合性极低，一个功能的调整往往只需要修改其中的一个模块就可以，风险可控。不至于出现改动一处代码，引发全局问题的情况。</p><p>其次，前端工程化提倡用完善的流程规范和代码规范来保证大型应用的质量和可维护性。比如通过 ESlint、stylelint 对代码进行自动校验，通过评审、详细设计、开发、联调、测试、上线等每个环节的控制，确保项目的高质量和按时交付。向主分支合并代码必须经过 code review。流程规范确保了大型项目质量和可维护性的同时能够如期交付。</p><p><strong>更易获得面试官青睐</strong></p><p>依稀记得六七年前去面试，遇到面试题大概是这种风格：“如何实现水平垂直居中”，“js 事件委托的原理是什么”，“常见的 css hack 方式有什么？”，“$(function(){})与 window.onload 有什么区别？”</p><p>今天面试遇到的面试题大概是这种风格：“能讲下 Vue 实现双向数据绑定的原理吗？”，“Webpack 中如何配置 Babel？”，“promise 和 await/async 的区别是什么？”</p><p>如果想进入大公司工作，前端工程化更是需要具备的基本素质。大公司的业务往往非常复杂，而且对稳定性的要求极高。与之相对应的前端工程化程度很高，各种配套的基础建设很成熟。比如美团点评体系化的工程化方案、移动组件库 Vix、自动化测试工具 Freekite、Hybrid 功能体验的解决方案 Titans 等。想得到这些公司的青睐，候选人需要在前端工程化领域有较深的积累。</p><p>前端的岗位技能已经发生深刻的变化。有人甚至戏言成前端工程师为前端配置工程师。</p><p>fouber（张云龙）曾经在自己的博文中说：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"前端是一种技术问题较少、工程问题较多的软件开发领域。”</span></span><br></pre></td></tr></table></figure><p>所以前端工程化是每个现代前端人应该必备的技能。</p><h3 id="谁需要前端工程化？"><a href="#谁需要前端工程化？" class="headerlink" title="谁需要前端工程化？"></a>谁需要前端工程化？</h3><p><strong>3. 初中级前端工程师</strong></p><p>对于初级中级前端工程师来说，由于工作经验较少，技术的宽度和广度都不足，对前端工程化的认知其实也是不够的，一上来整体掌握前端工程化肯定是有困难的。对于这部分同学来讲，首要的事情要学会去”用”，循序渐进地去了解其中的原理。例如在开发之余，自己学一学如何实现一个简单的脚手架工具，了解一下日常开发必备的脚手架是如何实现的，以点带面地学习里面用到的技术点。</p><p><strong>期望晋升的前端工程师</strong></p><p>前端工程化能力也是一个资深前端的必备技能。工作好多年了，如果连前端工程化都知之甚少，甚至连一个基本的脚手架都不能自己搭建，这是不及格的。如果将来带团队，怎么能指导团队同学，怎么能带领团队进步呢？如果去参加公司的晋升，也是没有说服力的。因为想要晋升高 T，必然需要在效率和性能优化等方面有深厚的积累和贡献。</p><p>所以，<strong>无论你是处在什么阶段，深入了解一下前端工程化都是极有必要的</strong>。</p><p>前端应用越来越复杂，对前端工程化的要求越来越高。脚手架作为目前前端工程化的一个重要的组成部分，在开发过程中扮演了至关重要的角色。现在几乎所有主流前端几框架都有自己配套的脚手架，无疑给开发者带来了极大的便利。但正如上文所述，很多开发者由于本身入行较短，或者很多工作多年的开发者由于公司业务的原因，没有机会接触到前端工程化领域。</p><h3 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h3><p><a href="https://gitchat.csdn.net/columnTopic/5d0c6f33820bf61799b753a3?utm_source=so" target="_blank" rel="noopener">开篇词：到底什么是前端工程化</a></p><p>第一部分：模板设计</p><p><a href="https://gitchat.csdn.net/columnTopic/5d0c6f64820bf61799b753a4?utm_source=so" target="_blank" rel="noopener">第01课：模板功能设计</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7596820bf61799b753d2?utm_source=so" target="_blank" rel="noopener">第02课：Webpack 基本介绍</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c77c3820bf61799b753e1?utm_source=so" target="_blank" rel="noopener">第03课：搭建项目模板框架</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7af9820bf61799b753ec?utm_source=so" target="_blank" rel="noopener">第04课：前端模块化解决方案</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7b27820bf61799b753ed?utm_source=so" target="_blank" rel="noopener">第05课：搭建本地开发环境</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7b47820bf61799b753ee?utm_source=so" target="_blank" rel="noopener">第06课：搭建本地 Mock 服务</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7b69820bf61799b753ef?utm_source=so" target="_blank" rel="noopener">第07课：引入代码检查工具</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bd6820bf61799b75404?utm_source=so" target="_blank" rel="noopener">第08课：自动生成雪碧图</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第09课：根据浏览器构建</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第10课：根据环境构建</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第11课：集成移动端调试工具</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第12课：引入单元测试</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第13课：引入 e2e 测试</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第14课：Webpack 构建性能优化</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第15课：添加部署功能</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第16课：聚合项目配置并模板化</a></p><p>第二部分：命令行设计</p><p><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第17课：cli 功能设计（上）</a><br><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">第18课：cli 功能设计（下）</a></p><p><a href="https://gitchat.csdn.net/columnTopic/5d0c7bfb820bf61799b75406?utm_source=so" target="_blank" rel="noopener">结语：开放的心态才是更高阶的工程化</a></p><p>学完后至少有以下几点收获：</p><ul><li>对前端工程化有一个系统认知；</li><li>能独立设计一套前端工程化解决方案；</li><li>知识广度上有大幅提升；</li><li>进入更好的平台，获得更好的薪酬。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack依赖加载cdn配置</title>
      <link href="//posts/f8a3109a.html"/>
      <url>//posts/f8a3109a.html</url>
      
        <content type="html"><![CDATA[<h1 id="CDN服务商的选择"><a href="#CDN服务商的选择" class="headerlink" title="CDN服务商的选择"></a>CDN服务商的选择</h1><p>要使用cdn功能，就需要cdn服务商，我们可以自己搭建，也可以使用一些比较知名的服务商，庆幸的是市面上有不少的免费cdn服务商，如：</p><ul><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bootcdn.cn%2F" target="_blank" rel="noopener">BootCDN</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Funpkg.com%2F" target="_blank" rel="noopener">unpkg</a></li></ul><p>其中BootCDN 是 Bootstrap 中文网支持并维护的前端开源项目免费 CDN 服务，项目资源同步于 cdnjs 仓库。界面相对比较好看，且支持搜索功能，可以在线测试cdn是否正常，所以下面以Bootcdn为例说明。</p><h1 id="webpack的作用"><a href="#webpack的作用" class="headerlink" title="webpack的作用"></a>webpack的作用</h1><p>在前段项目开发中，我们经常使用webpack进行项目搭建， 主要作用有两个，分别是</p><p>1.启动服务器环境，用于调试代码</p><p>2.构建项目，生成静态资源</p><p>在webpack中使用cdn是在打包生成静态资源的时候做处理，主要原理是使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fhtml-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a>动态插入cdn链接。</p><p><em>关于webpack的使用这里不做过多的介绍，将以vue–cli 2.x生成的默认项目为例做介绍</em></p><a id="more"></a><h1 id="html-webpack-plugin的使用"><a href="#html-webpack-plugin的使用" class="headerlink" title="html-webpack-plugin的使用"></a>html-webpack-plugin的使用</h1><p><code>html-webpack-plugin</code>是webpack的一个插件，可以动态的创建和编辑html内容，在html中使用<code>esj语法</code>可以读取到配置中的参数，简化了html文件的构建。</p><p>我们这次主要是使用它来动态插入cdn链接，如link标签和script标签。</p><h1 id="创建Vue项目"><a href="#创建Vue项目" class="headerlink" title="创建Vue项目"></a>创建Vue项目</h1><h2 id="vue-cli-2-x"><a href="#vue-cli-2-x" class="headerlink" title="vue-cli 2.x"></a><em>vue-cli 2.x</em></h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue init webpack webpack-cdn-demo</span></span><br></pre></td></tr></table></figure><p>创建名为<code>webpack-cdn-demo</code>，类型为webpack的<code>vue</code>项目，如果安装的vue-cli是3.x版本，命令不太一样，详细可看<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fguide%2Fcreating-a-project.html%23vue-create" target="_blank" rel="noopener">vue-cli 3</a>。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span>  webpack-cdn-demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm  install</span></span><br></pre></td></tr></table></figure><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">run</span><span class="bash"> dev</span></span><br></pre></td></tr></table></figure><p><strong>目录结构</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-- build</span></span><br><span class="line">|  +<span class="comment">-- utils.js js 工具类</span></span><br><span class="line">|  +<span class="comment">-- webpack.base.conf.js  webpack基础配置</span></span><br><span class="line">|  +<span class="comment">-- webpack.dev.conf.js  webpack开发配置</span></span><br><span class="line">|  +<span class="comment">-- webpack.prod.conf.js  webpack构建配置</span></span><br><span class="line">+<span class="comment">-- config</span></span><br><span class="line">+<span class="comment">-- src</span></span><br><span class="line">|  +<span class="comment">-- App.vue  vue文件组件</span></span><br><span class="line">|   +<span class="comment">-- main.js  入口文件</span></span><br><span class="line">+<span class="comment">-- index.html  页面</span></span><br><span class="line">+<span class="comment">-- package.json  项目文件</span></span><br></pre></td></tr></table></figure><p>其中build文件夹中的<code>webpack.prod.conf.js</code>是我们主要注意的文件,我们在该文件中动态设置不需要被打包的模块并构建出合适的链接。</p><h1 id="确定需要使用CDN的模块"><a href="#确定需要使用CDN的模块" class="headerlink" title="确定需要使用CDN的模块"></a>确定需要使用CDN的模块</h1><p>在webpack项目中，所引入的第三方资源会被统一打包进vender文件中，我们通过webpack的<code>externals</code>属性可以设置打包时排除该模块，详情说明见<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fexternals%2F" target="_blank" rel="noopener">外部扩展(externals)</a>。</p><p>在前面的步骤中，我们创建的项目包括vue、vue-router，在正式开发在还会有ui库，如element-ui，为了方便演示，我们再安装element-ui和axios两个模块，并实现在构建是把这是个模块以cdn的形式引入。</p><table><thead><tr><th style="text-align:center">所需模块</th></tr></thead><tbody><tr><td style="text-align:center">vue</td></tr><tr><td style="text-align:center">vue-router</td></tr><tr><td style="text-align:center">element-ui</td></tr><tr><td style="text-align:center">axios</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="keyword">element</span>-ui axios  -S</span><br></pre></td></tr></table></figure><p><em>注意安装时记得 -S，它的作用是安装完后在package.json项目文件中插入记录，后续操作需要读取已安装模块</em></p><h1 id="确定CDN资源URI"><a href="#确定CDN资源URI" class="headerlink" title="确定CDN资源URI"></a>确定CDN资源URI</h1><p>对于cdn，我们可以自己搭建，也可以使用专业的cdn服务商，这里使用免费的cdn <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bootcdn.cn%2F" target="_blank" rel="noopener">bootcdn</a>。选用免费cdn有很多好处，但毕竟有隐患，那就是服务有可能会奔溃。</p><p>bootcdn <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bootcdn.cn" target="_blank" rel="noopener">https://www.bootcdn.cn</a></p><p>依次搜索出前面模块，结果如下:</p><table><thead><tr><th><strong>模块</strong></th><th>版本</th><th><strong>js</strong></th><th><strong>css</strong></th></tr></thead><tbody><tr><td>vue</td><td>2.5.2</td><td><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.bootcss.com%2Fvue%2F2.5.2%2Fvue.min.js" target="_blank" rel="noopener">https://cdn.bootcss.com/vue/2.5.2/vue.min.js</a></td><td>-</td></tr><tr><td>vue-router</td><td>3.0.1</td><td><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.bootcss.com%2Fvue-router%2F3.0.1%2Fvue-router.min.js" target="_blank" rel="noopener">https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js</a></td><td>-</td></tr><tr><td>element-ui</td><td>2.6.3</td><td><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.bootcss.com%2Felement-ui%2F2.6.1%2Findex.js" target="_blank" rel="noopener">https://cdn.bootcss.com/element-ui/2.6.1/index.js</a></td><td><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.bootcss.com%2Felement-ui%2F2.6.1%2Ftheme-chalk%2Findex.css" target="_blank" rel="noopener">https://cdn.bootcss.com/element-ui/2.6.1/theme-chalk/index.css</a></td></tr><tr><td>axios</td><td>0.18.0</td><td><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.bootcss.com%2Faxios%2F0.18.0%2Faxios.min.js" target="_blank" rel="noopener">https://cdn.bootcss.com/axios/0.18.0/axios.min.js</a></td><td>-</td></tr></tbody></table><p>按照规律，得出cdn资源路径规则为</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//cdn.bootcss.com + 模块名 + 版本号 + 具体路径</span></span><br></pre></td></tr></table></figure><p>其他cdn服务商同理</p><h1 id="打包前的处理"><a href="#打包前的处理" class="headerlink" title="打包前的处理"></a>打包前的处理</h1><h2 id="build-utils-js添加读取事件"><a href="#build-utils-js添加读取事件" class="headerlink" title="build/utils.js添加读取事件"></a>build/utils.js添加读取事件</h2><p><code>使用cdn其实也就是在webpack热启动和打包项目的时候动态插入script和style链接</code>，为了方便维护，我们通过在<code>build/utils.js</code>文件上添加几个方法，将来在<code>webpack.dev.conf.js</code>和<code>webpack.prod.conf.js</code>上可以使用。</p><p><em>如果没有build/utils.js，可以在其他文件上添加，只要在后续步骤中能操作到就行</em></p><p>添加cdn根地址</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/utils.js 国内免费cdn镜像源</span></span><br><span class="line"><span class="keyword">exports</span>.cdnBaseHttp = <span class="string">'https://cdn.bootcss.com'</span>;</span><br></pre></td></tr></table></figure><p>添加cdn模块 <code>按照需要删改</code> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  build/utils.js external配置</span></span><br><span class="line">exports.externalConfig = [</span><br><span class="line">  &#123; <span class="string">name:</span> <span class="string">'vue'</span>, <span class="string">scope:</span> <span class="string">'Vue'</span>, <span class="string">js:</span> <span class="string">'vue.min.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">name:</span> <span class="string">'vue-router'</span>, <span class="string">scope:</span> <span class="string">'VueRouter'</span>, <span class="string">js:</span> <span class="string">'vue-router.min.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">name:</span> <span class="string">'axios'</span>, <span class="string">scope:</span> <span class="string">'axios'</span>, <span class="string">js:</span> <span class="string">'axios.min.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">name:</span> <span class="string">'element-ui'</span>, <span class="string">scope:</span> <span class="string">'ELEMENT'</span>, <span class="string">js:</span> <span class="string">'index.js'</span>, <span class="string">css:</span> <span class="string">'theme-chalk/index.css'</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><code>name</code> 模块名称，与package.json同名<br> <code>scope</code> 模块作用域命名<br> <code>js</code> js地址<br> <code>css</code> css地址</p><p>这里特别注意scope，它是webpack配置的external参数下的信息，比如vue的作用域命名是Vue，vue-router的作用域命名是VueRouter，element-ui的作用域命名是ELEMENT，同理，jq的作用域命名是JQuery，<code>具体做法是先引入该资源，然后在控制台依次输入近似的值，一个个匹配</code>(目前没找到更好的做法)。</p><p>添加获取版本号方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/utils.js 获取模块版本号</span></span><br><span class="line">exports.getModulesVersion = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mvs = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> regexp = <span class="regexp">/^npm_package_.&#123;0,3&#125;dependencies_/gi</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> m <span class="keyword">in</span> process.env) &#123; <span class="comment">// 从node内置参数中读取，也可直接import 项目文件进来</span></span><br><span class="line">    <span class="keyword">if</span> (regexp.test(m)) &#123; <span class="comment">// 匹配模块</span></span><br><span class="line">       <span class="comment">// 获取到模块版本号</span></span><br><span class="line">      mvs[m.replace(regexp, <span class="string">''</span>).replace(<span class="regexp">/_/g</span>, <span class="string">'-'</span>)] = process.env[m].replace(<span class="regexp">/(~|\^)/g</span>, <span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mvs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>导出不需要被打包的cdn模块配置<code>重点</code> </p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// build/utils.js</span><br><span class="line">exports.getExternalModules = config =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> externals = &#123;&#125;; // 结果</span><br><span class="line">  <span class="keyword">let</span> dependencieModules = this.getModulesVersion(); // 获取全部的模块和版本号</span><br><span class="line">  config = config || this.externalConfig; // 默认使用utils下的配置</span><br><span class="line">  config.forEach(<span class="type">item</span> =&gt; &#123; // 遍历配置</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">item</span><span class="built_in">.name</span> <span class="keyword">in</span> dependencieModules) &#123;</span><br><span class="line">      <span class="keyword">let</span> version = dependencieModules[<span class="type">item</span><span class="built_in">.name</span>];</span><br><span class="line">      // 拼接css 和 js 完整链接</span><br><span class="line">      <span class="type">item</span>.css = <span class="type">item</span>.css &amp;&amp; [this.cdnBaseHttp, <span class="type">item</span><span class="built_in">.name</span>, version, <span class="type">item</span>.css].join(<span class="string">'/'</span>);</span><br><span class="line">      <span class="type">item</span>.js = <span class="type">item</span>.js &amp;&amp; [this.cdnBaseHttp, <span class="type">item</span><span class="built_in">.name</span>, version, <span class="type">item</span>.js].join(<span class="string">'/'</span>);</span><br><span class="line">      externals[<span class="type">item</span><span class="built_in">.name</span>] = <span class="type">item</span>.scope; // 为打包时准备</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      throw new Error(<span class="string">'相关依赖未安装，请先执行npm install '</span> + <span class="type">item</span><span class="built_in">.name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> externals;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-conf-js添加cdn配置"><a href="#webpack-dev-conf-js添加cdn配置" class="headerlink" title="webpack.dev.conf.js添加cdn配置"></a>webpack.dev.conf.js添加cdn配置</h2><p>在webpack热启动本地调试的时候，我们可以使用cdn。</p><p>获取cdn配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.dev.conf.js 大概在15行</span></span><br><span class="line"><span class="keyword">const</span> externalConfig = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(utils.externalConfig));  <span class="comment">// 读取配置</span></span><br><span class="line">utils.getExternalModules(externalConfig); <span class="comment">// 获取到合适的路径（引用类型，自动改变）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const devWebpackConfig = merge .......</span></span><br></pre></td></tr></table></figure><p>在<code>build/webpack.dev.conf.js</code>中，默认已经引入了<code>utils.js</code>，所以可以直接调用相关方法，如果是自定义的文件，记得引入。</p><p>HtmlWebpackPlugin插件中导出cdn<br> 紧接着我们在该文件下找到<code>devWebpackConfig</code>下的<code>plugins</code>下的<code>HtmlWebpackPlugin</code>插件，它的作用是动态构建html页面，原始配置如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  template: <span class="string">'index.html'</span>,</span><br><span class="line">  <span class="keyword">inject</span>: <span class="keyword">true</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 代表处理根目录下的index.html文件</span></span><br></pre></td></tr></table></figure><p><code>我们可以往里面添加点自定义属性，方便在index.html中调用。</code>，修改如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line"> <span class="attribute">filename</span>: <span class="string">'index.html'</span>,</span><br><span class="line"> <span class="attribute">template</span>: <span class="string">'index.html'</span>,</span><br><span class="line"> <span class="attribute">inject</span>: true,</span><br><span class="line"> <span class="attribute">cdnConfig</span>: externalConfig, <span class="comment">// cdn配置</span></span><br><span class="line"> <span class="attribute">onlyCss</span>: true, <span class="comment">//dev下只加载css</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>其中<code>cdnConfig</code>和<code>onlyCss</code>自定义属性，在html上通过<code>htmlWebpackPlugin.options</code>可以读取到。</p><p>更多html-webpack-plugin配置情况官网，这里暂时不需要更多。</p><h2 id="webpack-prod-conf-js添加cdn配置和忽略模块"><a href="#webpack-prod-conf-js添加cdn配置和忽略模块" class="headerlink" title="webpack.prod.conf.js添加cdn配置和忽略模块"></a>webpack.prod.conf.js添加cdn配置和忽略模块</h2><p>在打包的时候，我们使用cdn，配置和前面dev的差不多，只不过需要做多一步。</p><p>获取cdn配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.prod.conf.js 大概在15行</span></span><br><span class="line"><span class="keyword">const</span> externalConfig = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(utils.externalConfig)); <span class="comment">// 读取配置</span></span><br><span class="line"><span class="keyword">const</span> externalModules = utils.getExternalModules(externalConfig); <span class="comment">// 获取到合适路径和忽略模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const webpackConfig = merge(baseWebpackConfig....</span></span><br></pre></td></tr></table></figure><p>注意此处的<code>externalModules</code>，后面用到，也就是比dev多的步骤。</p><p>webpck配置加多个属性externals<br> <code>externals</code>代表构建时不需要被处理的模块，也就是前面说的<code>scope</code>需要注意的地方。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.prod.conf.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="keyword">merge</span>(baseWebpackConfig, &#123;</span><br><span class="line">  externals: externalModules, <span class="comment">// 构建时忽略的资源</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin插件中导出cdn<br> 和dev一样，我们修改<code>webpackConfig</code>下的<code>plugins</code>下的<code>HtmlWebpackPlugin</code>插件配置 (这里的默认配置比dev的多，主要是css压缩和js压缩相关)</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">   <span class="comment">// 其他默认配置</span></span><br><span class="line">  cdnConfig: externalConfig, <span class="comment">// cdn配置</span></span><br><span class="line">  onlyCss: <span class="literal">false</span>, <span class="comment">//加载css</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>加入和dev一样的两个配置，不过需要把onlyCss改为<code>true</code>，因为我们希望打包时不单单使用css。</p><h2 id="index-html插入相关链接"><a href="#index-html插入相关链接" class="headerlink" title="index.html插入相关链接"></a>index.html插入相关链接</h2><p>webpack配置已经完成，在html-webpack-plugin中已经添加了相关参数，我们再在页面上可以直接使用，使用语法是<code>ejs</code>，和asp.net，jsp，php类似。</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="comment">&lt;!-- 其他标签 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> htmlWebpackPlugin.options.cdnConfig.forEach(function(item)&#123; <span class="keyword">if</span>(item.css)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> item.css </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125;&#125;) </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="comment">&lt;!-- 其他标签 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> htmlWebpackPlugin.options.cdnConfig.forEach(function(item)&#123; <span class="keyword">if</span>(item.js &amp;&amp; !htmlWebpackPlugin.options.onlyCss)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> item.js </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125;&#125;) </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过<code>&lt;% %&gt;</code> 和 <code>htmlWebpackPlugin.options</code> 用js遍历<code>插入</code>link标签和script标签。</p><p><em>ps: 修改了webpack配置，需要重启项目才会生效</em></p><h3 id="愉快的开发"><a href="#愉快的开发" class="headerlink" title="愉快的开发"></a>愉快的开发</h3><p>此时启动项目，查看控制台或者查看源代码，可以清楚的相关资源来源</p><p><strong>有一个更好的插件</strong><a href="https://github.com/shirotech/webpack-cdn-plugin" target="_blank" rel="noopener">webpack-cdn-plugin</a></p><p><strong><a href="https://www.jianshu.com/p/9248db0349fb" target="_blank" rel="noopener">原文链接</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git子目录创建分支</title>
      <link href="//posts/2bdc4097.html"/>
      <url>//posts/2bdc4097.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用场景</strong></p><p>例如，在项目Game中有一个子目录AI。Game和AI分别是一个独立的git项目，可以分开维护。为了避免直接复制粘贴代码，我们希望Game中的AI子目录与AI的git项目关联，有3层意思：</p><p>1.AI子目录使用AI的git项目来填充，内容保持一致。</p><p>2.当AI的git项目代码有更新，可以拉取更新到Game项目的AI子目录来。</p><p>3.反过来，当Game项目的AI子目录有变更，还可以推送这些变更到AI的git项目。</p><p>用git subtree可以轻松满足上面的需求。</p><a id="more"></a><h1 id="git-subtree用法"><a href="#git-subtree用法" class="headerlink" title="git subtree用法"></a><strong>git subtree用法</strong></h1><h2 id="1-第一次添加子目录，建立与git项目的关联"><a href="#1-第一次添加子目录，建立与git项目的关联" class="headerlink" title="1. 第一次添加子目录，建立与git项目的关联"></a><strong>1. 第一次添加子目录，建立与git项目的关联</strong></h2><p>建立关联总共有2条命令。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：git remote <span class="builtin-name">add</span> -f &lt;子仓库名&gt; &lt;子仓库地址&gt; </span><br><span class="line"></span><br><span class="line">解释：其中-f意思是在添加远程仓库之后，立即执行fetch。</span><br><span class="line"></span><br><span class="line">语法：git subtree <span class="builtin-name">add</span> <span class="attribute">--prefix</span>=&lt;子目录名&gt; &lt;子仓库名&gt; &lt;分支&gt; --squash </span><br><span class="line"></span><br><span class="line">解释：–squash意思是把subtree的改动合并成一次commit，这样就不用拉取子项目完整的历史记录。–prefix之后的=等号也可以用空格。</span><br></pre></td></tr></table></figure><p>示例<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> -f ai https://github.com/aoxu/ai.git   </span></span><br><span class="line">git subtree <span class="keyword">add</span><span class="bash"> --prefix=ai ai master --squash</span></span><br></pre></td></tr></table></figure></p><h2 id="2-从远程仓库更新子目录"><a href="#2-从远程仓库更新子目录" class="headerlink" title="2. 从远程仓库更新子目录"></a><strong>2. 从远程仓库更新子目录</strong></h2><p>更新子目录有2条命令。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：git fetch <span class="tag">&lt;<span class="name">远程仓库名</span>&gt;</span> <span class="tag">&lt;<span class="name">分支</span>&gt;</span>  </span><br><span class="line">语法：git subtree pull --prefix=<span class="tag">&lt;<span class="name">子目录名</span>&gt;</span> <span class="tag">&lt;<span class="name">远程分支</span>&gt;</span> <span class="tag">&lt;<span class="name">分支</span>&gt;</span> --squash</span><br></pre></td></tr></table></figure></p><p>示例<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch ai <span class="keyword">master</span>   <span class="title"></span></span><br><span class="line"><span class="title">git</span> subtree pull --<span class="attr">prefix=</span>ai ai --squash</span><br></pre></td></tr></table></figure></p><h2 id="3-从子目录push到远程仓库（确认你有写权限）"><a href="#3-从子目录push到远程仓库（确认你有写权限）" class="headerlink" title="3. 从子目录push到远程仓库（确认你有写权限）"></a><strong>3. 从子目录push到远程仓库（确认你有写权限）</strong></h2><p>推送子目录的变更有1条命令。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：git <span class="keyword">subtree </span><span class="keyword">push </span>--prefix=&lt;子目录名&gt; &lt;远程分支名&gt; 分支</span><br></pre></td></tr></table></figure></p><p>示例<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">subtree </span><span class="keyword">push </span>--prefix<span class="symbol">=ai</span> ai master</span><br></pre></td></tr></table></figure></p><p><strong>原文地址：</strong><a href="http://cssor.com/git-subtree-usage.html" target="_blank" rel="noopener"><strong>http://cssor.com/git-subtree-usage.html</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="//posts/423abe9e.html"/>
      <url>//posts/423abe9e.html</url>
      
        <content type="html"><![CDATA[<p><strong>推送到远程仓库</strong>：<a href="http://blog.csdn.net/u011043843/article/details/33336625" target="_blank" rel="noopener">http://blog.csdn.net/u011043843/article/details/33336625</a></p><p><strong>github设置添加SSH</strong>：<a href="https://blog.csdn.net/binyao02123202/article/details/20130891" target="_blank" rel="noopener">https://blog.csdn.net/binyao02123202/article/details/20130891</a></p><a id="more"></a><h2 id="一-设置git的全局变量-用户名和邮箱"><a href="#一-设置git的全局变量-用户名和邮箱" class="headerlink" title="一.设置git的全局变量(用户名和邮箱)"></a><strong>一.设置git的全局变量(用户名和邮箱)</strong></h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. git<span class="built_in"> config </span>--global user.name”用户名(建议是英文)” 创建用户名</span><br><span class="line">2. git<span class="built_in"> config </span>--global user.email”邮箱地址” 创建邮箱</span><br></pre></td></tr></table></figure><h2 id="二-创建一个新的仓库"><a href="#二-创建一个新的仓库" class="headerlink" title="二.创建一个新的仓库"></a><strong>二.创建一个新的仓库</strong></h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. git <span class="keyword">clone</span> <span class="title">&lt;url</span>&gt;  从远程服务器克隆一个完全一样的版本库到本地 ：</span><br><span class="line"><span class="number">2</span>. git add . 暂存文件</span><br><span class="line"><span class="number">3</span>. git commit -a <span class="tag">&lt;注释&gt;</span> 提交</span><br><span class="line"><span class="number">4</span>. git push -u origin <span class="keyword">master</span> <span class="title">推送（推送到主分支）</span></span><br></pre></td></tr></table></figure><h2 id="三-本地已经创建该目录"><a href="#三-本地已经创建该目录" class="headerlink" title="三.本地已经创建该目录"></a><strong>三.本地已经创建该目录</strong></h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> git init .初始化</span><br><span class="line"><span class="number">2.</span> git <span class="comment">remote add origin ssh://git.com/lsy/demo.git 增加一个远程服务端 </span></span><br><span class="line"><span class="number">3.</span> git add 文件名/工程名 .（所有文件） 暂存文件</span><br><span class="line"><span class="number">4.</span> git commit -m “Initial commit” 提交</span><br><span class="line"><span class="number">5.</span> git push -u origin master 推送（推送到主分支）</span><br></pre></td></tr></table></figure><h2 id="四-存在git仓库"><a href="#四-存在git仓库" class="headerlink" title="四.存在git仓库"></a><strong>四.存在git仓库</strong></h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> cd demo 进入该仓库</span><br><span class="line"><span class="number">2.</span> git <span class="comment">remote add origin ssh://git.com/lsy/hhh.git（git  pull 同步代码到本地）增加一个远程服务端</span></span><br><span class="line"><span class="number">3.</span> git push -u origin --all（上传代码到远程库） 推送</span><br><span class="line"><span class="number">4.</span> git push -u origin --tags 推送标签到主机</span><br></pre></td></tr></table></figure><h2 id="五-常用命令："><a href="#五-常用命令：" class="headerlink" title="五.常用命令："></a><strong>五.常用命令：</strong></h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> git branch 查看本地所有分支</span><br><span class="line"><span class="number">2.</span> git branch -a 查看远程所有的分支</span><br><span class="line"><span class="number">3.</span> git branch -r 查看远程所有分支(不包括当前分支)</span><br><span class="line"><span class="number">4.</span> git push origin --<span class="keyword">delete</span> &lt;<span class="keyword">name</span>&gt;  可以删除远程分支</span><br><span class="line"><span class="number">5.</span> git branch -d &lt;<span class="keyword">name</span>&gt;  可以删除本地分支（在主分支中）</span><br><span class="line"><span class="number">6.</span> git status 查看当前状态 </span><br><span class="line"><span class="number">7.</span> git commit -am <span class="string">"init"</span> 提交并且加注释 </span><br><span class="line"><span class="number">8.</span> git subtree push --prefix= [目录地址(dist)] origin [分支名称(gh-pages)]  单个目录托管命令</span><br><span class="line"><span class="number">9.</span> git <span class="comment">remote add origin git@192.168.1.119:ndshow</span></span><br><span class="line"><span class="number">10.</span> git push origin master 将文件给推到服务器上 </span><br><span class="line"><span class="number">11.</span> git <span class="comment">remote show origin 显示远程库origin里的资源 </span></span><br><span class="line"><span class="number">12.</span> git push origin master:develop 提交本地master分支作为远程的develop分支</span><br><span class="line"><span class="number">13.</span> git checkout --track origin/dev 切换到远程dev分支</span><br><span class="line"><span class="number">14.</span> git checkout -b dev 建立一个新的本地分支dev</span><br><span class="line"><span class="number">15.</span> git <span class="keyword">merge</span> origin/dev 将分支dev与当前分支进行合并</span><br><span class="line"><span class="number">16.</span> git checkout dev 切换到本地dev分支</span><br><span class="line"><span class="number">17.</span> git <span class="comment">remote show 查看远程库</span></span><br><span class="line"><span class="number">18.</span> git <span class="comment">remote remove &lt;name&gt;  删除remote</span></span><br><span class="line"><span class="number">19.</span> git add . 暂存文件全部</span><br><span class="line"><span class="number">20.</span> git rm 文件名(包括路径) 从git中删除指定文件</span><br><span class="line"><span class="number">21.</span> git clone git:// 下载</span><br><span class="line"><span class="number">22.</span> github.<span class="keyword">com</span>/schacon/grit.git 从服务器上将代码给拉下来</span><br><span class="line"><span class="number">23.</span> git config --<span class="keyword">list</span> 看所有用户</span><br><span class="line"><span class="number">24.</span> git ls-<span class="keyword">files</span> 看已经被提交的</span><br><span class="line"><span class="number">25.</span> git rm [file <span class="keyword">name</span>] 删除一个文件</span><br><span class="line"><span class="number">26.</span> git commit -a 提交当前repos的所有的改变</span><br><span class="line"><span class="number">27.</span> git add [file <span class="keyword">name</span>] 添加一个文件到git index</span><br><span class="line"><span class="number">28.</span> git commit -v 当你用－v参数的时候可以看commit的差异</span><br><span class="line"><span class="number">29.</span> git commit -m <span class="string">"This is the message describing the commit"</span> 添加commit信息</span><br><span class="line"><span class="number">30.</span> git commit -a -a是代表add，把所有的change加到git index里然后再commit</span><br><span class="line"><span class="number">31.</span> git commit -a -v 一般提交命令</span><br><span class="line"><span class="number">32.</span> git <span class="keyword">log</span> 看你commit的日志</span><br><span class="line"><span class="number">33.</span> git diff 查看尚未暂存的更新</span><br><span class="line"><span class="number">34.</span> git rm a.a 移除文件(从暂存区和工作区中删除)</span><br><span class="line"><span class="number">35.</span> git rm --cached a.a 移除文件(只从暂存区中删除)</span><br><span class="line"><span class="number">36.</span> git commit -m <span class="string">"remove"</span> 移除文件(从Git中删除)</span><br><span class="line"><span class="number">37.</span> git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)</span><br><span class="line"><span class="number">38.</span> git diff --cached 或 $ git diff --staged 查看尚未提交的更新</span><br><span class="line"><span class="number">39.</span> git stash push 将文件给push到一个临时空间中</span><br><span class="line"><span class="number">40.</span> git stash pop 将文件从临时空间pop下来</span><br><span class="line"><span class="number">41.</span> git <span class="comment">remote add origin git@github.com:username/Hello-World.git</span></span><br><span class="line"><span class="number">42.</span> git push origin master 将本地项目给提交到服务器中</span><br><span class="line"><span class="number">43.</span> git pull 本地与服务器端同步</span><br><span class="line"><span class="number">44.</span> git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</span><br><span class="line"><span class="number">45.</span> git push origin serverfix:awesomebranch</span><br><span class="line"><span class="number">46.</span> git fetch 相当于是从远程获取最新版本到本地，不会自动<span class="keyword">merge</span></span><br><span class="line"><span class="number">47.</span> git commit -a -m <span class="string">"log_message"</span> (-a是提交所有改动，-m是加入<span class="keyword">log</span>信息) 本地修改同步至服务器端 ：</span><br><span class="line"><span class="number">48.</span> git branch branch_0.<span class="number">1</span> master 从主分支master创建branch_0.<span class="number">1</span>分支</span><br><span class="line"><span class="number">49.</span> git branch -m branch_0.<span class="number">1</span> branch_1.<span class="number">0</span> 将branch_0.<span class="number">1</span>重命名为branch_1.<span class="number">0</span></span><br><span class="line"><span class="number">50.</span> git checkout branch_1.<span class="number">0</span>/master 切换到branch_1.<span class="number">0</span>/master分支</span><br><span class="line"><span class="number">51.</span> git branch 删除远程branch</span><br><span class="line"><span class="number">52.</span> git push origin :branch_<span class="comment">remote_name</span></span><br><span class="line"><span class="number">53.</span> git branch -r -d branch_<span class="comment">remote_name</span></span><br><span class="line"><span class="number">54.</span> git <span class="keyword">reset</span> --hard commit_id 版本回退</span><br><span class="line"><span class="number">55.</span> git <span class="keyword">log</span>可以查看提交历史</span><br><span class="line"><span class="number">56.</span> git reflog查看命令历史</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue.config.js配置</title>
      <link href="//posts/4de2b0c3.html"/>
      <url>//posts/4de2b0c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="在项目根目录下创建vue-config-js文件："><a href="#在项目根目录下创建vue-config-js文件：" class="headerlink" title="在项目根目录下创建vue.config.js文件："></a>在项目根目录下创建vue.config.js文件：</h2><h3 id="详细代码如下："><a href="#详细代码如下：" class="headerlink" title="详细代码如下："></a><strong>详细代码如下：</strong></h3><a id="more"></a><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require<span class="params">('webpack')</span></span><br><span class="line">const path = require<span class="params">('path')</span>;</span><br><span class="line"> </span><br><span class="line">function resolve<span class="params">(dir)</span> &#123;</span><br><span class="line">    return path.join<span class="params">(__dirname, dir)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  /* vue-cli3 项目配置文件 */</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  基本路径</span><br><span class="line">  默认情况下，我们假设您的应用程序将部署在域的根上</span><br><span class="line">  例如：https:<span class="string">//www.my-app.com/</span></span><br><span class="line">  如果应用程序部署在子路径上，则需要指定</span><br><span class="line">  这里的子路径，例如，如果应用程序部署在 https:<span class="string">//www.foobar.com/my-app/</span></span><br><span class="line">  然后把这个变成 '<span class="string">/my-app/</span>'</span><br><span class="line">  例如：https:<span class="string">//www.example.com/project/v1.1/index.html</span></span><br><span class="line">  baseUrl 为 <span class="string">/project/v1.1/</span></span><br><span class="line">  baseUrl: process.env.NODE_ENV === 'production' ? '<span class="string">/online/</span>' : '/'</span><br><span class="line">  */</span><br><span class="line">  baseUrl: '/',</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 输出文件目录</span><br><span class="line">  <span class="string">//</span> 在npm run build时 生成文件的目录 type<span class="function">:string</span>, default:'dist'</span><br><span class="line">  outputDir: 'dist',</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  构建多页时使用</span><br><span class="line">  index: &#123;</span><br><span class="line">    <span class="string">//</span> 入口</span><br><span class="line">    entry: 'src/index/main.js',</span><br><span class="line">    <span class="string">//</span> 模板</span><br><span class="line">    template: 'public/index.html',</span><br><span class="line">    <span class="string">//</span> output as dist/index.html</span><br><span class="line">    filename: 'index.html'</span><br><span class="line">  &#125;</span><br><span class="line">  */</span><br><span class="line">  pages: &#123; type: Object, Default: undefined &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 用于放置生成的静态资源 <span class="params">(js、css、img、fonts)</span> 的；（项目打包之后，静态资源会放在这个文件夹下</span><br><span class="line">  <span class="string">//</span> 网络请求的静态目录为 public 不参与打包 请求地址 <span class="string">./</span> 直接指向 public 目录</span><br><span class="line">  assetsDir: 'assets',</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 指定生成的 index.html 的输出路径  <span class="params">(打包之后，改变系统默认的index.html的文件名)</span></span><br><span class="line">  indexPath: 'index.html',</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置</span><br><span class="line">  lintOnSave: process.env.NODE_ENV !== 'production</span><br><span class="line">  eslint-loader eslint检查,是否在保存的时候检查</span><br><span class="line">  lintOnSave：&#123; type<span class="function">:Boolean</span> default<span class="function">:true</span> &#125; 问你是否使用eslint</span><br><span class="line">  */</span><br><span class="line">  lintOnSave: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 <span class="literal">false</span> 来关闭文件名哈希。<span class="params">(false的时候就是让原来的文件名不改变)</span></span><br><span class="line">  filenameHashing: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  使用编译器生成全在浏览器</span><br><span class="line">  是否使用包含运行时编译器的 Vue 构建版本。设置为 <span class="literal">true</span> 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。<span class="params">(默认false)</span></span><br><span class="line">  https:<span class="string">//vuejs.org/v2/guide/installation.html</span><span class="comment">#Runtime-Compiler-vs-Runtime-only</span></span><br><span class="line">  */</span><br><span class="line">  runtimeCompiler: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  babel-loader在默认情况下跳过`node_modules`模块</span><br><span class="line">  显式地使用此选项来转换依赖项</span><br><span class="line">  默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来</span><br><span class="line">  */</span><br><span class="line">  transpileDependencies: [ /* string or regex */ ],</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 生产环境是否生成 sourceMap 文件</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  调整内部webpack配置</span><br><span class="line">  see https:<span class="string">//github.com/vuejs/vue-cli/blob/dev/docs/webpack.md</span></span><br><span class="line">  是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.module</span><br><span class="line">      <span class="string">.rule</span><span class="params">('images')</span></span><br><span class="line">      <span class="string">.use</span><span class="params">('url-loader')</span></span><br><span class="line">      <span class="string">.loader</span><span class="params">('url-loader')</span></span><br><span class="line">      <span class="string">.tap</span><span class="params">(<span class="attr">options</span> =&gt; &#123;</span></span><br><span class="line"><span class="params">        // 修改它的选项...</span></span><br><span class="line"><span class="params">        return options</span></span><br><span class="line"><span class="params">      &#125;)</span>,</span><br><span class="line">      config.entry.app = [<span class="string">"babel-polyfill"</span>, resolve<span class="params">('src/main.js')</span>],</span><br><span class="line">      <span class="string">//</span> 别名</span><br><span class="line">      config.resolve.<span class="keyword">alias</span></span><br><span class="line">            <span class="string">.set</span><span class="params">('@', resolve('src')</span>)</span><br><span class="line">            <span class="string">.set</span><span class="params">('./@assets', resolve('src/assets')</span>)</span><br><span class="line">            <span class="string">.set</span><span class="params">('@components', resolve('src/components')</span>)</span><br><span class="line">            <span class="string">.set</span><span class="params">('@font', resolve('src/font')</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  configureWebpack: config =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(process.env.<span class="attr">NODE_ENV</span> === 'production')</span> &#123;</span><br><span class="line">      <span class="string">//</span> 为生产环境修改配置<span class="string">...</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      <span class="string">//</span> 为开发环境修改配置<span class="string">...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  */</span><br><span class="line">  <span class="string">//</span> 插件配置</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            new webpack.ProvidePlugin<span class="params">(&#123;</span></span><br><span class="line"><span class="params">                jQuery: 'jquery',</span></span><br><span class="line"><span class="params">                $: 'jquery'</span></span><br><span class="line"><span class="params">            &#125;)</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="string">//</span> css相关配置</span><br><span class="line">  css: &#123;</span><br><span class="line">    <span class="string">//</span> 是否使用css分离插件 ExtractTextPlugin</span><br><span class="line">    extract: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">//</span> 开启 CSS source maps?</span><br><span class="line">    sourceMap: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">//</span> css预设器配置项</span><br><span class="line">    loaderOptions: &#123;&#125;,</span><br><span class="line">    <span class="string">//</span> 启用 CSS modules for all css / pre-processor files.</span><br><span class="line">    modules: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 在生产中使用Babel＆TS thread-loader</span><br><span class="line">  <span class="string">//</span> 默认情况下，如果机器有超过1个内核</span><br><span class="line">  parallel: require<span class="params">('os')</span><span class="string">.cpus</span><span class="params">()</span><span class="string">.length</span> &gt; 1,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> PWA（渐进式WEB应用） 插件相关配置 https:<span class="string">//segmentfault.com/a/1190000012353473</span></span><br><span class="line">  <span class="string">//</span> see https:<span class="string">//github.com/vuejs/vue-cli/tree/dev/packages/</span>%40vue/cli-plugin-pwa</span><br><span class="line">  pwa: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span> 它支持webPack-dev-server的所有选项</span><br><span class="line">  <span class="string">//</span> See https:<span class="string">//github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md</span><span class="comment">#configuring-proxy</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="string">//</span> 主机名</span><br><span class="line">    host: process.env.HOST || 'localhost',</span><br><span class="line">    <span class="string">//</span> 端口号</span><br><span class="line">    port: process.env.PORT || 8080,</span><br><span class="line">    <span class="string">//</span> 是否支持https安全访问</span><br><span class="line">    https: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">//</span> 配置自动启动浏览器 process.platform === 'darwin'</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">//</span> 热更新（webpack已实现了，这里<span class="literal">false</span>即可）</span><br><span class="line">    hotOnly: <span class="literal">false</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    /*</span><br><span class="line">    配置跨域处理,只有一个代理</span><br><span class="line">    proxy: 'http:<span class="string">//localhost</span><span class="function">:4000</span>'</span><br><span class="line">    配置多个代理</span><br><span class="line">    &#123;</span><br><span class="line">      '<span class="string">/api</span>': &#123;</span><br><span class="line">        target: '&lt;url&gt;',</span><br><span class="line">        ws: <span class="literal">true</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      '<span class="string">/foo</span>': &#123;</span><br><span class="line">        target: '&lt;other_url&gt;'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    proxy: null,</span><br><span class="line">    <span class="string">//</span> 请求之前</span><br><span class="line">    before: app =&gt; &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">//</span> 第三方插件配置 css loader</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    'style-resources-loader': &#123;</span><br><span class="line">      preProcessor: 'less',</span><br><span class="line">      patterns: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue轮子工厂</title>
      <link href="//posts/da177769.html"/>
      <url>//posts/da177769.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.wheelsfactory.cn/#/" target="_blank" rel="noopener">Vue轮子工厂</a></p><p><img src="https://cdn.jsdelivr.net/gh/yangyfeng/yangyfeng.github.io@gh-pages/assets_blog/img/loading.gif" data-original="https://s2.ax1x.com/2019/07/13/Zhvm6I.png" alt="Zhvm6I.png"></p><a id="more"></a><table><thead><tr><th><strong>组件名字</strong></th><th><strong>组件描述</strong></th><th><strong>组件git创库地址</strong></th></tr></thead><tbody><tr><td>element</td><td>element - 饿了么出品的Vue2的web UI工具套件</td><td><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">https://github.com/ElemeFE/element</a></td></tr><tr><td>Vux</td><td>Vux - 基于Vue和WeUI的组件库</td><td><a href="https://github.com/airyland/vux" target="_blank" rel="noopener">https://github.com/airyland/vux</a></td></tr><tr><td>mint-ui</td><td>mint-ui - Vue 2的移动UI元素</td><td><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">https://github.com/ElemeFE/mint-ui</a></td></tr><tr><td>iview</td><td>iview - 基于 Vuejs 的开源 UI 组件库</td><td><a href="https://github.com/iview/iview" target="_blank" rel="noopener">https://github.com/iview/iview</a></td></tr><tr><td>Keen-UI</td><td>Keen-UI - 轻量级的基本UI组件合集</td><td><a href="https://github.com/JosephusPaye/Keen-UI" target="_blank" rel="noopener">https://github.com/JosephusPaye/Keen-UI</a></td></tr><tr><td>vue-material</td><td>vue-material - 通过Vue Material和Vue 2建立精美的app应用</td><td><a href="https://github.com/marcosmoura/vue-material" target="_blank" rel="noopener">https://github.com/marcosmoura/vue-material</a></td></tr><tr><td>muse-ui</td><td>muse-ui - 三端样式一致的响应式 UI 库</td><td><a href="https://github.com/museui/muse-ui" target="_blank" rel="noopener">https://github.com/museui/muse-ui</a></td></tr><tr><td>vuetify</td><td>vuetify - 为移动而生的Vue JS 2组件框架</td><td><a href="https://github.com/vuetifyjs/vuetify" target="_blank" rel="noopener">https://github.com/vuetifyjs/vuetify</a></td></tr><tr><td>vonic</td><td>vonic - 快速构建移动端单页应用</td><td><a href="https://github.com/wangdahoo/vonic" target="_blank" rel="noopener">https://github.com/wangdahoo/vonic</a></td></tr><tr><td>eme</td><td>eme - 优雅的Markdown编辑器</td><td><a href="https://github.com/egoist/eme" target="_blank" rel="noopener">https://github.com/egoist/eme</a></td></tr><tr><td>vue-multiselect</td><td>vue-multiselect - Vue.js选择框解决方案</td><td><a href="https://github.com/monterail/vue-multiselect" target="_blank" rel="noopener">https://github.com/monterail/vue-multiselect</a></td></tr><tr><td>vue-table</td><td>vue-table - 简化数据表格</td><td><a href="https://github.com/ratiw/vue-table" target="_blank" rel="noopener">https://github.com/ratiw/vue-table</a></td></tr><tr><td>VueCircleMenu</td><td>VueCircleMenu - 漂亮的vue圆环菜单</td><td><a href="https://github.com/OYsun/VueCircleMenu" target="_blank" rel="noopener">https://github.com/OYsun/VueCircleMenu</a></td></tr><tr><td>vue-chat</td><td>vue-chat - vuejs和vuex及webpack的聊天示例</td><td><a href="https://github.com/Coffcer/vue-chat" target="_blank" rel="noopener">https://github.com/Coffcer/vue-chat</a></td></tr><tr><td>radon-ui</td><td>radon-ui - 快速开发产品的Vue组件库</td><td><a href="https://github.com/luojilab/radon-ui" target="_blank" rel="noopener">https://github.com/luojilab/radon-ui</a></td></tr><tr><td>vue-waterfall</td><td>vue-waterfall - Vue.js的瀑布布局组件</td><td><a href="https://github.com/MopTym/vue-waterfall" target="_blank" rel="noopener">https://github.com/MopTym/vue-waterfall</a></td></tr><tr><td>vue-carbon</td><td>vue-carbon - 基于 vue 开发MD风格的移动端</td><td><a href="https://github.com/myronliu347/vue-carbon" target="_blank" rel="noopener">https://github.com/myronliu347/vue-carbon</a></td></tr><tr><td>vue-beauty</td><td>vue-beauty - 由vue和ant design创建的优美UI组件</td><td><a href="https://github.com/FE-Driver/vue-beauty" target="_blank" rel="noopener">https://github.com/FE-Driver/vue-beauty</a></td></tr><tr><td>vue-blu</td><td>vue-blu - 帮助你轻松创建web应用</td><td><a href="https://github.com/chenz24/vue-blu" target="_blank" rel="noopener">https://github.com/chenz24/vue-blu</a></td></tr><tr><td>vueAdmin</td><td>vueAdmin - 基于vuejs2和element的简单的管理员模板</td><td><a href="https://github.com/taylorchen709/vueAdmin" target="_blank" rel="noopener">https://github.com/taylorchen709/vueAdmin</a></td></tr><tr><td>vue-syntax-highlight</td><td>vue-syntax-highlight - Sublime Text语法高亮</td><td><a href="https://github.com/vuejs/vue-syntax-highlight" target="_blank" rel="noopener">https://github.com/vuejs/vue-syntax-highlight</a></td></tr><tr><td>vue-infinite-scroll</td><td>vue-infinite-scroll - VueJS的无限滚动指令</td><td><a href="https://github.com/ElemeFE/vue-infinite-scroll" target="_blank" rel="noopener">https://github.com/ElemeFE/vue-infinite-scroll</a></td></tr><tr><td>Vue.Draggable</td><td>Vue.Draggable - 实现拖放和视图模型数组同步</td><td><a href="https://github.com/David-Desmaisons/Vue.Draggable" target="_blank" rel="noopener">https://github.com/David-Desmaisons/Vue.Draggable</a></td></tr><tr><td>vue-awesome-swiper</td><td>vue-awesome-swiper - vue.js触摸滑动组件</td><td><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">https://github.com/surmon-china/vue-awesome-swiper</a></td></tr><tr><td>vue-calendar</td><td>vue-calendar - 日期选择插件</td><td><a href="https://github.com/jinzhe/vue-calendar" target="_blank" rel="noopener">https://github.com/jinzhe/vue-calendar</a></td></tr><tr><td>bootstrap-vue</td><td>bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件</td><td><a href="https://github.com/pi0/bootstrap-vue" target="_blank" rel="noopener">https://github.com/pi0/bootstrap-vue</a></td></tr><tr><td>vue-swipe</td><td>vue-swipe - VueJS触摸滑块</td><td><a href="https://github.com/ElemeFE/vue-swipe" target="_blank" rel="noopener">https://github.com/ElemeFE/vue-swipe</a></td></tr><tr><td>vue-amap</td><td>vue-amap - 基于Vue 2和高德地图的地图组件</td><td><a href="https://github.com/ElemeFE/vue-amap" target="_blank" rel="noopener">https://github.com/ElemeFE/vue-amap</a></td></tr><tr><td>vue-chartjs</td><td>vue-chartjs - vue中的Chartjs的封装</td><td><a href="https://github.com/apertureless/vue-chartjs" target="_blank" rel="noopener">https://github.com/apertureless/vue-chartjs</a></td></tr><tr><td>vue-datepicker</td><td>vue-datepicker - 日历和日期选择组件</td><td><a href="https://github.com/hilongjw/vue-datepicker" target="_blank" rel="noopener">https://github.com/hilongjw/vue-datepicker</a></td></tr><tr><td>markcook</td><td>markcook - 好看的markdown编辑器</td><td><a href="https://github.com/jrainlau/markcook" target="_blank" rel="noopener">https://github.com/jrainlau/markcook</a></td></tr><tr><td>vue-google-maps</td><td>vue-google-maps - 带有双向数据绑定Google地图组件</td><td><a href="https://github.com/GuillaumeLeclerc/vue-google-maps" target="_blank" rel="noopener">https://github.com/GuillaumeLeclerc/vue-google-maps</a></td></tr><tr><td>vue-progressbar</td><td>vue-progressbar - vue轻量级进度条</td><td><a href="https://github.com/hilongjw/vue-progressbar" target="_blank" rel="noopener">https://github.com/hilongjw/vue-progressbar</a></td></tr><tr><td>vue-picture-input</td><td>vue-picture-input - 移动友好的图片文件输入组件</td><td><a href="https://github.com/alessiomaffeis/vue-picture-input" target="_blank" rel="noopener">https://github.com/alessiomaffeis/vue-picture-input</a></td></tr><tr><td>vue-infinite-loading</td><td>vue-infinite-loading - VueJS的无限滚动插件</td><td><a href="https://github.com/PeachScript/vue-infinite-loading" target="_blank" rel="noopener">https://github.com/PeachScript/vue-infinite-loading</a></td></tr><tr><td>vue-upload-component</td><td>vue-upload-component - Vuejs文件上传组件</td><td><a href="https://github.com/lian-yue/vue-upload-component" target="_blank" rel="noopener">https://github.com/lian-yue/vue-upload-component</a></td></tr><tr><td>vue-datetime-picker</td><td>vue-datetime-picker - 日期时间选择控件</td><td><a href="https://github.com/Haixing-Hu/vue-datetime-picker" target="_blank" rel="noopener">https://github.com/Haixing-Hu/vue-datetime-picker</a></td></tr><tr><td>vue-scroller</td><td>vue-scroller - Vonic UI的功能性组件</td><td><a href="https://github.com/wangdahoo/vue-scroller" target="_blank" rel="noopener">https://github.com/wangdahoo/vue-scroller</a></td></tr><tr><td>vue2-calendar</td><td>vue2-calendar - 支持lunar和日期事件的日期选择器</td><td><a href="https://github.com/icai/vue2-calendar" target="_blank" rel="noopener">https://github.com/icai/vue2-calendar</a></td></tr><tr><td>vue-video-player</td><td>vue-video-player - VueJS视频及直播播放器</td><td><a href="https://github.com/surmon-china/vue-video-player" target="_blank" rel="noopener">https://github.com/surmon-china/vue-video-player</a></td></tr><tr><td>vue-fullcalendar</td><td>vue-fullcalendar - 基于vue.js的全日历组件</td><td><a href="https://github.com/Wanderxx/vue-fullcalendar" target="_blank" rel="noopener">https://github.com/Wanderxx/vue-fullcalendar</a></td></tr><tr><td>rubik</td><td>rubik - 基于Vuejs2的开源 UI 组件库</td><td><a href="https://github.com/ccforward/rubik" target="_blank" rel="noopener">https://github.com/ccforward/rubik</a></td></tr><tr><td>VueStar</td><td>VueStar - 带星星动画的vue点赞按钮</td><td><a href="https://github.com/OYsun/VueStar" target="_blank" rel="noopener">https://github.com/OYsun/VueStar</a></td></tr><tr><td>vue-mugen-scroll</td><td>vue-mugen-scroll - 无限滚动组件</td><td><a href="https://github.com/egoist/vue-mugen-scroll" target="_blank" rel="noopener">https://github.com/egoist/vue-mugen-scroll</a></td></tr><tr><td>mint-loadmore</td><td>mint-loadmore - VueJS的双向下拉刷新组件</td><td><a href="https://github.com/mint-ui/mint-loadmore" target="_blank" rel="noopener">https://github.com/mint-ui/mint-loadmore</a></td></tr><tr><td>vue-tables-2</td><td>vue-tables-2 - 显示数据的bootstrap样式网格</td><td><a href="https://github.com/matfish2/vue-tables-2" target="_blank" rel="noopener">https://github.com/matfish2/vue-tables-2</a></td></tr><tr><td>vue-virtual-scroller</td><td>vue-virtual-scroller - 带任意数目数据的顺畅的滚动</td><td><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">https://github.com/Akryum/vue-virtual-scroller</a></td></tr><tr><td>DataVisualization</td><td>DataVisualization - 数据可视化</td><td><a href="https://github.com/SimonZhangITer/DataVisualization" target="_blank" rel="noopener">https://github.com/SimonZhangITer/DataVisualization</a></td></tr><tr><td>vue-quill-editor</td><td>vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器</td><td><a href="https://github.com/surmon-china/vue-quill-editor" target="_blank" rel="noopener">https://github.com/surmon-china/vue-quill-editor</a></td></tr><tr><td>Vueditor</td><td>Vueditor - 所见即所得的编辑器</td><td><a href="https://github.com/hifarer/Vueditor" target="_blank" rel="noopener">https://github.com/hifarer/Vueditor</a></td></tr><tr><td>vue-html5-editor</td><td>vue-html5-editor - html5所见即所得编辑器</td><td><a href="https://github.com/PeakTai/vue-html5-editor" target="_blank" rel="noopener">https://github.com/PeakTai/vue-html5-editor</a></td></tr><tr><td>vue-msgbox</td><td>vue-msgbox - vuejs的消息框</td><td><a href="https://github.com/ElemeFE/vue-msgbox" target="_blank" rel="noopener">https://github.com/ElemeFE/vue-msgbox</a></td></tr><tr><td>vue-slider</td><td>vue-slider - vue 滑动组件</td><td><a href="https://github.com/warpcgd/vue-slider" target="_blank" rel="noopener">https://github.com/warpcgd/vue-slider</a></td></tr><tr><td>vue-core-image-upload</td><td>vue-core-image-upload - 轻量级的vue上传插件</td><td><a href="https://github.com/Vanthink-UED/vue-core-image-upload" target="_blank" rel="noopener">https://github.com/Vanthink-UED/vue-core-image-upload</a></td></tr><tr><td>vue-slide</td><td>vue-slide - vue轻量级滑动组件</td><td><a href="https://github.com/hilongjw/vue-slide" target="_blank" rel="noopener">https://github.com/hilongjw/vue-slide</a></td></tr><tr><td>vue-lazyload-img</td><td>vue-lazyload-img - 移动优化的vue图片懒加载插件</td><td><a href="https://github.com/JALBAA/vue-lazyload-img" target="_blank" rel="noopener">https://github.com/JALBAA/vue-lazyload-img</a></td></tr><tr><td>vue-drag-and-drop-list</td><td>vue-drag-and-drop-list - 创建排序列表的Vue指令</td><td><a href="https://github.com/Alex-fun/vue-drag-and-drop-list" target="_blank" rel="noopener">https://github.com/Alex-fun/vue-drag-and-drop-list</a></td></tr><tr><td>vue-progressive-image</td><td>vue-progressive-image - Vue的渐进图像加载插件</td><td><a href="https://github.com/MatteoGabriele/vue-progressive-image" target="_blank" rel="noopener">https://github.com/MatteoGabriele/vue-progressive-image</a></td></tr><tr><td>vuwe</td><td>vuwe - 基于微信WeUI所开发的专用于Vue2的组件库</td><td><a href="https://github.com/vuwe/vuwe" target="_blank" rel="noopener">https://github.com/vuwe/vuwe</a></td></tr><tr><td>vue-dropzone</td><td>vue-dropzone - 用于文件上传的Vue组件</td><td><a href="https://github.com/rowanwins/vue-dropzone" target="_blank" rel="noopener">https://github.com/rowanwins/vue-dropzone</a></td></tr><tr><td>vue-charts</td><td>vue-charts - 轻松渲染一个图表</td><td><a href="https://github.com/hchstera/vue-charts" target="_blank" rel="noopener">https://github.com/hchstera/vue-charts</a></td></tr><tr><td>vue-swiper</td><td>vue-swiper - 易于使用的滑块组件</td><td><a href="https://github.com/weilao/vue-swiper" target="_blank" rel="noopener">https://github.com/weilao/vue-swiper</a></td></tr><tr><td>vue-images</td><td>vue-images - 显示一组图片的lightbox组件</td><td><a href="https://github.com/littlewin-wang/vue-images" target="_blank" rel="noopener">https://github.com/littlewin-wang/vue-images</a></td></tr><tr><td>vue-carousel-3d</td><td>vue-carousel-3d - VueJS的3D轮播组件</td><td><a href="https://github.com/Wlada/vue-carousel-3d" target="_blank" rel="noopener">https://github.com/Wlada/vue-carousel-3d</a></td></tr><tr><td>vue-region-picker</td><td>vue-region-picker - 选择中国的省份市和地区</td><td><a href="https://github.com/QingWei-Li/vue-region-picker" target="_blank" rel="noopener">https://github.com/QingWei-Li/vue-region-picker</a></td></tr><tr><td>vue-typer</td><td>vue-typer - 模拟用户输入选择和删除文本的Vue组件</td><td><a href="https://github.com/cngu/vue-typer" target="_blank" rel="noopener">https://github.com/cngu/vue-typer</a></td></tr><tr><td>vue-impression</td><td>vue-impression - 移动Vuejs2 UI元素</td><td><a href="https://github.com/NewDadaFE/vue-impression" target="_blank" rel="noopener">https://github.com/NewDadaFE/vue-impression</a></td></tr><tr><td>vue-datatable</td><td>vue-datatable - 使用Vuejs创建的DataTableView</td><td><a href="https://github.com/galenyuan/vue-datatable" target="_blank" rel="noopener">https://github.com/galenyuan/vue-datatable</a></td></tr><tr><td>vue-instant</td><td>vue-instant - 轻松创建自动提示的自定义搜索控件</td><td><a href="https://github.com/santiblanko/vue-instant" target="_blank" rel="noopener">https://github.com/santiblanko/vue-instant</a></td></tr><tr><td>vue-dragging</td><td>vue-dragging - 使元素可以拖拽</td><td><a href="https://github.com/hilongjw/vue-dragging" target="_blank" rel="noopener">https://github.com/hilongjw/vue-dragging</a></td></tr><tr><td>vue-slider-component</td><td>vue-slider-component - 在vue1和vue2中使用滑块</td><td><a href="https://github.com/NightCatSama/vue-slider-component" target="_blank" rel="noopener">https://github.com/NightCatSama/vue-slider-component</a></td></tr><tr><td>vue2-loading-bar</td><td>vue2-loading-bar - 最简单的仿Youtube加载条视图</td><td><a href="https://github.com/BosNaufal/vue2-loading-bar" target="_blank" rel="noopener">https://github.com/BosNaufal/vue2-loading-bar</a></td></tr><tr><td>vue-datepicker</td><td>vue-datepicker - 漂亮的Vue日期选择器组件</td><td><a href="https://github.com/weifeiyue/vue-datepicker" target="_blank" rel="noopener">https://github.com/weifeiyue/vue-datepicker</a></td></tr><tr><td>vue-video</td><td>vue-video - Vue.js的HTML5视频播放器</td><td><a href="https://github.com/hilongjw/vue-video" target="_blank" rel="noopener">https://github.com/hilongjw/vue-video</a></td></tr><tr><td>vue-toast-mobile</td><td>vue-toast-mobile - VueJS的toast插件</td><td><a href="https://github.com/ElemeFE/vue-toast-mobile" target="_blank" rel="noopener">https://github.com/ElemeFE/vue-toast-mobile</a></td></tr><tr><td>vue-image-crop-upload</td><td>vue-image-crop-upload - vue图片剪裁上传组件</td><td><a href="https://github.com/dai-siki/vue-image-crop-upload" target="_blank" rel="noopener">https://github.com/dai-siki/vue-image-crop-upload</a></td></tr><tr><td>vue-tooltip</td><td>vue-tooltip - 带绑定信息提示的提示工具</td><td><a href="https://github.com/Akryum/vue-tooltip" target="_blank" rel="noopener">https://github.com/Akryum/vue-tooltip</a></td></tr><tr><td>vue-highcharts</td><td>vue-highcharts - HighCharts组件</td><td><a href="https://github.com/weizhenye/vue-highcharts" target="_blank" rel="noopener">https://github.com/weizhenye/vue-highcharts</a></td></tr><tr><td>vue-touch-ripple</td><td>vue-touch-ripple - vuejs的触摸ripple组件</td><td><a href="https://github.com/surmon-china/vue-touch-ripple" target="_blank" rel="noopener">https://github.com/surmon-china/vue-touch-ripple</a></td></tr><tr><td>coffeebreak</td><td>coffeebreak - 实时编辑CSS组件工具</td><td><a href="https://github.com/Kocisov/coffeebreak" target="_blank" rel="noopener">https://github.com/Kocisov/coffeebreak</a></td></tr><tr><td>vue-datasource</td><td>vue-datasource - 创建VueJS动态表格</td><td><a href="https://github.com/coderdiaz/vue-datasource" target="_blank" rel="noopener">https://github.com/coderdiaz/vue-datasource</a></td></tr><tr><td>vue2-timepicker</td><td>vue2-timepicker - 下拉时间选择器</td><td><a href="https://github.com/phoenixwong/vue2-timepicker" target="_blank" rel="noopener">https://github.com/phoenixwong/vue2-timepicker</a></td></tr><tr><td>vue-date-picker</td><td>vue-date-picker - VueJS日期选择器组件</td><td><a href="https://github.com/Bubblings/vue-date-picker" target="_blank" rel="noopener">https://github.com/Bubblings/vue-date-picker</a></td></tr><tr><td>vue-scrollbar</td><td>vue-scrollbar - 最简单的滚动区域组件</td><td><a href="https://github.com/BosNaufal/vue-scrollbar" target="_blank" rel="noopener">https://github.com/BosNaufal/vue-scrollbar</a></td></tr><tr><td>vue-quill</td><td>vue-quill - vue组件构建quill编辑器</td><td><a href="https://github.com/CroudSupport/vue-quill" target="_blank" rel="noopener">https://github.com/CroudSupport/vue-quill</a></td></tr><tr><td>vue-google-signin-button</td><td>vue-google-signin-button - 导入谷歌登录按钮</td><td><a href="https://github.com/phanan/vue-google-signin-button" target="_blank" rel="noopener">https://github.com/phanan/vue-google-signin-button</a></td></tr><tr><td>vue-svgicon</td><td>vue-svgicon - 创建svg图标组件的工具</td><td><a href="https://github.com/MMF-FE/vue-svgicon" target="_blank" rel="noopener">https://github.com/MMF-FE/vue-svgicon</a></td></tr><tr><td>vue-float-label</td><td>vue-float-label - VueJS浮动标签模式</td><td><a href="https://github.com/bkzl/vue-float-label" target="_blank" rel="noopener">https://github.com/bkzl/vue-float-label</a></td></tr><tr><td>vue-baidu-map</td><td>vue-baidu-map - 基于 Vue 2的百度地图组件库</td><td><a href="https://github.com/Dafrok/vue-baidu-map" target="_blank" rel="noopener">https://github.com/Dafrok/vue-baidu-map</a></td></tr><tr><td>vue-social-sharing</td><td>vue-social-sharing - 社交分享组件</td><td><a href="https://github.com/nicolasbeauvais/vue-social-sharing" target="_blank" rel="noopener">https://github.com/nicolasbeauvais/vue-social-sharing</a></td></tr><tr><td>vue2-editor</td><td>vue2-editor - HTML编辑器</td><td><a href="https://github.com/davidroyer/vue2-editor" target="_blank" rel="noopener">https://github.com/davidroyer/vue2-editor</a></td></tr><tr><td>vue-tagsinput</td><td>vue-tagsinput - 基于VueJS的标签组件</td><td><a href="https://github.com/Ginhing/vue-tagsinput" target="_blank" rel="noopener">https://github.com/Ginhing/vue-tagsinput</a></td></tr><tr><td>vue-easy-slider</td><td>vue-easy-slider - Vue 2.x的滑块组件</td><td><a href="https://github.com/shhdgit/vue-easy-slider" target="_blank" rel="noopener">https://github.com/shhdgit/vue-easy-slider</a></td></tr><tr><td>datepicker</td><td>datepicker - 基于flatpickr的时间选择组件</td><td><a href="https://github.com/vue-bulma/datepicker" target="_blank" rel="noopener">https://github.com/vue-bulma/datepicker</a></td></tr><tr><td>vue-chart</td><td>vue-chart - 强大的高速的vue图表解析</td><td><a href="https://github.com/miaolz123/vue-chart" target="_blank" rel="noopener">https://github.com/miaolz123/vue-chart</a></td></tr><tr><td>vue-music-master</td><td>vue-music-master - vue手机端网页音乐播放器</td><td><a href="https://github.com/yunyi1895/vue-music-master" target="_blank" rel="noopener">https://github.com/yunyi1895/vue-music-master</a></td></tr><tr><td>handsontable</td><td>handsontable - 网页表格组件</td><td><a href="https://github.com/vue-bulma/handsontable" target="_blank" rel="noopener">https://github.com/vue-bulma/handsontable</a></td></tr><tr><td>vue-simplemde</td><td>vue-simplemde - VueJS的Markdown编辑器组件</td><td><a href="https://github.com/F-loat/vue-simplemde" target="_blank" rel="noopener">https://github.com/F-loat/vue-simplemde</a></td></tr><tr><td>vue-popup-mixin</td><td>vue-popup-mixin - 用于管理弹出框的遮盖层</td><td><a href="https://github.com/myronliu347/vue-popup-mixin" target="_blank" rel="noopener">https://github.com/myronliu347/vue-popup-mixin</a></td></tr><tr><td>cubeex</td><td>cubeex - 包含一套完整的移动UI</td><td><a href="https://github.com/fangyongbao/cubeex" target="_blank" rel="noopener">https://github.com/fangyongbao/cubeex</a></td></tr><tr><td>vue-fullcalendar</td><td>vue-fullcalendar - vue FullCalendar封装</td><td><a href="https://github.com/CroudSupport/vue-fullcalendar" target="_blank" rel="noopener">https://github.com/CroudSupport/vue-fullcalendar</a></td></tr><tr><td>vue-material-design</td><td>vue-material-design - Vue MD风格组件</td><td><a href="https://github.com/loujiayu/vue-material-design" target="_blank" rel="noopener">https://github.com/loujiayu/vue-material-design</a></td></tr><tr><td>vue-morris</td><td>vue-morris - Vuejs组件封装Morrisjs库</td><td><a href="https://github.com/bbonnin/vue-morris" target="_blank" rel="noopener">https://github.com/bbonnin/vue-morris</a></td></tr><tr><td>we-vue</td><td>we-vue - Vue2及weui1开发的组件</td><td><a href="https://github.com/tianyong90/we-vue" target="_blank" rel="noopener">https://github.com/tianyong90/we-vue</a></td></tr><tr><td>vue-image-clip</td><td>vue-image-clip - 基于vue的图像剪辑组件</td><td><a href="https://github.com/legeneek/vue-image-clip" target="_blank" rel="noopener">https://github.com/legeneek/vue-image-clip</a></td></tr><tr><td>vue-bootstrap-table</td><td>vue-bootstrap-table - 可排序可检索的表格</td><td><a href="https://github.com/jbaysolutions/vue-bootstrap-table" target="_blank" rel="noopener">https://github.com/jbaysolutions/vue-bootstrap-table</a></td></tr><tr><td>vue-radial-progress</td><td>vue-radial-progress - Vue.js放射性进度条组件</td><td><a href="https://github.com/wyzant-dev/vue-radial-progress" target="_blank" rel="noopener">https://github.com/wyzant-dev/vue-radial-progress</a></td></tr><tr><td>vue-slick</td><td>vue-slick - 实现流畅轮播框的vue组件</td><td><a href="https://github.com/staskjs/vue-slick" target="_blank" rel="noopener">https://github.com/staskjs/vue-slick</a></td></tr><tr><td>vue-pull-to-refresh</td><td>vue-pull-to-refresh - Vue2的上拉下拉</td><td><a href="https://github.com/bajian/vue-pull-to-refresh" target="_blank" rel="noopener">https://github.com/bajian/vue-pull-to-refresh</a></td></tr><tr><td>vue-form-2</td><td>vue-form-2 - 全面的HTML表单管理的解决方案</td><td><a href="https://github.com/matfish2/vue-form-2" target="_blank" rel="noopener">https://github.com/matfish2/vue-form-2</a></td></tr><tr><td>vue-side-nav</td><td>vue-side-nav - 响应式的侧边导航</td><td><a href="https://github.com/vue-comps/vue-side-nav" target="_blank" rel="noopener">https://github.com/vue-comps/vue-side-nav</a></td></tr><tr><td>mint-indicator</td><td>mint-indicator - VueJS移动加载指示器插件</td><td><a href="https://github.com/mint-ui/mint-indicator" target="_blank" rel="noopener">https://github.com/mint-ui/mint-indicator</a></td></tr><tr><td>chartjs</td><td>chartjs - Vue Bulma的chartjs组件</td><td><a href="https://github.com/vue-bulma/chartjs" target="_blank" rel="noopener">https://github.com/vue-bulma/chartjs</a></td></tr><tr><td>vue-scroll</td><td>vue-scroll - vue滚动</td><td><a href="https://github.com/suguangwen/vue-scroll" target="_blank" rel="noopener">https://github.com/suguangwen/vue-scroll</a></td></tr><tr><td>vue-ripple</td><td>vue-ripple - 制作谷歌MD风格涟漪效果的Vue组件</td><td><a href="https://github.com/BosNaufal/vue-ripple" target="_blank" rel="noopener">https://github.com/BosNaufal/vue-ripple</a></td></tr><tr><td>vue-touch-keyboard</td><td>vue-touch-keyboard - VueJS虚拟键盘组件</td><td><a href="https://github.com/icebob/vue-touch-keyboard" target="_blank" rel="noopener">https://github.com/icebob/vue-touch-keyboard</a></td></tr><tr><td>vue-chartkick</td><td>vue-chartkick - VueJS一行代码实现优美图表</td><td><a href="https://github.com/ankane/vue-chartkick" target="_blank" rel="noopener">https://github.com/ankane/vue-chartkick</a></td></tr><tr><td>vue-ztree</td><td>vue-ztree - 用 vue 写的树层级组件</td><td><a href="https://github.com/lisiyizu/vue-ztree" target="_blank" rel="noopener">https://github.com/lisiyizu/vue-ztree</a></td></tr><tr><td>vue-m-carousel</td><td>vue-m-carousel - vue 移动端轮播组件</td><td><a href="https://github.com/shiye515/vue-m-carousel" target="_blank" rel="noopener">https://github.com/shiye515/vue-m-carousel</a></td></tr><tr><td>vue-datepicker-simple</td><td>vue-datepicker-simple - 基于vue的日期选择器</td><td><a href="https://github.com/dai-siki/vue-datepicker-simple" target="_blank" rel="noopener">https://github.com/dai-siki/vue-datepicker-simple</a></td></tr><tr><td>vue-tabs</td><td>vue-tabs - 多tab页轻型框架</td><td><a href="https://github.com/alexqdjay/vue-tabs" target="_blank" rel="noopener">https://github.com/alexqdjay/vue-tabs</a></td></tr><tr><td>vue-verify-pop</td><td>vue-verify-pop - 带气泡提示的vue校验插件</td><td><a href="https://github.com/aweiu/vue-verify-pop" target="_blank" rel="noopener">https://github.com/aweiu/vue-verify-pop</a></td></tr><tr><td>vue-parallax</td><td>vue-parallax - 整洁的视觉效果</td><td><a href="https://github.com/vue-comps/vue-parallax" target="_blank" rel="noopener">https://github.com/vue-comps/vue-parallax</a></td></tr><tr><td>vue-img-loader</td><td>vue-img-loader - 图片加载UI组件</td><td><a href="https://github.com/JackGit/vue-img-loader" target="_blank" rel="noopener">https://github.com/JackGit/vue-img-loader</a></td></tr><tr><td>vue-typewriter</td><td>vue-typewriter - vue组件类型</td><td><a href="https://github.com/eduardostuart/vue-typewriter" target="_blank" rel="noopener">https://github.com/eduardostuart/vue-typewriter</a></td></tr><tr><td>vue-smoothscroll</td><td>vue-smoothscroll - smoothscroll的VueJS版本</td><td><a href="https://github.com/Teddy-Zhu/vue-smoothscroll" target="_blank" rel="noopener">https://github.com/Teddy-Zhu/vue-smoothscroll</a></td></tr><tr><td>vue-city</td><td>vue-city - 城市选择器</td><td><a href="https://github.com/xinxingyu/vue-city" target="_blank" rel="noopener">https://github.com/xinxingyu/vue-city</a></td></tr><tr><td>vue-tree</td><td>vue-tree - vue树视图组件</td><td><a href="https://github.com/weibangtuo/vue-tree" target="_blank" rel="noopener">https://github.com/weibangtuo/vue-tree</a></td></tr><tr><td>vue-ios-alertview</td><td>vue-ios-alertview - iOS7+ 风格的alertview服务</td><td><a href="https://github.com/Treri/vue-ios-alertview" target="_blank" rel="noopener">https://github.com/Treri/vue-ios-alertview</a></td></tr><tr><td>dd-vue-component</td><td>dd-vue-component - 订单来了的公共组件库</td><td><a href="https://github.com/ibufu/dd-vue-component" target="_blank" rel="noopener">https://github.com/ibufu/dd-vue-component</a></td></tr><tr><td>paco-ui-vue</td><td>paco-ui-vue - PACOUI的vue组件</td><td><a href="https://github.com/yeseason/paco-ui-vue" target="_blank" rel="noopener">https://github.com/yeseason/paco-ui-vue</a></td></tr><tr><td>vue-cmap</td><td>vue-cmap - Vue China map可视化组件</td><td><a href="https://github.com/doodlewind/vue-cmap" target="_blank" rel="noopener">https://github.com/doodlewind/vue-cmap</a></td></tr><tr><td>vue-button</td><td>vue-button - Vue按钮组件</td><td><a href="https://github.com/steven5538/vue-button" target="_blank" rel="noopener">https://github.com/steven5538/vue-button</a></td></tr><tr><td>vue.js</td><td>vue.js - 流行的轻量高效的前端组件化方案</td><td><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></td></tr><tr><td>vue-admin</td><td>vue-admin - Vue管理面板框架</td><td><a href="https://github.com/fundon/vue-admin" target="_blank" rel="noopener">https://github.com/fundon/vue-admin</a></td></tr><tr><td>electron-vue</td><td>electron-vue - Electron及VueJS快速启动样板</td><td><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">https://github.com/SimulatedGREG/electron-vue</a></td></tr><tr><td>vue-2.0-boilerplate</td><td>vue-2.0-boilerplate - Vue2单页应用样板</td><td><a href="https://github.com/petervmeijgaard/vue-2.0-boilerplate" target="_blank" rel="noopener">https://github.com/petervmeijgaard/vue-2.0-boilerplate</a></td></tr><tr><td>vue-spa-template</td><td>vue-spa-template - 前后端分离后的单页应用开发</td><td><a href="https://github.com/hanan198501/vue-spa-template" target="_blank" rel="noopener">https://github.com/hanan198501/vue-spa-template</a></td></tr><tr><td>Framework7-Vue</td><td>Framework7-Vue - VueJS与Framework7结合</td><td><a href="https://github.com/nolimits4web/Framework7-Vue" target="_blank" rel="noopener">https://github.com/nolimits4web/Framework7-Vue</a></td></tr><tr><td>vue-bulma</td><td>vue-bulma - 轻量级高性能MVVM Admin UI框架</td><td><a href="https://github.com/wangxg2016/vue-bulma" target="_blank" rel="noopener">https://github.com/wangxg2016/vue-bulma</a></td></tr><tr><td>vue-webgulp</td><td>vue-webgulp - 仿VueJS Vue loader示例</td><td><a href="https://github.com/rodzzlessa24/vue-webgulp" target="_blank" rel="noopener">https://github.com/rodzzlessa24/vue-webgulp</a></td></tr><tr><td>vue-element-starter</td><td>vue-element-starter - vue启动页</td><td><a href="https://github.com/Metnew/vue-element-starter" target="_blank" rel="noopener">https://github.com/Metnew/vue-element-starter</a></td></tr><tr><td>vuex</td><td>vuex - 专为 Vue.js 应用程序开发的状态管理模式</td><td><a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">https://github.com/vuejs/vuex</a></td></tr><tr><td>vuelidate</td><td>vuelidate - 简单轻量级的基于模块的Vue.js验证</td><td><a href="https://github.com/monterail/vuelidate" target="_blank" rel="noopener">https://github.com/monterail/vuelidate</a></td></tr><tr><td>qingcheng</td><td>qingcheng - qingcheng主题</td><td><a href="https://github.com/zerqu/qingcheng" target="_blank" rel="noopener">https://github.com/zerqu/qingcheng</a></td></tr><tr><td>vue-desktop</td><td>vue-desktop - 创建管理面板网站的UI库</td><td><a href="https://github.com/ElemeFE/vue-desktop" target="_blank" rel="noopener">https://github.com/ElemeFE/vue-desktop</a></td></tr><tr><td>vue-meta</td><td>vue-meta - 管理app的meta信息</td><td><a href="https://github.com/declandewet/vue-meta" target="_blank" rel="noopener">https://github.com/declandewet/vue-meta</a></td></tr><tr><td>vue-axios</td><td>vue-axios - 将axios整合到VueJS的封装</td><td><a href="https://github.com/imcvampire/vue-axios" target="_blank" rel="noopener">https://github.com/imcvampire/vue-axios</a></td></tr><tr><td>vue-svg-icon</td><td>vue-svg-icon - vue2的可变彩色svg图标方案</td><td><a href="https://github.com/cenkai88/vue-svg-icon" target="_blank" rel="noopener">https://github.com/cenkai88/vue-svg-icon</a></td></tr><tr><td>avoriaz</td><td>avoriaz - VueJS测试实用工具库</td><td><a href="https://github.com/eddyerburgh/avoriaz" target="_blank" rel="noopener">https://github.com/eddyerburgh/avoriaz</a></td></tr><tr><td>vue-framework7</td><td>vue-framework7 - 结合VueJS使用的Framework7组件</td><td><a href="https://github.com/lmk123/vue-framework7" target="_blank" rel="noopener">https://github.com/lmk123/vue-framework7</a></td></tr><tr><td>vue-bootstrap-modal</td><td>vue-bootstrap-modal - vue的Bootstrap样式组件</td><td><a href="https://github.com/Coffcer/vue-bootstrap-modal" target="_blank" rel="noopener">https://github.com/Coffcer/vue-bootstrap-modal</a></td></tr><tr><td>vuep</td><td>vuep - 用实时编辑和预览来渲染Vue组件</td><td><a href="https://github.com/QingWei-Li/vuep" target="_blank" rel="noopener">https://github.com/QingWei-Li/vuep</a></td></tr><tr><td>vue-online</td><td>vue-online - reactive的在线和离线组件</td><td><a href="https://github.com/Sopamo/vue-online" target="_blank" rel="noopener">https://github.com/Sopamo/vue-online</a></td></tr><tr><td>vue-lazy-render</td><td>vue-lazy-render - 用于Vue组件的延迟渲染</td><td><a href="https://github.com/yeyuqiudeng/vue-lazy-render" target="_blank" rel="noopener">https://github.com/yeyuqiudeng/vue-lazy-render</a></td></tr><tr><td>vue-password-strength-meter</td><td>vue-password-strength-meter - 交互式密码强度计</td><td><a href="https://github.com/apertureless/vue-password-strength-meter" target="_blank" rel="noopener">https://github.com/apertureless/vue-password-strength-meter</a></td></tr><tr><td>element-admin</td><td>element-admin - 支持 vuecli 的 Element UI 的后台模板</td><td><a href="https://github.com/lynzz/element-admin" target="_blank" rel="noopener">https://github.com/lynzz/element-admin</a></td></tr><tr><td>vue-electron</td><td>vue-electron - 将选择的API封装到Vue对象中的插件</td><td><a href="https://github.com/SimulatedGREG/vue-electron" target="_blank" rel="noopener">https://github.com/SimulatedGREG/vue-electron</a></td></tr><tr><td>cleave</td><td>cleave - 基于cleave.js的Cleave组件</td><td><a href="https://github.com/vue-bulma/cleave" target="_blank" rel="noopener">https://github.com/vue-bulma/cleave</a></td></tr><tr><td>vue-events</td><td>vue-events - 简化事件的VueJS插件</td><td><a href="https://github.com/cklmercer/vue-events" target="_blank" rel="noopener">https://github.com/cklmercer/vue-events</a></td></tr><tr><td>vue-shortkey</td><td>vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件</td><td><a href="https://github.com/iFgR/vue-shortkey" target="_blank" rel="noopener">https://github.com/iFgR/vue-shortkey</a></td></tr><tr><td>vue-cordova</td><td>vue-cordova - Cordova的VueJS插件</td><td><a href="https://github.com/kartsims/vue-cordova" target="_blank" rel="noopener">https://github.com/kartsims/vue-cordova</a></td></tr><tr><td>vue-router-transition</td><td>vue-router-transition - 页面过渡插件</td><td><a href="https://github.com/weinot/vue-router-transition" target="_blank" rel="noopener">https://github.com/weinot/vue-router-transition</a></td></tr><tr><td>vue-gesture</td><td>vue-gesture - VueJS的手势事件插件</td><td><a href="https://github.com/mlyknown/vue-gesture" target="_blank" rel="noopener">https://github.com/mlyknown/vue-gesture</a></td></tr><tr><td>http-vue-loader</td><td>http-vue-loader - 从html及js环境加载vue文件</td><td><a href="https://github.com/FranckFreiburger/http-vue-loader" target="_blank" rel="noopener">https://github.com/FranckFreiburger/http-vue-loader</a></td></tr><tr><td>vue-qart</td><td>vue-qart - 用于qartjs的Vue2指令</td><td><a href="https://github.com/superman66/vue-qart" target="_blank" rel="noopener">https://github.com/superman66/vue-qart</a></td></tr><tr><td>vuemit</td><td>vuemit - 处理VueJS事件</td><td><a href="https://github.com/gocanto/vuemit" target="_blank" rel="noopener">https://github.com/gocanto/vuemit</a></td></tr><tr><td>vue-websocket</td><td>vue-websocket - VueJS的Websocket插件</td><td><a href="https://github.com/icebob/vue-websocket" target="_blank" rel="noopener">https://github.com/icebob/vue-websocket</a></td></tr><tr><td>vue-local-storage</td><td>vue-local-storage - 具有类型支持的Vuejs本地储存插件</td><td><a href="https://github.com/pinguinjkeke/vue-local-storage" target="_blank" rel="noopener">https://github.com/pinguinjkeke/vue-local-storage</a></td></tr><tr><td>lazy-vue</td><td>lazy-vue - 懒加载图片</td><td><a href="https://github.com/gocanto/lazy-vue" target="_blank" rel="noopener">https://github.com/gocanto/lazy-vue</a></td></tr><tr><td>vue-bus</td><td>vue-bus - VueJS的事件总线</td><td><a href="https://github.com/yangmingshan/vue-bus" target="_blank" rel="noopener">https://github.com/yangmingshan/vue-bus</a></td></tr><tr><td>vue-reactive-storage</td><td>vue-reactive-storage - vue插件的Reactive层</td><td><a href="https://github.com/ropbla9/vue-reactive-storage" target="_blank" rel="noopener">https://github.com/ropbla9/vue-reactive-storage</a></td></tr><tr><td>vue-notifications</td><td>vue-notifications - 非阻塞通知库</td><td><a href="https://github.com/se-panfilov/vue-notifications" target="_blank" rel="noopener">https://github.com/se-panfilov/vue-notifications</a></td></tr><tr><td>vue-lazy-component</td><td>vue-lazy-component - 懒加载组件或者元素的Vue指令</td><td><a href="https://github.com/Coffcer/vue-lazy-component" target="_blank" rel="noopener">https://github.com/Coffcer/vue-lazy-component</a></td></tr><tr><td>v-media-query</td><td>v-media-query - vue中添加用于配合媒体查询的方法</td><td><a href="https://github.com/AStaroverov/v-media-query" target="_blank" rel="noopener">https://github.com/AStaroverov/v-media-query</a></td></tr><tr><td>vue-observe-visibility</td><td>vue-observe-visibility - 当元素在页面上可见或隐藏时检测</td><td><a href="https://github.com/Akryum/vue-observe-visibility" target="_blank" rel="noopener">https://github.com/Akryum/vue-observe-visibility</a></td></tr><tr><td>vue-ts-loader</td><td>vue-ts-loader - 在Vue装载机检查脚本</td><td><a href="https://github.com/HerringtonDarkholme/vue-ts-loader" target="_blank" rel="noopener">https://github.com/HerringtonDarkholme/vue-ts-loader</a></td></tr><tr><td>vue-pagination-2</td><td>vue-pagination-2 - 简单通用的分页组件</td><td><a href="https://github.com/matfish2/vue-pagination-2" target="_blank" rel="noopener">https://github.com/matfish2/vue-pagination-2</a></td></tr><tr><td>vuex-i18n</td><td>vuex-i18n - 定位插件</td><td><a href="https://github.com/dkfbasel/vuex-i18n" target="_blank" rel="noopener">https://github.com/dkfbasel/vuex-i18n</a></td></tr><tr><td>Vue.resize</td><td>Vue.resize - 检测HTML调整大小事件的vue指令</td><td><a href="https://github.com/David-Desmaisons/Vue.resize" target="_blank" rel="noopener">https://github.com/David-Desmaisons/Vue.resize</a></td></tr><tr><td>vuex-shared-mutations</td><td>vuex-shared-mutations - 分享某种Vuex mutations</td><td><a href="https://github.com/xanf/vuex-shared-mutations" target="_blank" rel="noopener">https://github.com/xanf/vuex-shared-mutations</a></td></tr><tr><td>vue-file-base64</td><td>vue-file-base64 - 将文件转换为Base64的vue组件</td><td><a href="https://github.com/BosNaufal/vue-file-base64" target="_blank" rel="noopener">https://github.com/BosNaufal/vue-file-base64</a></td></tr><tr><td>modal</td><td>modal - Vue Bulma的modal组件</td><td><a href="https://github.com/vue-bulma/modal" target="_blank" rel="noopener">https://github.com/vue-bulma/modal</a></td></tr><tr><td>Famous-Vue</td><td>Famous-Vue - Famous库的vue组件</td><td><a href="https://github.com/irwansyahwii/Famous-Vue" target="_blank" rel="noopener">https://github.com/irwansyahwii/Famous-Vue</a></td></tr><tr><td>leo-vue-validator</td><td>leo-vue-validator - 异步的表单验证组件</td><td><a href="https://github.com/LeoHuiyi/leo-vue-validator" target="_blank" rel="noopener">https://github.com/LeoHuiyi/leo-vue-validator</a></td></tr><tr><td>Vue-Easy-Validator</td><td>Vue-Easy-Validator - 简单的表单验证</td><td><a href="https://github.com/MetinSeylan/Vue-Easy-Validator" target="_blank" rel="noopener">https://github.com/MetinSeylan/Vue-Easy-Validator</a></td></tr><tr><td>vue-truncate-filter</td><td>vue-truncate-filter - 截断字符串的VueJS过滤器</td><td><a href="https://github.com/imcvampire/vue-truncate-filter" target="_blank" rel="noopener">https://github.com/imcvampire/vue-truncate-filter</a></td></tr><tr><td>vue-zoombox</td><td>vue-zoombox - 一个高级zoombox</td><td><a href="https://github.com/vue-comps/vue-zoombox" target="_blank" rel="noopener">https://github.com/vue-comps/vue-zoombox</a></td></tr><tr><td>vue-input-autosize</td><td>vue-input-autosize - 基于内容自动调整文本输入的大小</td><td><a href="https://github.com/syropian/vue-input-autosize" target="_blank" rel="noopener">https://github.com/syropian/vue-input-autosize</a></td></tr><tr><td>vue-lazyloadImg</td><td>vue-lazyloadImg - 图片懒加载插件</td><td><a href="https://github.com/yodfz/vue-lazyloadImg" target="_blank" rel="noopener">https://github.com/yodfz/vue-lazyloadImg</a></td></tr><tr><td>nuxt.js</td><td>nuxt.js - 用于服务器渲染Vue app的最小化框架</td><td><a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">https://github.com/nuxt/nuxt.js</a></td></tr><tr><td>express-vue</td><td>express-vue - 简单的使用服务器端渲染vue.js</td><td><a href="https://github.com/danmademe/express-vue" target="_blank" rel="noopener">https://github.com/danmademe/express-vue</a></td></tr><tr><td>vue-ssr</td><td>vue-ssr - 非常简单的VueJS服务器端渲染模板</td><td><a href="https://github.com/ccforward/vue-ssr" target="_blank" rel="noopener">https://github.com/ccforward/vue-ssr</a></td></tr><tr><td>vue-ssr</td><td>vue-ssr - 结合Express使用Vue2服务端渲染</td><td><a href="https://github.com/hilongjw/vue-ssr" target="_blank" rel="noopener">https://github.com/hilongjw/vue-ssr</a></td></tr><tr><td>vue-easy-renderer</td><td>vue-easy-renderer - Nodejs服务端渲染</td><td><a href="https://github.com/leaves4j/vue-easy-renderer" target="_blank" rel="noopener">https://github.com/leaves4j/vue-easy-renderer</a></td></tr><tr><td>DejaVue</td><td>DejaVue - Vuejs可视化及压力测试</td><td><a href="https://github.com/MiCottOn/DejaVue" target="_blank" rel="noopener">https://github.com/MiCottOn/DejaVue</a></td></tr><tr><td>vue-play</td><td>vue-play - 展示Vue组件的最小化框架</td><td><a href="https://github.com/vue-play/vue-play" target="_blank" rel="noopener">https://github.com/vue-play/vue-play</a></td></tr><tr><td>vscode-VueHelper</td><td>vscode-VueHelper - 目前vscode最好的vue代码提示插件</td><td><a href="https://github.com/OYsun/vscode-VueHelper" target="_blank" rel="noopener">https://github.com/OYsun/vscode-VueHelper</a></td></tr><tr><td>vue-generate-component</td><td>vue-generate-component - 轻松生成Vue js组件的CLI工具</td><td><a href="https://github.com/NetanelBasal/vue-generate-component" target="_blank" rel="noopener">https://github.com/NetanelBasal/vue-generate-component</a></td></tr><tr><td>vue-multipage-cli</td><td>vue-multipage-cli - 简单的多页CLI</td><td><a href="https://github.com/xwpongithub/vue-multipage-cli" target="_blank" rel="noopener">https://github.com/xwpongithub/vue-multipage-cli</a></td></tr><tr><td>VuejsStarterKit</td><td>VuejsStarterKit - vuejs starter套件</td><td><a href="https://github.com/MetinSeylan/VuejsStarterKit" target="_blank" rel="noopener">https://github.com/MetinSeylan/VuejsStarterKit</a></td></tr><tr><td>koel</td><td>koel - 基于网络的个人音频流媒体服务</td><td><a href="https://github.com/phanan/koel" target="_blank" rel="noopener">https://github.com/phanan/koel</a></td></tr><tr><td>pagekit</td><td>pagekit - 轻量级的CMS建站系统</td><td><a href="https://github.com/pagekit/pagekit" target="_blank" rel="noopener">https://github.com/pagekit/pagekit</a></td></tr><tr><td>vuedo</td><td>vuedo - 博客平台</td><td><a href="https://github.com/Vuedo/vuedo" target="_blank" rel="noopener">https://github.com/Vuedo/vuedo</a></td></tr><tr><td>jackblog-vue</td><td>jackblog-vue - 个人博客系统</td><td><a href="https://github.com/jackhutu/jackblog-vue" target="_blank" rel="noopener">https://github.com/jackhutu/jackblog-vue</a></td></tr><tr><td>vue-cnode</td><td>vue-cnode - 重写vue版cnode社区</td><td><a href="https://github.com/lzxb/vue-cnode" target="_blank" rel="noopener">https://github.com/lzxb/vue-cnode</a></td></tr><tr><td>CMS-of-Blog</td><td>CMS-of-Blog - 博客内容管理器</td><td><a href="https://github.com/ycwalker/CMS-of-Blog" target="_blank" rel="noopener">https://github.com/ycwalker/CMS-of-Blog</a></td></tr><tr><td>rss-reader</td><td>rss-reader - 简单的rss阅读器</td><td><a href="https://github.com/mrgodhani/rss-reader" target="_blank" rel="noopener">https://github.com/mrgodhani/rss-reader</a></td></tr><tr><td>vue-ghpages-blog</td><td>vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客</td><td><a href="https://github.com/viko16/vue-ghpages-blog" target="_blank" rel="noopener">https://github.com/viko16/vue-ghpages-blog</a></td></tr><tr><td>swoole-vue-webim</td><td>swoole-vue-webim - Web版的聊天应用</td><td><a href="https://github.com/wh469012917/swoole-vue-webim" target="_blank" rel="noopener">https://github.com/wh469012917/swoole-vue-webim</a></td></tr><tr><td>vue-dashing-js</td><td>vue-dashing-js - nuvo-dashing-js的fork</td><td><a href="https://github.com/thelinuxlich/vue-dashing-js" target="_blank" rel="noopener">https://github.com/thelinuxlich/vue-dashing-js</a></td></tr><tr><td>fewords</td><td>fewords - 功能极其简单的笔记本</td><td><a href="https://github.com/sapjax/fewords" target="_blank" rel="noopener">https://github.com/sapjax/fewords</a></td></tr><tr><td>vue-blog</td><td>vue-blog - 使用Vue2.0 和Vuex的vue-blog</td><td><a href="https://github.com/surmon-china/vue-blog" target="_blank" rel="noopener">https://github.com/surmon-china/vue-blog</a></td></tr><tr><td>Vue-cnodejs</td><td>Vue-cnodejs - 基于vue重写Cnodejs.org的webapp</td><td><a href="https://github.com/shinygang/Vue-cnodejs" target="_blank" rel="noopener">https://github.com/shinygang/Vue-cnodejs</a></td></tr><tr><td>NeteaseCloudWebApp</td><td>NeteaseCloudWebApp - 高仿网易云音乐的webapp</td><td><a href="https://github.com/javaSwing/NeteaseCloudWebApp" target="_blank" rel="noopener">https://github.com/javaSwing/NeteaseCloudWebApp</a></td></tr><tr><td>vue-zhihu-daily</td><td>vue-zhihu-daily - 知乎日报 with Vuejs</td><td><a href="https://github.com/hilongjw/vue-zhihu-daily" target="_blank" rel="noopener">https://github.com/hilongjw/vue-zhihu-daily</a></td></tr><tr><td>vue-wechat</td><td>vue-wechat - vue.js开发微信app界面</td><td><a href="https://github.com/useryangtao/vue-wechat" target="_blank" rel="noopener">https://github.com/useryangtao/vue-wechat</a></td></tr><tr><td>vue2-demo</td><td>vue2-demo - 从零构建vue2 + vue-router + vuex 开发环境</td><td><a href="https://github.com/lzxb/vue2-demo" target="_blank" rel="noopener">https://github.com/lzxb/vue2-demo</a></td></tr><tr><td>eleme</td><td>eleme - 高仿饿了么app商家详情</td><td><a href="https://github.com/liangxiaojuan/eleme" target="_blank" rel="noopener">https://github.com/liangxiaojuan/eleme</a></td></tr><tr><td>vue-demo</td><td>vue-demo - vue简易留言板</td><td><a href="https://github.com/kenberkeley/vue-demo" target="_blank" rel="noopener">https://github.com/kenberkeley/vue-demo</a></td></tr><tr><td>maizuo</td><td>maizuo - vue/vuex/redux仿卖座网</td><td><a href="https://github.com/zhengguorong/maizuo" target="_blank" rel="noopener">https://github.com/zhengguorong/maizuo</a></td></tr><tr><td>spa-starter-kit</td><td>spa-starter-kit - 单页应用启动套件</td><td><a href="https://github.com/codecasts/spa-starter-kit" target="_blank" rel="noopener">https://github.com/codecasts/spa-starter-kit</a></td></tr><tr><td>vue-music</td><td>vue-music - Vue 音乐搜索播放</td><td><a href="https://github.com/Sioxas/vue-music" target="_blank" rel="noopener">https://github.com/Sioxas/vue-music</a></td></tr><tr><td>douban</td><td>douban - 模仿豆瓣前端</td><td><a href="https://github.com/jiakeqi/douban" target="_blank" rel="noopener">https://github.com/jiakeqi/douban</a></td></tr><tr><td>vue-Meizi</td><td>vue-Meizi - vue最新实战项目</td><td><a href="https://github.com/liangxiaojuan/vue-Meizi" target="_blank" rel="noopener">https://github.com/liangxiaojuan/vue-Meizi</a></td></tr><tr><td>zhihudaily-vue</td><td>zhihudaily-vue - 知乎日报web版</td><td><a href="https://github.com/yatessss/zhihudaily-vue" target="_blank" rel="noopener">https://github.com/yatessss/zhihudaily-vue</a></td></tr><tr><td>vue-demo-kugou</td><td>vue-demo-kugou - vuejs仿写酷狗音乐webapp</td><td><a href="https://github.com/lavyun/vue-demo-kugou" target="_blank" rel="noopener">https://github.com/lavyun/vue-demo-kugou</a></td></tr><tr><td>VueDemo_Sell_Eleme</td><td>VueDemo_Sell_Eleme - Vue2高仿饿了么外卖平台</td><td><a href="https://github.com/SimonZhangITer/VueDemo_Sell_Eleme" target="_blank" rel="noopener">https://github.com/SimonZhangITer/VueDemo_Sell_Eleme</a></td></tr><tr><td>vue2.0-taopiaopiao</td><td>vue2.0-taopiaopiao - vue2.0与express构建淘票票页面</td><td><a href="https://github.com/canfoo/vue2.0-taopiaopiao" target="_blank" rel="noopener">https://github.com/canfoo/vue2.0-taopiaopiao</a></td></tr><tr><td>vue-leancloud-blog</td><td>vue-leancloud-blog - 一个前后端完全分离的单页应用</td><td><a href="https://github.com/jiangjiu/vue-leancloud-blog" target="_blank" rel="noopener">https://github.com/jiangjiu/vue-leancloud-blog</a></td></tr><tr><td>node-vue-server-webpack</td><td>node-vue-server-webpack - Node.js+Vue.js+webpack快速开发框架</td><td><a href="https://github.com/yjj5855/node-vue-server-webpack" target="_blank" rel="noopener">https://github.com/yjj5855/node-vue-server-webpack</a></td></tr><tr><td>mi-by-vue</td><td>mi-by-vue - VueJS仿小米官网</td><td><a href="https://github.com/wendaosanshou/mi-by-vue" target="_blank" rel="noopener">https://github.com/wendaosanshou/mi-by-vue</a></td></tr><tr><td>vue-fis3</td><td>vue-fis3 - 流行开源工具集成demo</td><td><a href="https://github.com/okoala/vue-fis3" target="_blank" rel="noopener">https://github.com/okoala/vue-fis3</a></td></tr><tr><td>vue2.x-douban</td><td>vue2.x-douban - Vue2实现简易豆瓣电影webApp</td><td><a href="https://github.com/superman66/vue2.x-douban" target="_blank" rel="noopener">https://github.com/superman66/vue2.x-douban</a></td></tr><tr><td>vue-demo-maizuo</td><td>vue-demo-maizuo - 使用Vue2全家桶仿制卖座电影</td><td><a href="https://github.com/ChuckCZC/vue-demo-maizuo" target="_blank" rel="noopener">https://github.com/ChuckCZC/vue-demo-maizuo</a></td></tr><tr><td>vue-zhihudaily</td><td>vue-zhihudaily - 知乎日报 Web 版本</td><td><a href="https://github.com/iHaPBoy/vue-zhihudaily" target="_blank" rel="noopener">https://github.com/iHaPBoy/vue-zhihudaily</a></td></tr><tr><td>vue-adminLte-vue-router</td><td>vue-adminLte-vue-router - vue和adminLte整合应用</td><td><a href="https://github.com/liujians/vue-adminLte-vue-router" target="_blank" rel="noopener">https://github.com/liujians/vue-adminLte-vue-router</a></td></tr><tr><td>vue-axios-github</td><td>vue-axios-github - 登录拦截登出功能</td><td><a href="https://github.com/superman66/vue-axios-github" target="_blank" rel="noopener">https://github.com/superman66/vue-axios-github</a></td></tr><tr><td>Zhihu-Daily-Vue.js</td><td>Zhihu-Daily-Vue.js - Vuejs单页网页应用</td><td><a href="https://github.com/pomelo-chuan/Zhihu-Daily-Vue.js" target="_blank" rel="noopener">https://github.com/pomelo-chuan/Zhihu-Daily-Vue.js</a></td></tr><tr><td>hello-vue-django</td><td>hello-vue-django - 使用带有Django的vuejs的样板项目</td><td><a href="https://github.com/rokups/hello-vue-django" target="_blank" rel="noopener">https://github.com/rokups/hello-vue-django</a></td></tr><tr><td>vue-cnode</td><td>vue-cnode - vue单页应用demo</td><td><a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">https://github.com/wszgxa/vue-cnode</a></td></tr><tr><td>x-blog</td><td>x-blog - 开源的个人blog项目</td><td><a href="https://github.com/CommanderXL/x-blog" target="_blank" rel="noopener">https://github.com/CommanderXL/x-blog</a></td></tr><tr><td>vue-express-mongodb</td><td>vue-express-mongodb - 简单的前后端分离案例</td><td><a href="https://github.com/xrr2016/vue-express-mongodb" target="_blank" rel="noopener">https://github.com/xrr2016/vue-express-mongodb</a></td></tr><tr><td>websocket_chat</td><td>websocket_chat - 基于vue和websocket的多人在线聊天室</td><td><a href="https://github.com/secreter/websocket_chat" target="_blank" rel="noopener">https://github.com/secreter/websocket_chat</a></td></tr><tr><td>photoShare</td><td>photoShare - 基于图片分享的社交平台</td><td><a href="https://github.com/beidan/photoShare" target="_blank" rel="noopener">https://github.com/beidan/photoShare</a></td></tr><tr><td>vue-zhihudaily-2.0</td><td>vue-zhihudaily-2.0 - 使用Vue2.0+vue-router+vuex创建的zhihudaily</td><td><a href="https://github.com/cs1707/vue-zhihudaily-2.0" target="_blank" rel="noopener">https://github.com/cs1707/vue-zhihudaily-2.0</a></td></tr><tr><td>notepad</td><td>notepad - 本地存储的记事本</td><td><a href="https://github.com/lin-xin/notepad" target="_blank" rel="noopener">https://github.com/lin-xin/notepad</a></td></tr><tr><td>vueBlog</td><td>vueBlog - 前后端分离博客</td><td><a href="https://github.com/elva2596/vueBlog" target="_blank" rel="noopener">https://github.com/elva2596/vueBlog</a></td></tr><tr><td>vue-ruby-china</td><td>vue-ruby-china - VueJS框架搭建的rubychina平台</td><td><a href="https://github.com/hql123/vue-ruby-china" target="_blank" rel="noopener">https://github.com/hql123/vue-ruby-china</a></td></tr><tr><td>Zhihu_Daily</td><td>Zhihu_Daily - 基于Vue和Nodejs的Web单页应用</td><td><a href="https://github.com/littlewin-wang/Zhihu_Daily" target="_blank" rel="noopener">https://github.com/littlewin-wang/Zhihu_Daily</a></td></tr><tr><td>vue-koa-demo</td><td>vue-koa-demo - 使用Vue2和Koa1的全栈demo</td><td><a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">https://github.com/Molunerfinn/vue-koa-demo</a></td></tr><tr><td>vue2.x-Cnode</td><td>vue2.x-Cnode - 基于vue全家桶的Cnode社区</td><td><a href="https://github.com/vincentSea/vue2.x-Cnode" target="_blank" rel="noopener">https://github.com/vincentSea/vue2.x-Cnode</a></td></tr><tr><td>life-app-vue</td><td>life-app-vue - 使用vue2完成多功能集合到小webapp</td><td><a href="https://github.com/shaqihe/life-app-vue" target="_blank" rel="noopener">https://github.com/shaqihe/life-app-vue</a></td></tr><tr><td>github-explorer</td><td>github-explorer - 寻找最有趣的GitHub库</td><td><a href="https://github.com/SidKwok/github-explorer" target="_blank" rel="noopener">https://github.com/SidKwok/github-explorer</a></td></tr><tr><td>vue-trip</td><td>vue-trip - vue2做的出行webapp</td><td><a href="https://github.com/wenye123/vue-trip" target="_blank" rel="noopener">https://github.com/wenye123/vue-trip</a></td></tr><tr><td>vue-ssr-boilerplate</td><td>vue-ssr-boilerplate - 精简版的ofvue-hackernews-2</td><td><a href="https://github.com/albertchan/vue-ssr-boilerplate" target="_blank" rel="noopener">https://github.com/albertchan/vue-ssr-boilerplate</a></td></tr><tr><td>vue-bushishiren</td><td>vue-bushishiren - 不是诗人应用</td><td><a href="https://github.com/nswbmw/vue-bushishiren" target="_blank" rel="noopener">https://github.com/nswbmw/vue-bushishiren</a></td></tr><tr><td>houtai</td><td>houtai - 基于vue和Element的后台管理系统</td><td><a href="https://github.com/peng1992/houtai" target="_blank" rel="noopener">https://github.com/peng1992/houtai</a></td></tr><tr><td>ios7-vue</td><td>ios7-vue - 使用vue2.0 vue-router vuex模拟ios7</td><td><a href="https://github.com/QRL909109/ios7-vue" target="_blank" rel="noopener">https://github.com/QRL909109/ios7-vue</a></td></tr><tr><td>Framework7-VueJS</td><td>Framework7-VueJS - 使用移动框架的示例</td><td><a href="https://github.com/tyllo/Framework7-VueJS" target="_blank" rel="noopener">https://github.com/tyllo/Framework7-VueJS</a></td></tr><tr><td>cnode-vue</td><td>cnode-vue - 基于vue和vue-router构建的cnodejs web网站SPA</td><td><a href="https://github.com/BubblyPoker/cnode-vue" target="_blank" rel="noopener">https://github.com/BubblyPoker/cnode-vue</a></td></tr><tr><td>vue-cli-multipage-bootstrap</td><td>vue-cli-multipage-bootstrap - 将vue官方在线示例整合到组件中</td><td><a href="https://github.com/zhoou/vue-cli-multipage-bootstrap" target="_blank" rel="noopener">https://github.com/zhoou/vue-cli-multipage-bootstrap</a></td></tr><tr><td>vue-cnode</td><td>vue-cnode - 用 Vue 做的 CNode 官网</td><td><a href="https://github.com/jiananle/vue-cnode" target="_blank" rel="noopener">https://github.com/jiananle/vue-cnode</a></td></tr><tr><td>HyaReader</td><td>HyaReader - 移动友好的阅读器</td><td><a href="https://github.com/GitaiQAQ/HyaReader" target="_blank" rel="noopener">https://github.com/GitaiQAQ/HyaReader</a></td></tr><tr><td>zhihu-daily</td><td>zhihu-daily - 轻松查看知乎日报内容</td><td><a href="https://github.com/xrr2016/zhihu-daily" target="_blank" rel="noopener">https://github.com/xrr2016/zhihu-daily</a></td></tr><tr><td>seeMusic</td><td>seeMusic - 跨平台云音乐播放器</td><td><a href="https://github.com/Alex-xd/seeMusic" target="_blank" rel="noopener">https://github.com/Alex-xd/seeMusic</a></td></tr><tr><td>vue-cnode</td><td>vue-cnode - 使用cNode社区提供的接口</td><td><a href="https://github.com/Damonlw/vue-cnode" target="_blank" rel="noopener">https://github.com/Damonlw/vue-cnode</a></td></tr><tr><td>zhihu-daily-vue</td><td>zhihu-daily-vue - 知乎日报</td><td><a href="https://github.com/moonou/zhihu-daily-vue" target="_blank" rel="noopener">https://github.com/moonou/zhihu-daily-vue</a></td></tr><tr><td>sls-vuex2-demo</td><td>sls-vuex2-demo - vuex2商城购物车demo</td><td><a href="https://github.com/sailengsi/sls-vuex2-demo" target="_blank" rel="noopener">https://github.com/sailengsi/sls-vuex2-demo</a></td></tr><tr><td>vue-dropload</td><td>vue-dropload - 用以测试下拉加载与简单路由</td><td><a href="https://github.com/ITCNZ/vue-dropload" target="_blank" rel="noopener">https://github.com/ITCNZ/vue-dropload</a></td></tr><tr><td>vue-cnode-mobile</td><td>vue-cnode-mobile - 搭建cnode社区</td><td><a href="https://github.com/soulcm/vue-cnode-mobile" target="_blank" rel="noopener">https://github.com/soulcm/vue-cnode-mobile</a></td></tr><tr><td>Vuejs-SalePlatform</td><td>Vuejs-SalePlatform - vuejs搭建的售卖平台demo</td><td><a href="https://github.com/fishenal/Vuejs-SalePlatform" target="_blank" rel="noopener">https://github.com/fishenal/Vuejs-SalePlatform</a></td></tr><tr><td>v-notes</td><td>v-notes - 简单美观的记事本</td><td><a href="https://github.com/Halfeld/v-notes" target="_blank" rel="noopener">https://github.com/Halfeld/v-notes</a></td></tr><tr><td>vue-starter</td><td>vue-starter - VueJs项目的简单启动页</td><td><a href="https://github.com/BosNaufal/vue-starter" target="_blank" rel="noopener">https://github.com/BosNaufal/vue-starter</a></td></tr><tr><td>vue-memo</td><td>vue-memo - 用 vue写的记事本应用</td><td><a href="https://github.com/youknowznm/vue-memo" target="_blank" rel="noopener">https://github.com/youknowznm/vue-memo</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给文章加bgm</title>
      <link href="//posts/3090f597.html"/>
      <url>//posts/3090f597.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">给文章加bgm</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-12</span><span class="bullet">-30</span></span><br><span class="line"><span class="attr">music:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">song</span>        <span class="comment"># song （单曲） album （专辑） playlist （歌单） search （搜索）</span></span><br><span class="line"><span class="attr">  id:</span> <span class="number">26664345</span>      <span class="comment"># 歌曲/专辑/歌单 ID</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客文档 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
